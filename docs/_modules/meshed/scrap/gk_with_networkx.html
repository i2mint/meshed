<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>meshed.scrap.gk_with_networkx &mdash; meshed 0.1.90 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script src="../../../_static/toggleprompt.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> meshed
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed.html">meshed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/base.html">meshed.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/caching.html">meshed.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/composition.html">meshed.composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/dag.html">meshed.dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/examples/online_marketing.html">meshed.examples.online_marketing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/examples/price_elasticity.html">meshed.examples.price_elasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/examples/vaccine_vs_no_vaccine.html">meshed.examples.vaccine_vs_no_vaccine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/ext.html">meshed.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/ext/gk.html">meshed.ext.gk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/ext/gk_tests.html">meshed.ext.gk_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/itools.html">meshed.itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/makers.html">meshed.makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/scrap.html">meshed.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/scrap/cached_dag.html">meshed.scrap.cached_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/scrap/dask_graph_language.html">meshed.scrap.dask_graph_language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/scrap/gk_with_networkx.html">meshed.scrap.gk_with_networkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/scrap/misc_utils.html">meshed.scrap.misc_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/scrap/wrapping_dags.html">meshed.scrap.wrapping_dags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests.html">meshed.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_base.html">meshed.tests.test_base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_caching.html">meshed.tests.test_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_composition.html">meshed.tests.test_composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_dag.html">meshed.tests.test_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_dag_2.html">meshed.tests.test_dag_2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_dag_defaults.html">meshed.tests.test_dag_defaults</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_dag_variadics.html">meshed.tests.test_dag_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_getitem.html">meshed.tests.test_getitem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_itools.html">meshed.tests.test_itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_makers.html">meshed.tests.test_makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/test_util.html">meshed.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/tests/utils_for_testing.html">meshed.tests.utils_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_docs/meshed/util.html">meshed.util</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">meshed</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>meshed.scrap.gk_with_networkx</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for meshed.scrap.gk_with_networkx</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">seriously modified version of yahoo/graphkit</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># ---------- base --------------------------------------------------------------</span>


<div class="viewcode-block" id="Data"><a class="viewcode-back" href="../../../module_docs/meshed/scrap/gk_with_networkx.html#meshed.scrap.gk_with_networkx.Data">[docs]</a><span class="k">class</span> <span class="nc">Data</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This wraps any data that is consumed or produced</span>
<span class="sd">    by a Operation. This data should also know how to serialize</span>
<span class="sd">    itself appropriately.</span>
<span class="sd">    This class an &quot;abstract&quot; class that should be extended by</span>
<span class="sd">    any class working with data in the HiC framework.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">set_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>


<div class="viewcode-block" id="Operation"><a class="viewcode-back" href="../../../module_docs/meshed/scrap/gk_with_networkx.html#meshed.scrap.gk_with_networkx.Operation">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Operation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is an abstract class representing a data transformation. To use this,</span>
<span class="sd">    please inherit from this class and customize the ``.compute`` method to your</span>
<span class="sd">    specific application.</span>

<span class="sd">    Names may be given to this layer and its inputs and outputs. This is</span>
<span class="sd">    important when connecting layers and data in a Network object, as the</span>
<span class="sd">    names are used to construct the graph.</span>
<span class="sd">    :param str name: The name the operation (e.g. conv1, conv2, etc..)</span>
<span class="sd">    :param list needs: Names of input data objects this layer requires.</span>
<span class="sd">    :param list provides: Names of output data objects this provides.</span>
<span class="sd">    :param dict params: A dict of key/value pairs representing parameters</span>
<span class="sd">                        associated with your operation. These values will be</span>
<span class="sd">                        accessible using the ``.params`` attribute of your object.</span>
<span class="sd">                        NOTE: It&#39;s important that any values stored in this</span>
<span class="sd">                        argument must be pickelable.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span>
    <span class="n">needs</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">provides</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is a hook for you to override. It gets called after this</span>
<span class="sd">        object has been initialized with its ``needs``, ``provides``, ``name``,</span>
<span class="sd">        and ``params`` attributes. People often override this method to implement</span>
<span class="sd">        custom loading logic required for objects that do not pickle easily, and</span>
<span class="sd">        for initialization of c++ dependencies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operation equality is based on name of layer.</span>
<span class="sd">        (__eq__ and __hash__ must be overridden together)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Operation equality is based on name of layer.</span>
<span class="sd">        (__eq__ and __hash__ must be overridden together)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="Operation.compute"><a class="viewcode-back" href="../../../module_docs/meshed/scrap/gk_with_networkx.html#meshed.scrap.gk_with_networkx.Operation.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method must be implemented to perform this layer&#39;s feed-forward</span>
<span class="sd">        computation on a given set of inputs.</span>
<span class="sd">        :param list inputs:</span>
<span class="sd">            A list of :class:`Data` objects on which to run the layer&#39;s</span>
<span class="sd">            feed-forward computation.</span>
<span class="sd">        :returns list:</span>
<span class="sd">            Should return a list of :class:`Data` objects representing</span>
<span class="sd">            the results of running the feed-forward computation on</span>
<span class="sd">            ``inputs``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">named_inputs</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">needs</span><span class="p">]</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provides</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
            <span class="n">results</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This allows your operation to be pickled.</span>
<span class="sd">        Everything needed to instantiate your operation should be defined by the</span>
<span class="sd">        following attributes: params, needs, provides, and name</span>
<span class="sd">        No other piece of state should leak outside of these 4 variables</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># this check should get deprecated soon. its for downward compatibility</span>
        <span class="c1"># with earlier pickled operation objects</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;params&#39;</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;needs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;needs&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;provides&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;provides&#39;</span><span class="p">]</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        load from pickle and instantiate the detector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">state</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__postinit__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display more informative names for the Operation class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(name=&#39;</span><span class="si">%s</span><span class="s2">&#39;, needs=</span><span class="si">%s</span><span class="s2">, provides=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">needs</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">provides</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="NetworkOperation"><a class="viewcode-back" href="../../../module_docs/meshed/scrap/gk_with_networkx.html#meshed.scrap.gk_with_networkx.NetworkOperation">[docs]</a><span class="k">class</span> <span class="nc">NetworkOperation</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">net</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;net&#39;</span><span class="p">)</span>
        <span class="n">Operation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># set execution mode to single-threaded sequential by default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execution_method</span> <span class="o">=</span> <span class="s1">&#39;sequential&#39;</span>

    <span class="k">def</span> <span class="nf">_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">net</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">named_inputs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_execution_method</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<div class="viewcode-block" id="NetworkOperation.set_execution_method"><a class="viewcode-back" href="../../../module_docs/meshed/scrap/gk_with_networkx.html#meshed.scrap.gk_with_networkx.NetworkOperation.set_execution_method">[docs]</a>    <span class="k">def</span> <span class="nf">set_execution_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine how the network will be executed.</span>
<span class="sd">        Args:</span>
<span class="sd">            method: str</span>
<span class="sd">                If &quot;parallel&quot;, execute graph operations concurrently</span>
<span class="sd">                using a threadpool.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;parallel&#39;</span><span class="p">,</span> <span class="s1">&#39;sequential&#39;</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_execution_method</span> <span class="o">=</span> <span class="n">method</span></div>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">net</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">Operation</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;net&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;net&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state</span></div>


<span class="c1"># ------------ modifiers -------------------------------------------------------</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This sub-module contains input/output modifiers that can be applied to</span>
<span class="sd">arguments to ``needs`` and ``provides`` to let GraphKit know it should treat</span>
<span class="sd">them differently.</span>

<span class="sd">Copyright 2016, Yahoo Inc.</span>
<span class="sd">Licensed under the terms of the Apache License, Version 2.0. See the LICENSE</span>
<span class="sd">file associated with the project for terms.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="optional"><a class="viewcode-back" href="../../../module_docs/meshed/scrap/gk_with_networkx.html#meshed.scrap.gk_with_networkx.optional">[docs]</a><span class="k">class</span> <span class="nc">optional</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Input values in ``needs`` may be designated as optional using this modifier.</span>
<span class="sd">    If this modifier is applied to an input value, that value will be input to</span>
<span class="sd">    the ``operation`` if it is available.  The function underlying the</span>
<span class="sd">    ``operation`` should have a parameter with the same name as the input value</span>
<span class="sd">    in ``needs``, and the input value will be passed as a keyword argument if</span>
<span class="sd">    it is available.</span>

<span class="sd">    Here is an example of an operation that uses an optional argument::</span>

<span class="sd">        from graphkit import operation, compose</span>
<span class="sd">        from graphkit.modifiers import optional</span>

<span class="sd">        # Function that adds either two or three numbers.</span>
<span class="sd">        def myadd(a, b, c=0):</span>
<span class="sd">            return a + b + c</span>

<span class="sd">        # Designate c as an optional argument.</span>
<span class="sd">        graph = compose(&#39;mygraph&#39;)(</span>
<span class="sd">            operator(name=&#39;myadd&#39;, needs=[&#39;a&#39;, &#39;b&#39;, optional(&#39;c&#39;)], provides=&#39;sum&#39;)(myadd)</span>
<span class="sd">        )</span>

<span class="sd">        # The graph works with and without &#39;c&#39; provided as input.</span>
<span class="sd">        assert graph({&#39;a&#39;: 5, &#39;b&#39;: 2, &#39;c&#39;: 4})[&#39;sum&#39;] == 11</span>
<span class="sd">        assert graph({&#39;a&#39;: 5, &#39;b&#39;: 2})[&#39;sum&#39;] == 7</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span></div>


<span class="c1"># ------------ network ------------------------------------------------------</span>

<span class="c1"># Copyright 2016, Yahoo Inc.</span>
<span class="c1"># Licensed under the terms of the Apache License, Version 2.0. See the LICENSE file associated with the project for terms.</span>


<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>

<span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">time</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

    <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>

    <span class="c1"># uses base.Operation</span>

    <span class="k">class</span> <span class="nc">DataPlaceholderNode</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A node for the Network graph that describes the name of a Data instance</span>
<span class="sd">        produced or required by a layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;DataPlaceholderNode(&quot;</span><span class="si">%s</span><span class="s1">&quot;)&#39;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">class</span> <span class="nc">DeleteInstruction</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An instruction for the compiled list of evaluation steps to free or delete</span>
<span class="sd">        a Data instance from the Network&#39;s cache after it is no longer needed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;DeleteInstruction(&quot;</span><span class="si">%s</span><span class="s1">&quot;)&#39;</span> <span class="o">%</span> <span class="bp">self</span>

    <span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the main network implementation. The class contains all of the</span>
<span class="sd">        code necessary to weave together operations into a directed-acyclic-graph (DAG)</span>
<span class="sd">        and pass data through.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; &quot;&quot;&quot;</span>

            <span class="c1"># directed graph of layer instances and data-names defining the net.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

            <span class="c1"># this holds the timing information for eache layer</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># a compiled list of steps to evaluate layers *in order* and free mem.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># This holds a cache of results for the _find_necessary_steps</span>
            <span class="c1"># function, this helps speed up the compute call as well avoid</span>
            <span class="c1"># a multithreading issue that is occuring when accessing the</span>
            <span class="c1"># graph in networkx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_steps_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">add_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">operation</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Adds the given operation and its data requirements to the network graph</span>
<span class="sd">            based on the name of the operation, the names of the operation&#39;s needs, and</span>
<span class="sd">            the names of the data it provides.</span>

<span class="sd">            :param Operation operation: Operation object to add.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># assert layer and its data requirements are named.</span>
            <span class="k">assert</span> <span class="n">operation</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;Operation must be named&#39;</span>
            <span class="k">assert</span> <span class="n">operation</span><span class="o">.</span><span class="n">needs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Operation&#39;s &#39;needs&#39; must be named&quot;</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">operation</span><span class="o">.</span><span class="n">provides</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;Operation&#39;s &#39;provides&#39; must be named&quot;</span>

            <span class="c1"># assert layer is only added once to graph</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">operation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
            <span class="p">),</span> <span class="s1">&#39;Operation may only be added once&#39;</span>

            <span class="c1"># add nodes and edges to graph describing the data needs for this layer</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">operation</span><span class="o">.</span><span class="n">needs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">DataPlaceholderNode</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">operation</span><span class="p">)</span>

            <span class="c1"># add nodes and edges to graph describing what this layer provides</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">operation</span><span class="o">.</span><span class="n">provides</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">DataPlaceholderNode</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

            <span class="c1"># clear compiled steps (must recompile after adding new layers)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span> <span class="nf">list_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps</span><span class="p">,</span> <span class="s1">&#39;network must be compiled before listing layers.&#39;</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Operation</span><span class="p">)]</span>

        <span class="k">def</span> <span class="nf">show_layers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Shows info (name, needs, and provides) about all layers in this network.&quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_layers</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;layer_name: &#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;needs: &#39;</span><span class="p">,</span> <span class="n">step</span><span class="o">.</span><span class="n">needs</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;provides: &#39;</span><span class="p">,</span> <span class="n">step</span><span class="o">.</span><span class="n">provides</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Create a set of steps for evaluating layers</span>
<span class="sd">            and freeing memory as necessary&quot;&quot;&quot;</span>

            <span class="c1"># clear compiled steps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># create an execution order such that each layer&#39;s needs are provided.</span>
            <span class="n">ordered_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>

            <span class="c1"># add Operations evaluation steps, and instructions to free data.</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ordered_nodes</span><span class="p">):</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">DataPlaceholderNode</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>

                    <span class="c1"># add layer to list of steps</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                    <span class="c1"># Add instructions to delete predecessors as possible.  A</span>
                    <span class="c1"># predecessor may be deleted if it is a data placeholder that</span>
                    <span class="c1"># is no longer needed by future Operations.</span>
                    <span class="k">for</span> <span class="n">predecessor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;checking if node </span><span class="si">%s</span><span class="s1"> can be deleted&#39;</span> <span class="o">%</span> <span class="n">predecessor</span><span class="p">)</span>
                        <span class="n">predecessor_still_needed</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">for</span> <span class="n">future_node</span> <span class="ow">in</span> <span class="n">ordered_nodes</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]:</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">future_node</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">predecessor</span> <span class="ow">in</span> <span class="n">future_node</span><span class="o">.</span><span class="n">needs</span><span class="p">:</span>
                                    <span class="n">predecessor_still_needed</span> <span class="o">=</span> <span class="kc">True</span>
                                    <span class="k">break</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">predecessor_still_needed</span><span class="p">:</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="s1">&#39;  adding delete instruction for </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">predecessor</span>
                                <span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DeleteInstruction</span><span class="p">(</span><span class="n">predecessor</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized network graph node&#39;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_find_necessary_steps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Determines what graph steps need to pe run to get to the requested</span>
<span class="sd">            outputs from the provided inputs.  Eliminates steps that come before</span>
<span class="sd">            (in topological order) any inputs that have been provided.  Also</span>
<span class="sd">            eliminates steps that are not on a path from he provided inputs to</span>
<span class="sd">            the requested outputs.</span>

<span class="sd">            :param list outputs:</span>
<span class="sd">                A list of desired output names.  This can also be ``None``, in which</span>
<span class="sd">                case the necessary steps are all graph nodes that are reachable</span>
<span class="sd">                from one of the provided inputs.</span>

<span class="sd">            :param dict inputs:</span>
<span class="sd">                A dictionary mapping names to values for all provided inputs.</span>

<span class="sd">            :returns:</span>
<span class="sd">                Returns a list of all the steps that need to be run for the</span>
<span class="sd">                provided inputs and requested outputs.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># return steps if it has already been computed before for this set of inputs and outputs</span>
            <span class="n">outputs</span> <span class="o">=</span> <span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">outputs</span><span class="p">))</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">))</span> <span class="k">else</span> <span class="n">outputs</span>
            <span class="p">)</span>
            <span class="n">inputs_keys</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="n">cache_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputs_keys</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cache_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_steps_cache</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_steps_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span>

            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">outputs</span><span class="p">:</span>

                <span class="c1"># If caller requested all outputs, the necessary nodes are all</span>
                <span class="c1"># nodes that are reachable from one of the inputs.  Ignore input</span>
                <span class="c1"># names that aren&#39;t in the graph.</span>
                <span class="n">necessary_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">input_name</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">input_name</span><span class="p">):</span>
                        <span class="n">necessary_nodes</span> <span class="o">|=</span> <span class="n">nx</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">input_name</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># If the caller requested a subset of outputs, find any nodes that</span>
                <span class="c1"># are made unecessary because we were provided with an input that&#39;s</span>
                <span class="c1"># deeper into the network graph.  Ignore input names that aren&#39;t</span>
                <span class="c1"># in the graph.</span>
                <span class="n">unnecessary_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">input_name</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">inputs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">input_name</span><span class="p">):</span>
                        <span class="n">unnecessary_nodes</span> <span class="o">|=</span> <span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">input_name</span><span class="p">)</span>

                <span class="c1"># Find the nodes we need to be able to compute the requested</span>
                <span class="c1"># outputs.  Raise an exception if a requested output doesn&#39;t</span>
                <span class="c1"># exist in the graph.</span>
                <span class="n">necessary_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">output_name</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">output_name</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s1">&#39;graphkit graph does not have an output &#39;</span>
                            <span class="s1">&#39;node named </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">output_name</span>
                        <span class="p">)</span>
                    <span class="n">necessary_nodes</span> <span class="o">|=</span> <span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">output_name</span><span class="p">)</span>

                <span class="c1"># Get rid of the unnecessary nodes from the set of necessary ones.</span>
                <span class="n">necessary_nodes</span> <span class="o">-=</span> <span class="n">unnecessary_nodes</span>

            <span class="n">necessary_steps</span> <span class="o">=</span> <span class="p">[</span><span class="n">step</span> <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps</span> <span class="k">if</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">necessary_nodes</span><span class="p">]</span>

            <span class="c1"># save this result in a precomputed cache for future lookup</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_necessary_steps_cache</span><span class="p">[</span><span class="n">cache_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">necessary_steps</span>

            <span class="c1"># Return an ordered list of the needed steps.</span>
            <span class="k">return</span> <span class="n">necessary_steps</span>

        <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">named_inputs</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Run the graph. Any inputs to the network must be passed in by name.</span>

<span class="sd">            :param list output: The names of the data node you&#39;d like to have returned</span>
<span class="sd">                                once all necessary computations are complete.</span>
<span class="sd">                                If you set this variable to ``None``, all</span>
<span class="sd">                                data nodes will be kept and returned at runtime.</span>

<span class="sd">            :param dict named_inputs: A dict of key/value pairs where the keys</span>
<span class="sd">                                      represent the data nodes you want to populate,</span>
<span class="sd">                                      and the values are the concrete values you</span>
<span class="sd">                                      want to set for the data node.</span>


<span class="sd">            :returns: a dictionary of output data objects, keyed by name.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="c1"># assert that network has been compiled</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps</span><span class="p">,</span> <span class="s1">&#39;network must be compiled before calling compute.&#39;</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">or</span> <span class="n">outputs</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s1">&#39;The outputs argument must be a list&#39;</span>

            <span class="c1"># choose a method of execution</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;parallel&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_thread_pool_barrier_method</span><span class="p">(</span><span class="n">named_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sequential_method</span><span class="p">(</span><span class="n">named_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_compute_thread_pool_barrier_method</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">named_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">thread_pool_size</span><span class="o">=</span><span class="mi">10</span>
        <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This method runs the graph using a parallel pool of thread executors.</span>
<span class="sd">            You may achieve lower total latency if your graph is sufficiently</span>
<span class="sd">            sub divided into operations using this method.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="kn">from</span> <span class="nn">multiprocessing.dummy</span> <span class="kn">import</span> <span class="n">Pool</span>

            <span class="c1"># if we have not already created a thread_pool, create one</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_thread_pool&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_thread_pool</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="n">thread_pool_size</span><span class="p">)</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_thread_pool</span>

            <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">named_inputs</span><span class="p">)</span>
            <span class="n">necessary_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_necessary_steps</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">named_inputs</span><span class="p">)</span>

            <span class="c1"># this keeps track of all nodes that have already executed</span>
            <span class="n">has_executed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="c1"># with each loop iteration, we determine a set of operations that can be</span>
            <span class="c1"># scheduled, then schedule them onto a thread pool, then collect their</span>
            <span class="c1"># results onto a memory cache for use upon the next iteration.</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>

                <span class="c1"># the upnext list contains a list of operations for scheduling</span>
                <span class="c1"># in the current round of scheduling</span>
                <span class="n">upnext</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">necessary_nodes</span><span class="p">:</span>
                    <span class="c1"># only delete if all successors for the data node have been executed</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">DeleteInstruction</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">ready_to_delete_data_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">has_executed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                                <span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                    <span class="c1"># continue if this node is anything but an operation node</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>
                        <span class="k">continue</span>

                    <span class="k">if</span> <span class="p">(</span>
                        <span class="n">ready_to_schedule_operation</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">has_executed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">has_executed</span>
                    <span class="p">):</span>
                        <span class="n">upnext</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># stop if no nodes left to schedule, exit out of the loop</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">upnext</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>

                <span class="n">done_iterator</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">imap_unordered</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">op</span><span class="p">:</span> <span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">_compute</span><span class="p">(</span><span class="n">cache</span><span class="p">)),</span> <span class="n">upnext</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">done_iterator</span><span class="p">:</span>
                    <span class="n">cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
                    <span class="n">has_executed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">outputs</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">cache</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">_compute_sequential_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This method runs the graph one operation at a time in a single thread</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># start with fresh data cache</span>
            <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># add inputs to data cache</span>
            <span class="n">cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">named_inputs</span><span class="p">)</span>

            <span class="c1"># Find the subset of steps we need to run to get to the requested</span>
            <span class="c1"># outputs from the provided inputs.</span>
            <span class="n">all_steps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_necessary_steps</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">named_inputs</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">all_steps</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">Operation</span><span class="p">):</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;-&#39;</span> <span class="o">*</span> <span class="mi">32</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;executing step: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">step</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

                    <span class="c1"># time execution...</span>
                    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

                    <span class="c1"># compute layer outputs</span>
                    <span class="n">layer_outputs</span> <span class="o">=</span> <span class="n">step</span><span class="o">.</span><span class="n">_compute</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>

                    <span class="c1"># add outputs to cache</span>
                    <span class="n">cache</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">layer_outputs</span><span class="p">)</span>

                    <span class="c1"># record execution time</span>
                    <span class="n">t_complete</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">step</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">t_complete</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;step completion time: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">t_complete</span><span class="p">)</span>

                <span class="c1"># Process DeleteInstructions by deleting the corresponding data</span>
                <span class="c1"># if possible.</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">DeleteInstruction</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">outputs</span> <span class="ow">and</span> <span class="n">step</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
                        <span class="c1"># Some DeleteInstruction steps may not exist in the cache</span>
                        <span class="c1"># if they come from optional() needs that are not privoded</span>
                        <span class="c1"># as inputs.  Make sure the step exists before deleting.</span>
                        <span class="k">if</span> <span class="n">step</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_debug</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;removing data &#39;</span><span class="si">%s</span><span class="s2">&#39; from cache.&quot;</span> <span class="o">%</span> <span class="n">step</span><span class="p">)</span>
                            <span class="n">cache</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Unrecognized instruction.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">outputs</span><span class="p">:</span>
                <span class="c1"># Return the whole cache as output, including input and</span>
                <span class="c1"># intermediate data nodes.</span>
                <span class="k">return</span> <span class="n">cache</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Filter outputs to just return what&#39;s needed.</span>
                <span class="c1"># Note: list comprehensions exist in python 2.7+</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">cache</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Plot the graph.</span>

<span class="sd">            params:</span>
<span class="sd">            :param str filename:</span>
<span class="sd">                Write the output to a png, pdf, or graphviz dot file. The extension</span>
<span class="sd">                controls the output format.</span>

<span class="sd">            :param boolean show:</span>
<span class="sd">                If this is set to True, use matplotlib to show the graph diagram</span>
<span class="sd">                (Default: False)</span>

<span class="sd">            :returns:</span>
<span class="sd">                An instance of the pydot graph</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>

            <span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">pydot</span>
                <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
                <span class="kn">import</span> <span class="nn">matplotlib.image</span> <span class="k">as</span> <span class="nn">mpimg</span>

                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

                <span class="k">def</span> <span class="nf">get_node_name</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">DataPlaceholderNode</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">a</span>
                    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">name</span>

                <span class="n">g</span> <span class="o">=</span> <span class="n">pydot</span><span class="o">.</span><span class="n">Dot</span><span class="p">(</span><span class="n">graph_type</span><span class="o">=</span><span class="s1">&#39;digraph&#39;</span><span class="p">)</span>

                <span class="c1"># draw nodes</span>
                <span class="k">for</span> <span class="n">nx_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nx_node</span><span class="p">,</span> <span class="n">DataPlaceholderNode</span><span class="p">):</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">pydot</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">nx_node</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;rect&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">pydot</span><span class="o">.</span><span class="n">Node</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">nx_node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="s1">&#39;circle&#39;</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

                <span class="c1"># draw edges</span>
                <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                    <span class="n">src_name</span> <span class="o">=</span> <span class="n">get_node_name</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
                    <span class="n">dst_name</span> <span class="o">=</span> <span class="n">get_node_name</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span>
                    <span class="n">edge</span> <span class="o">=</span> <span class="n">pydot</span><span class="o">.</span><span class="n">Edge</span><span class="p">(</span><span class="n">src</span><span class="o">=</span><span class="n">src_name</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="n">dst_name</span><span class="p">)</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

                <span class="c1"># save plot</span>
                <span class="k">if</span> <span class="n">filename</span><span class="p">:</span>
                    <span class="n">basename</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;.png&#39;</span><span class="p">:</span>
                            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">create_png</span><span class="p">())</span>
                        <span class="k">elif</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;.dot&#39;</span><span class="p">:</span>
                            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">to_string</span><span class="p">())</span>
                        <span class="k">elif</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;.jpeg&#39;</span><span class="p">]:</span>
                            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">create_jpeg</span><span class="p">())</span>
                        <span class="k">elif</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;.pdf&#39;</span><span class="p">:</span>
                            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">create_pdf</span><span class="p">())</span>
                        <span class="k">elif</span> <span class="n">ext</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;.svg&#39;</span><span class="p">:</span>
                            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">create_svg</span><span class="p">())</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                                <span class="s1">&#39;Unknown file format for saving graph: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">ext</span>
                            <span class="p">)</span>

                <span class="c1"># display graph via matplotlib</span>
                <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
                    <span class="n">png</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">create_png</span><span class="p">()</span>
                    <span class="n">sio</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">(</span><span class="n">png</span><span class="p">)</span>
                    <span class="n">img</span> <span class="o">=</span> <span class="n">mpimg</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">sio</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

                <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">ready_to_schedule_operation</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">has_executed</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if a Operation is ready to be scheduled for execution based on</span>
<span class="sd">        what has already been executed.</span>

<span class="sd">        Args:</span>
<span class="sd">            op:</span>
<span class="sd">                The Operation object to check</span>
<span class="sd">            has_executed: set</span>
<span class="sd">                A set containing all operations that have been executed so far</span>
<span class="sd">            graph:</span>
<span class="sd">                The networkx graph containing the operations and data nodes</span>
<span class="sd">        Returns:</span>
<span class="sd">            A boolean indicating whether the operation may be scheduled for</span>
<span class="sd">            execution based on what has already been executed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dependencies</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Operation</span><span class="p">),</span> <span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">op</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">dependencies</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">has_executed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ready_to_delete_data_node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">has_executed</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines if a DataPlaceholderNode is ready to be deleted from the</span>
<span class="sd">        cache.</span>

<span class="sd">        Args:</span>
<span class="sd">            name:</span>
<span class="sd">                The name of the data node to check</span>
<span class="sd">            has_executed: set</span>
<span class="sd">                A set containing all operations that have been executed so far</span>
<span class="sd">            graph:</span>
<span class="sd">                The networkx graph containing the operations and data nodes</span>
<span class="sd">        Returns:</span>
<span class="sd">            A boolean indicating whether the data node can be deleted or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data_node</span> <span class="o">=</span> <span class="n">get_data_node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">graph</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">data_node</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">has_executed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_data_node</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">graph</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets a data node from a graph using its name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">name</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">DataPlaceholderNode</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">node</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># ------------ functional ------------------------------------------------------</span>

    <span class="c1"># Copyright 2016, Yahoo Inc.</span>
    <span class="c1"># Licensed under the terms of the Apache License, Version 2.0. See the LICENSE file associated with the project for terms.</span>

    <span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

    <span class="c1"># uses Operation, NetworkOperation from base</span>
    <span class="c1"># uses Network from network</span>

    <span class="k">class</span> <span class="nc">FunctionalOperation</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;fn&#39;</span><span class="p">)</span>
            <span class="n">Operation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_compute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">named_inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">named_inputs</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">needs</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">optional</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="c1"># Find any optional inputs in named_inputs.  Get only the ones that</span>
            <span class="c1"># are present there, no extra `None`s.</span>
            <span class="n">optionals</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">n</span><span class="p">:</span> <span class="n">named_inputs</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">needs</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">optional</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">named_inputs</span>
            <span class="p">}</span>

            <span class="c1"># Combine params and optionals into one big glob of keyword arguments.</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">optionals</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provides</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">result</span><span class="p">]</span>

            <span class="n">result</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">provides</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">outputs</span><span class="p">:</span>
                <span class="n">outputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">Operation</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">state</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">state</span>

    <span class="k">class</span> <span class="nc">operation</span><span class="p">(</span><span class="n">Operation</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This object represents an operation in a computation graph.  Its</span>
<span class="sd">        relationship to other operations in the graph is specified via its</span>
<span class="sd">        ``needs`` and ``provides`` arguments.</span>

<span class="sd">        :param function fn:</span>
<span class="sd">            The function used by this operation.  This does not need to be</span>
<span class="sd">            specified when the operation object is instantiated and can instead</span>
<span class="sd">            be set via ``__call__`` later.</span>

<span class="sd">        :param str name:</span>
<span class="sd">            The name of the operation in the computation graph.</span>

<span class="sd">        :param list needs:</span>
<span class="sd">            Names of input data objects this operation requires.  These should</span>
<span class="sd">            correspond to the ``args`` of ``fn``.</span>

<span class="sd">        :param list provides:</span>
<span class="sd">            Names of output data objects this operation provides.</span>

<span class="sd">        :param dict params:</span>
<span class="sd">            A dict of key/value pairs representing constant parameters</span>
<span class="sd">            associated with your operation.  These can correspond to either</span>
<span class="sd">            ``args`` or ``kwargs`` of ``fn`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>
            <span class="n">Operation</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_normalize_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>

            <span class="c1"># Allow single value for needs parameter</span>
            <span class="k">if</span> <span class="s1">&#39;needs&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;needs&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;needs&#39;</span><span class="p">],</span> <span class="s1">&#39;empty string provided for `needs` parameters&#39;</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;needs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;needs&#39;</span><span class="p">]]</span>

            <span class="c1"># Allow single value for provides parameter</span>
            <span class="k">if</span> <span class="s1">&#39;provides&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;provides&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">kwargs</span><span class="p">[</span>
                    <span class="s1">&#39;provides&#39;</span>
                <span class="p">],</span> <span class="s1">&#39;empty string provided for `needs` parameters&#39;</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;provides&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;provides&#39;</span><span class="p">]]</span>

            <span class="k">assert</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="s1">&#39;operation needs a name&#39;</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;needs&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;no `needs` parameter provided&#39;</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;provides&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">,</span> <span class="s1">&#39;no `provides` parameter provided&#39;</span>
            <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">],</span> <span class="s1">&#39;__call__&#39;</span>
            <span class="p">),</span> <span class="s1">&#39;operation was not provided with a callable&#39;</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">dict</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">return</span> <span class="n">kwargs</span>

        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            This enables ``operation`` to act as a decorator or as a functional</span>
<span class="sd">            operation, for example::</span>

<span class="sd">                @operator(name=&#39;myadd1&#39;, needs=[&#39;a&#39;, &#39;b&#39;], provides=[&#39;c&#39;])</span>
<span class="sd">                def myadd(a, b):</span>
<span class="sd">                    return a + b</span>

<span class="sd">            or::</span>

<span class="sd">                def myadd(a, b):</span>
<span class="sd">                    return a + b</span>
<span class="sd">                operator(name=&#39;myadd1&#39;, needs=[&#39;a&#39;, &#39;b&#39;], provides=[&#39;c&#39;])(myadd)</span>

<span class="sd">            :param function fn:</span>
<span class="sd">                The function to be used by this ``operation``.</span>

<span class="sd">            :return:</span>
<span class="sd">                Returns an operation class that can be called as a function or</span>
<span class="sd">                composed into a computation graph.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="n">fn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fn</span> <span class="o">=</span> <span class="n">fn</span>

            <span class="n">total_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">total_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">total_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">total_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_kwargs</span><span class="p">(</span><span class="n">total_kwargs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">FunctionalOperation</span><span class="p">(</span><span class="o">**</span><span class="n">total_kwargs</span><span class="p">)</span>

        <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Display more informative names for the Operation class</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(name=&#39;</span><span class="si">%s</span><span class="s2">&#39;, needs=</span><span class="si">%s</span><span class="s2">, provides=</span><span class="si">%s</span><span class="s2">, fn=</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">needs</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">provides</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fn</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">class</span> <span class="nc">compose</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a simple class that&#39;s used to compose ``operation`` instances into</span>
<span class="sd">        a computation graph.</span>

<span class="sd">        :param str name:</span>
<span class="sd">            A name for the graph being composed by this object.</span>

<span class="sd">        :param bool merge:</span>
<span class="sd">            If ``True``, this compose object will attempt to merge together</span>
<span class="sd">            ``operation`` instances that represent entire computation graphs.</span>
<span class="sd">            Specifically, if one of the ``operation`` instances passed to this</span>
<span class="sd">            ``compose`` object is itself a graph operation created by an</span>
<span class="sd">            earlier use of ``compose`` the sub-operations in that graph are</span>
<span class="sd">            compared against other operations passed to this ``compose``</span>
<span class="sd">            instance (as well as the sub-operations of other graphs passed to</span>
<span class="sd">            this ``compose`` instance).  If any two operations are the same</span>
<span class="sd">            (based on name), then that operation is computed only once, instead</span>
<span class="sd">            of multiple times (one for each time the operation appears).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">merge</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;compose needs a name&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">merge</span> <span class="o">=</span> <span class="n">merge</span>

        <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">operations</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Composes a collection of operations into a single computation graph,</span>
<span class="sd">            obeying the ``merge`` property, if set in the constructor.</span>

<span class="sd">            :param operations:</span>
<span class="sd">                Each argument should be an operation instance created using</span>
<span class="sd">                ``operation``.</span>

<span class="sd">            :return:</span>
<span class="sd">                Returns a special type of operation class, which represents an</span>
<span class="sd">                entire computation graph as a single operation.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">operations</span><span class="p">),</span> <span class="s1">&#39;no operations provided to compose&#39;</span>

            <span class="c1"># If merge is desired, deduplicate operations before building network</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">merge</span><span class="p">:</span>
                <span class="n">merge_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">NetworkOperation</span><span class="p">):</span>
                        <span class="n">net_ops</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
                            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Operation</span><span class="p">),</span> <span class="n">op</span><span class="o">.</span><span class="n">net</span><span class="o">.</span><span class="n">steps</span>
                        <span class="p">)</span>
                        <span class="n">merge_set</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">net_ops</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">merge_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="n">operations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">merge_set</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">order_preserving_uniquifier</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">seen</span> <span class="o">=</span> <span class="n">seen</span> <span class="k">if</span> <span class="n">seen</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">seen_add</span> <span class="o">=</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span> <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">seen</span> <span class="ow">or</span> <span class="n">seen_add</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>

            <span class="n">provides</span> <span class="o">=</span> <span class="n">order_preserving_uniquifier</span><span class="p">(</span>
                <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">provides</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">needs</span> <span class="o">=</span> <span class="n">order_preserving_uniquifier</span><span class="p">(</span>
                <span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">op</span><span class="o">.</span><span class="n">needs</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">]),</span> <span class="nb">set</span><span class="p">(</span><span class="n">provides</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># compile network</span>
            <span class="n">net</span> <span class="o">=</span> <span class="n">Network</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">:</span>
                <span class="n">net</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="n">net</span><span class="o">.</span><span class="n">compile</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">NetworkOperation</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">needs</span><span class="o">=</span><span class="n">needs</span><span class="p">,</span> <span class="n">provides</span><span class="o">=</span><span class="n">provides</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{},</span> <span class="n">net</span><span class="o">=</span><span class="n">net</span>
            <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>