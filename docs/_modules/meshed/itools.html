
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>meshed.itools &#8212; meshed 0.1.12 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for meshed.itools</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Functions that provide iterators of g elements where g is any</span>
<span class="sd">adjacency Mapping representation.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">Sig</span>
<span class="kn">from</span> <span class="nn">meshed.makers</span> <span class="kn">import</span> <span class="n">edge_reversed_graph</span>


<span class="k">def</span> <span class="nf">_handle_exclude_nodes</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_exclude_nodes</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_exclude_nodes&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2"> doesn&#39;t have a _exclude_nodes argument&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_exclude_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_exclude_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_exclude_nodes</span><span class="p">,</span> <span class="nb">set</span><span class="p">):</span>
            <span class="n">_exclude_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_exclude_nodes</span><span class="p">)</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_exclude_nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_exclude_nodes</span>
        <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">args_and_kwargs_from_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_func</span>


<div class="viewcode-block" id="add_edge"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.add_edge">[docs]</a><span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Add an edge FROM node1 TO node2&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">node1</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="n">g</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">g</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">node2</span><span class="p">]</span></div>


<div class="viewcode-block" id="edges"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.edges">[docs]</a><span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; g = dict(a=&#39;c&#39;, b=&#39;ce&#39;, c=&#39;abde&#39;, d=&#39;c&#39;, e=[&#39;c&#39;, &#39;z&#39;], f={})</span>
<span class="sd">    &gt;&gt;&gt; sorted(edges(g))</span>
<span class="sd">    [(&#39;a&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;e&#39;), (&#39;c&#39;, &#39;a&#39;), (&#39;c&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;c&#39;, &#39;e&#39;), (&#39;d&#39;, &#39;c&#39;), (&#39;e&#39;, &#39;c&#39;), (&#39;e&#39;, &#39;z&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">src</span><span class="p">]:</span>
            <span class="k">yield</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span></div>


<div class="viewcode-block" id="nodes"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.nodes">[docs]</a><span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; g = dict(a=&#39;c&#39;, b=&#39;ce&#39;, c=&#39;abde&#39;, d=&#39;c&#39;, e=[&#39;c&#39;, &#39;z&#39;], f={})</span>
<span class="sd">    &gt;&gt;&gt; sorted(nodes(g))</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;z&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">src</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">src</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">src</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">dst</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">dst</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span></div>


<div class="viewcode-block" id="has_node"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.has_node">[docs]</a><span class="k">def</span> <span class="nf">has_node</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">check_adjacencies</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns True if the graph has given node</span>

<span class="sd">    &gt;&gt;&gt; g = {</span>
<span class="sd">    ...     0: [1, 2],</span>
<span class="sd">    ...     1: [2]</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; has_node(g, 0)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; has_node(g, 2)</span>
<span class="sd">    True</span>

<span class="sd">    Note that 2 was found, though it&#39;s not a key of ``g``.</span>
<span class="sd">    This shows that we don&#39;t have to have an explicit ``{2: []}`` in ``g``</span>
<span class="sd">    to be able to see that it&#39;s a node of ``g``.</span>
<span class="sd">    The function will go through the values of the mapping to try to find it</span>
<span class="sd">    if it hasn&#39;t been found before in the keys.</span>

<span class="sd">    This can be inefficient, so if that matters, you can express your</span>
<span class="sd">    graph ``g`` so that all nodes are explicitly declared as keys, and</span>
<span class="sd">    use ``check_adjacencies=False`` to tell the function not to look into</span>
<span class="sd">    the values of the ``g`` mapping.</span>

<span class="sd">    &gt;&gt;&gt; has_node(g, 2, check_adjacencies=False)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; g = {</span>
<span class="sd">    ...     0: [1, 2],</span>
<span class="sd">    ...     1: [2],</span>
<span class="sd">    ...     2: []</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; has_node(g, 2, check_adjacencies=False)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">check_adjacencies</span><span class="p">:</span>
        <span class="c1"># look in the adjacencies (because a leaf might not show up as a</span>
        <span class="c1"># {leaf: []} item in g!</span>
        <span class="k">for</span> <span class="n">adjacencies</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">adjacencies</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># if not found before</span></div>


<div class="viewcode-block" id="successors"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.successors">[docs]</a><span class="nd">@_handle_exclude_nodes</span>
<span class="k">def</span> <span class="nf">successors</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">_exclude_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Iterator of nodes that have directed paths FROM node</span>

<span class="sd">    &gt;&gt;&gt; g = {</span>
<span class="sd">    ...     0: [1, 2],</span>
<span class="sd">    ...     1: [2, 3, 4],</span>
<span class="sd">    ...     2: [1, 4],</span>
<span class="sd">    ...     3: [4]}</span>
<span class="sd">    &gt;&gt;&gt; assert set(successors(g, 1)) == {1, 2, 3, 4}</span>
<span class="sd">    &gt;&gt;&gt; assert set(successors(g, 3)) == {4}</span>
<span class="sd">    &gt;&gt;&gt; assert set(successors(g, 4)) == set()</span>

<span class="sd">    Notice that 1 is a successor of 1 here because there&#39;s a 1-2-1 directed path</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">direct_successors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]))</span> <span class="o">-</span> <span class="n">_exclude_nodes</span>
    <span class="k">yield from</span> <span class="n">direct_successors</span>
    <span class="n">_exclude_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">direct_successors</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">successor_node</span> <span class="ow">in</span> <span class="n">direct_successors</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">successors</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">successor_node</span><span class="p">,</span> <span class="n">_exclude_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="predecessors"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.predecessors">[docs]</a><span class="k">def</span> <span class="nf">predecessors</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Iterator of nodes that have directed paths TO node</span>

<span class="sd">    &gt;&gt;&gt; g = {</span>
<span class="sd">    ...     0: [1, 2],</span>
<span class="sd">    ...     1: [2, 3, 4],</span>
<span class="sd">    ...     2: [1, 4],</span>
<span class="sd">    ...     3: [4]}</span>
<span class="sd">    &gt;&gt;&gt; set(predecessors(g, 4))</span>
<span class="sd">    {0, 1, 2, 3}</span>
<span class="sd">    &gt;&gt;&gt; set(predecessors(g, 2))</span>
<span class="sd">    {0, 1, 2}</span>
<span class="sd">    &gt;&gt;&gt; set(predecessors(g, 0))</span>
<span class="sd">    set()</span>

<span class="sd">    Notice that 2 is a predecessor of 2 here because of the presence</span>
<span class="sd">    of a 2-1-2 directed path.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">yield from</span> <span class="n">successors</span><span class="p">(</span><span class="n">edge_reversed_graph</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">node</span><span class="p">)</span></div>


<div class="viewcode-block" id="children"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.children">[docs]</a><span class="k">def</span> <span class="nf">children</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set of all nodes (not in source) adjacent FROM &#39;source&#39; in &#39;g&#39;</span>

<span class="sd">    &gt;&gt;&gt; g = {</span>
<span class="sd">    ...     0: [1, 2],</span>
<span class="sd">    ...     1: [2, 3, 4],</span>
<span class="sd">    ...     2: [1, 4],</span>
<span class="sd">    ...     3: [4]</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; children(g, [2, 3])</span>
<span class="sd">    {1, 4}</span>
<span class="sd">    &gt;&gt;&gt; children(g, [4])</span>
<span class="sd">    set()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="n">_children</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">_children</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">_children</span> <span class="o">-</span> <span class="n">source</span></div>


<div class="viewcode-block" id="parents"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.parents">[docs]</a><span class="k">def</span> <span class="nf">parents</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set of all nodes (not in source) adjacent TO &#39;source&#39; in &#39;g&#39;</span>

<span class="sd">    &gt;&gt;&gt; g = {</span>
<span class="sd">    ...     0: [1, 2],</span>
<span class="sd">    ...     1: [2, 3, 4],</span>
<span class="sd">    ...     2: [1, 4],</span>
<span class="sd">    ...     3: [4]</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; parents(g, [2, 3])</span>
<span class="sd">    {0, 1}</span>
<span class="sd">    &gt;&gt;&gt; parents(g, [0])</span>
<span class="sd">    set()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">children</span><span class="p">(</span><span class="n">edge_reversed_graph</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">source</span><span class="p">)</span></div>


<div class="viewcode-block" id="ancestors"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.ancestors">[docs]</a><span class="nd">@_handle_exclude_nodes</span>
<span class="k">def</span> <span class="nf">ancestors</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">_exclude_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set of all nodes (not in source) reachable TO `source` in `g`.</span>

<span class="sd">    &gt;&gt;&gt; g = {</span>
<span class="sd">    ...     0: [1, 2],</span>
<span class="sd">    ...     1: [2, 3, 4],</span>
<span class="sd">    ...     2: [1, 4],</span>
<span class="sd">    ...     3: [4]</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; ancestors(g, [2, 3])</span>
<span class="sd">    {0, 1}</span>
<span class="sd">    &gt;&gt;&gt; ancestors(g, [0])</span>
<span class="sd">    set()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span>
    <span class="n">source</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">-</span> <span class="n">_exclude_nodes</span>
    <span class="k">if</span> <span class="n">source</span><span class="p">:</span>
        <span class="n">_parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">parents</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">source</span><span class="p">))</span> <span class="o">-</span> <span class="n">_exclude_nodes</span>
        <span class="n">_exclude_nodes</span> <span class="o">=</span> <span class="n">_parents</span>
        <span class="n">_ancestors_of_parent</span> <span class="o">=</span> <span class="n">ancestors</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">_parents</span><span class="p">,</span> <span class="n">_exclude_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_parents</span> <span class="o">|</span> <span class="n">_ancestors_of_parent</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span></div>


<div class="viewcode-block" id="descendants"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.descendants">[docs]</a><span class="k">def</span> <span class="nf">descendants</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">_exclude_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the set of all nodes reachable FROM `source` in `g`.</span>

<span class="sd">    &gt;&gt;&gt; g = {</span>
<span class="sd">    ...     0: [1, 2],</span>
<span class="sd">    ...     1: [2, 3, 4],</span>
<span class="sd">    ...     2: [1, 4],</span>
<span class="sd">    ...     3: [4]</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; descendants(g, [2, 3])</span>
<span class="sd">    {1, 4}</span>
<span class="sd">    &gt;&gt;&gt; descendants(g, [4])</span>
<span class="sd">    set()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">ancestors</span><span class="p">(</span><span class="n">edge_reversed_graph</span><span class="p">(</span><span class="n">g</span><span class="p">),</span> <span class="n">source</span><span class="p">,</span> <span class="n">_exclude_nodes</span><span class="p">)</span></div>


<span class="c1"># TODO: Can serious be optimized, and hasn&#39;t been tested much: Revise</span>
<div class="viewcode-block" id="root_nodes"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.root_nodes">[docs]</a><span class="k">def</span> <span class="nf">root_nodes</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; g = dict(a=&#39;c&#39;, b=&#39;ce&#39;, c=&#39;abde&#39;, d=&#39;c&#39;, e=[&#39;c&#39;, &#39;z&#39;], f={})</span>
<span class="sd">    &gt;&gt;&gt; sorted(root_nodes(g))</span>
<span class="sd">    [&#39;f&#39;]</span>

<span class="sd">    Note that `f` is present: Isolated nodes are considered both as</span>
<span class="sd">    root and leaf nodes both.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nodes_having_parents</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes_having_parents</span><span class="p">)</span></div>


<span class="c1"># TODO: Can serious be optimized, and hasn&#39;t been tested much: Revise</span>
<div class="viewcode-block" id="leaf_nodes"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.leaf_nodes">[docs]</a><span class="k">def</span> <span class="nf">leaf_nodes</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; g = dict(a=&#39;c&#39;, b=&#39;ce&#39;, c=&#39;abde&#39;, d=&#39;c&#39;, e=[&#39;c&#39;, &#39;z&#39;], f={})</span>
<span class="sd">    &gt;&gt;&gt; sorted(leaf_nodes(g))</span>
<span class="sd">    [&#39;f&#39;, &#39;z&#39;]</span>

<span class="sd">    Note that `f` is present: Isolated nodes are considered both as</span>
<span class="sd">    root and leaf nodes both.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">root_nodes</span><span class="p">(</span><span class="n">edge_reversed_graph</span><span class="p">(</span><span class="n">g</span><span class="p">))</span></div>


<div class="viewcode-block" id="isolated_nodes"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.isolated_nodes">[docs]</a><span class="k">def</span> <span class="nf">isolated_nodes</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Nodes that</span>
<span class="sd">    &gt;&gt;&gt; g = dict(a=&#39;c&#39;, b=&#39;ce&#39;, c=&#39;abde&#39;, d=&#39;c&#39;, e=[&#39;c&#39;, &#39;z&#39;], f={})</span>
<span class="sd">    &gt;&gt;&gt; set(isolated_nodes(g))</span>
<span class="sd">    {&#39;f&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">next</span><span class="p">(</span>
            <span class="nb">iter</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="n">src</span><span class="p">]),</span> <span class="kc">False</span>
        <span class="p">):</span>  <span class="c1"># Note: Slower than just `not g[src]`, but safer</span>
            <span class="k">yield</span> <span class="n">src</span></div>


<div class="viewcode-block" id="find_path"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.find_path">[docs]</a><span class="k">def</span> <span class="nf">find_path</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;find a path from src to dst nodes in graph</span>

<span class="sd">    &gt;&gt;&gt; g = dict(a=&#39;c&#39;, b=&#39;ce&#39;, c=&#39;abde&#39;, d=&#39;c&#39;, e=[&#39;c&#39;, &#39;z&#39;], f={})</span>
<span class="sd">    &gt;&gt;&gt; find_path(g, &#39;a&#39;, &#39;c&#39;)</span>
<span class="sd">    [&#39;a&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; find_path(g, &#39;a&#39;, &#39;b&#39;)</span>
<span class="sd">    [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;]</span>
<span class="sd">    &gt;&gt;&gt; find_path(g, &#39;a&#39;, &#39;z&#39;)</span>
<span class="sd">    [&#39;a&#39;, &#39;c&#39;, &#39;b&#39;, &#39;e&#39;, &#39;z&#39;]</span>
<span class="sd">    &gt;&gt;&gt; assert find_path(g, &#39;a&#39;, &#39;f&#39;) == None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">src</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">src</span> <span class="o">==</span> <span class="n">dst</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="k">if</span> <span class="n">src</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">g</span><span class="p">[</span><span class="n">src</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
            <span class="n">extended_path</span> <span class="o">=</span> <span class="n">find_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">extended_path</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">extended_path</span>
    <span class="k">return</span> <span class="kc">None</span></div>


<span class="k">def</span> <span class="nf">reverse_edges</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst_nodes</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">yield from</span> <span class="n">product</span><span class="p">(</span><span class="n">dst_nodes</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>


<div class="viewcode-block" id="out_degrees"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.out_degrees">[docs]</a><span class="k">def</span> <span class="nf">out_degrees</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Sized</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; g = dict(a=&#39;c&#39;, b=&#39;ce&#39;, c=&#39;abde&#39;, d=&#39;c&#39;, e=[&#39;c&#39;, &#39;z&#39;], f={})</span>
<span class="sd">    &gt;&gt;&gt; assert dict(out_degrees(g)) == (</span>
<span class="sd">    ...     {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 4, &#39;d&#39;: 1, &#39;e&#39;: 2, &#39;f&#39;: 0}</span>
<span class="sd">    ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst_nodes</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">yield</span> <span class="n">src</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dst_nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="in_degrees"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.in_degrees">[docs]</a><span class="k">def</span> <span class="nf">in_degrees</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; g = dict(a=&#39;c&#39;, b=&#39;ce&#39;, c=&#39;abde&#39;, d=&#39;c&#39;, e=[&#39;c&#39;, &#39;z&#39;], f={})</span>
<span class="sd">    &gt;&gt;&gt; assert dict(in_degrees(g)) == (</span>
<span class="sd">    ... {&#39;a&#39;: 1, &#39;b&#39;: 1, &#39;c&#39;: 4,  &#39;d&#39;: 1, &#39;e&#39;: 2, &#39;f&#39;: 0, &#39;z&#39;: 1}</span>
<span class="sd">    ... )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">out_degrees</span><span class="p">(</span><span class="n">edge_reversed_graph</span><span class="p">(</span><span class="n">g</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">copy_of_g_with_some_keys_removed</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">_topological_sort_helper</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A recursive function to service topological_sort&quot;&quot;&quot;</span>

    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># Mark the current node as visited.</span>

    <span class="c1"># Recurse for all the vertices adjacent to this node</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[]):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">_topological_sort_helper</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

    <span class="c1"># Push current node to stack which stores result</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>


<div class="viewcode-block" id="topological_sort"><a class="viewcode-back" href="../../module_docs/meshed/itools.html#meshed.itools.topological_sort">[docs]</a><span class="k">def</span> <span class="nf">topological_sort</span><span class="p">(</span><span class="n">g</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the list of nodes in topological sort order.</span>

<span class="sd">    This order is such that a node parents will all occur before;</span>
<span class="sd">        If order[i] is parent of order[j] then i &lt; j</span>

<span class="sd">    This is often used to compute the order of computation in a DAG.</span>

<span class="sd">    &gt;&gt;&gt; g = {</span>
<span class="sd">    ...     0: [4, 2],</span>
<span class="sd">    ...     4: [3, 1],</span>
<span class="sd">    ...     2: [3],</span>
<span class="sd">    ...     3: [1]</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; list(topological_sort(g))</span>
<span class="sd">    [0, 2, 4, 3, 1]</span>

<span class="sd">    Here&#39;s an ascii art of the graph, to verify that the topological sort is</span>
<span class="sd">    indeed as expected.</span>
<span class="sd">    ┌───┐     ┌───┐     ┌───┐     ┌───┐</span>
<span class="sd">    │ 0 │ ──▶ │ 2 │ ──▶ │ 3 │ ──▶ │ 1 │</span>
<span class="sd">    └───┘     └───┘     └───┘     └───┘</span>
<span class="sd">      │                   ▲         ▲</span>
<span class="sd">      │                   │         │</span>
<span class="sd">      ▼                   │         │</span>
<span class="sd">    ┌───┐                 │         │</span>
<span class="sd">    │ 4 │ ────────────────┼─────────┘</span>
<span class="sd">    └───┘                 │</span>
<span class="sd">      │                   │</span>
<span class="sd">      └───────────────────┘</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Call the recursive helper function to accumulate topological sorts</span>
    <span class="c1"># starting from all vertices one by one</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">_topological_sort_helper</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">stack</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">meshed</a></h1>








<h3>Navigation</h3>
<p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed.html">meshed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/caching.html">meshed.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/dag.html">meshed.dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/online_marketing.html">meshed.examples.online_marketing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/price_elasticity.html">meshed.examples.price_elasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/vaccine_vs_no_vaccine.html">meshed.examples.vaccine_vs_no_vaccine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext.html">meshed.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk.html">meshed.ext.gk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk_tests.html">meshed.ext.gk_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/itools.html">meshed.itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/makers.html">meshed.makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap.html">meshed.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/dask_graph_language.html">meshed.scrap.dask_graph_language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/gk_with_networkx.html">meshed.scrap.gk_with_networkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/misc_utils.html">meshed.scrap.misc_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/wrapping_dags.html">meshed.scrap.wrapping_dags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests.html">meshed.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag.html">meshed.tests.test_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_2.html">meshed.tests.test_dag_2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_itools.html">meshed.tests.test_itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_makers.html">meshed.tests.test_makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_util.html">meshed.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/utils_for_testing.html">meshed.tests.utils_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/util.html">meshed.util</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;NO COPYRIGHT.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>