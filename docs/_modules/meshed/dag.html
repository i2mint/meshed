<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>meshed.dag &mdash; meshed 0.1.50 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> meshed
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed.html">meshed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/base.html">meshed.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/caching.html">meshed.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/composition.html">meshed.composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/dag.html">meshed.dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/online_marketing.html">meshed.examples.online_marketing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/price_elasticity.html">meshed.examples.price_elasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/vaccine_vs_no_vaccine.html">meshed.examples.vaccine_vs_no_vaccine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext.html">meshed.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk.html">meshed.ext.gk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk_tests.html">meshed.ext.gk_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/itools.html">meshed.itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/makers.html">meshed.makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap.html">meshed.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/dask_graph_language.html">meshed.scrap.dask_graph_language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/gk_with_networkx.html">meshed.scrap.gk_with_networkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/misc_utils.html">meshed.scrap.misc_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/wrapping_dags.html">meshed.scrap.wrapping_dags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests.html">meshed.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_composition.html">meshed.tests.test_composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag.html">meshed.tests.test_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_2.html">meshed.tests.test_dag_2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_getitem.html">meshed.tests.test_getitem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_itools.html">meshed.tests.test_itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_makers.html">meshed.tests.test_makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_util.html">meshed.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/utils_for_testing.html">meshed.tests.utils_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/util.html">meshed.util</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">meshed</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>meshed.dag</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for meshed.dag</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Making DAGs</span>

<span class="sd">In it&#39;s simplest form, consider this:</span>

<span class="sd">&gt;&gt;&gt; from meshed import DAG</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; def this(a, b=1):</span>
<span class="sd">...     return a + b</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; def that(x, b=1):</span>
<span class="sd">...     return x * b</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; def combine(this, that):</span>
<span class="sd">...     return (this, that)</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; dag = DAG((this, that, combine))</span>
<span class="sd">&gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">x,b -&gt; that_ -&gt; that</span>
<span class="sd">a,b -&gt; this_ -&gt; this</span>
<span class="sd">this,that -&gt; combine_ -&gt; combine</span>

<span class="sd">But don&#39;t be fooled: There&#39;s much more to it!</span>


<span class="sd">FAQ and Troubleshooting</span>
<span class="sd">=======================</span>

<span class="sd">DAGs and Pipelines</span>
<span class="sd">------------------</span>

<span class="sd">&gt;&gt;&gt; from functools import partial</span>
<span class="sd">&gt;&gt;&gt; from meshed import DAG</span>
<span class="sd">&gt;&gt;&gt; def chunker(sequence, chk_size: int):</span>
<span class="sd">...     return zip(*[iter(sequence)] * chk_size)</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; my_chunker = partial(chunker, chk_size=3)</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; vec = range(8)  # when appropriate, use easier to read sequences</span>
<span class="sd">&gt;&gt;&gt; list(my_chunker(vec))</span>
<span class="sd">[(0, 1, 2), (3, 4, 5)]</span>

<span class="sd">Oh, that&#39;s just a ``my_chunker -&gt; list`` pipeline!</span>
<span class="sd">A pipeline is a subset of DAG, so let me do this:</span>

<span class="sd">&gt;&gt;&gt; dag = DAG([my_chunker, list])</span>
<span class="sd">&gt;&gt;&gt; dag(vec)</span>
<span class="sd">Traceback (most recent call last):</span>
<span class="sd">...</span>
<span class="sd">TypeError: missing a required argument: &#39;sequence&#39;</span>

<span class="sd">What happened here?</span>
<span class="sd">You&#39;re assuming that saying ``[my_chunker, list]`` is enough for DAG to know that</span>
<span class="sd">what you meant is for ``my_chunker`` to feed it&#39;s input to ``list``.</span>
<span class="sd">Sure, DAG has enough information to do so, but the default connection policy doesn&#39;t</span>
<span class="sd">assume that it&#39;s a pipeline you want to make.</span>
<span class="sd">In fact, the order you specify the functions doesn&#39;t have an affect on the connections</span>
<span class="sd">with the default connection policy.</span>

<span class="sd">See what the signature of ``dag`` is:</span>

<span class="sd">&gt;&gt;&gt; from inspect import signature</span>
<span class="sd">&gt;&gt;&gt; str(signature(dag))</span>
<span class="sd">&#39;(iterable=(), /, sequence, *, chk_size: int = 3)&#39;</span>

<span class="sd">So dag actually works just fine. Here&#39;s the proof:</span>

<span class="sd">&gt;&gt;&gt; dag([1,2,3], vec)  # doctest: +SKIP</span>
<span class="sd">([1, 2, 3], &lt;zip object at 0x104d7f080&gt;)</span>

<span class="sd">It&#39;s just not what you might have intended.</span>

<span class="sd">Your best bet to get what you intended is to be explicit.</span>

<span class="sd">The way to be explicit is to not specify functions alone, but ``FuncNodes`` that</span>
<span class="sd">wrap them, along with the specification</span>
<span class="sd">the ``name`` the function will be referred to by,</span>
<span class="sd">the names that it&#39;s parameters should ``bind`` to (that is, where the function</span>
<span class="sd">will get it&#39;s import arguments from), and</span>
<span class="sd">the ``out`` name of where it should be it&#39;s output.</span>

<span class="sd">In the current case a fully specified DAG would look something like this:</span>

<span class="sd">&gt;&gt;&gt; from meshed import FuncNode</span>
<span class="sd">&gt;&gt;&gt; dag = DAG(</span>
<span class="sd">...     [</span>
<span class="sd">...         FuncNode(</span>
<span class="sd">...             func=my_chunker,</span>
<span class="sd">...             name=&#39;chunker&#39;,</span>
<span class="sd">...             bind=dict(sequence=&#39;sequence&#39;, chk_size=&#39;chk_size&#39;),</span>
<span class="sd">...             out=&#39;chks&#39;</span>
<span class="sd">...         ),</span>
<span class="sd">...         FuncNode(</span>
<span class="sd">...             func=list,</span>
<span class="sd">...             name=&#39;gather_chks_into_list&#39;,</span>
<span class="sd">...             bind=dict(iterable=&#39;chks&#39;),</span>
<span class="sd">...             out=&#39;list_of_chks&#39;</span>
<span class="sd">...         ),</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; list(dag(vec))</span>
<span class="sd">[(0, 1, 2), (3, 4, 5)]</span>

<span class="sd">But really, if you didn&#39;t care about the names of things,</span>
<span class="sd">all you need in this case was to make sure that the output of ``my_chunker`` was</span>
<span class="sd">fed to ``list``, and therefore the following was sufficient:</span>

<span class="sd">&gt;&gt;&gt; dag = DAG([</span>
<span class="sd">...     FuncNode(my_chunker, out=&#39;chks&#39;),  # call the output of chunker &quot;chks&quot;</span>
<span class="sd">...     FuncNode(list, bind=dict(iterable=&#39;chks&#39;))  # source list input from &quot;chks&quot;</span>
<span class="sd">... ])</span>
<span class="sd">&gt;&gt;&gt; list(dag(vec))</span>
<span class="sd">[(0, 1, 2), (3, 4, 5)]</span>

<span class="sd">Connection policies are very useful when you want to define ways for DAG to</span>
<span class="sd">&quot;just figure it out&quot; for you.</span>
<span class="sd">That is, you want to tell the machine to adapt to your thoughts, not vice versa.</span>
<span class="sd">We support such technological expectations!</span>
<span class="sd">The default connection policy is there to provide one such ways, but</span>
<span class="sd">by all means, use another!</span>

<span class="sd">Does this mean that connection policies are not for production code?</span>
<span class="sd">Well, it depends. The Zen of Python (``import this``)</span>
<span class="sd">states &quot;explicit is better than implicit&quot;, and indeed it&#39;s often</span>
<span class="sd">a good fallback rule.</span>
<span class="sd">But defining components and the way they should be assembled can go a long way</span>
<span class="sd">in achieving consistency, separation of concerns, adaptability, and flexibility.</span>
<span class="sd">All quite useful things. Also in production. Especially in production.</span>
<span class="sd">That said it is your responsiblity to use the right policy for your particular context.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">call_somewhat_forgivingly</span><span class="p">,</span>
    <span class="n">Parameter</span><span class="p">,</span>
    <span class="n">empty</span><span class="p">,</span>
    <span class="n">Sig</span><span class="p">,</span>
    <span class="n">sort_params</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">meshed.base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">FuncNode</span><span class="p">,</span>
    <span class="n">validate_that_func_node_names_are_sane</span><span class="p">,</span>
    <span class="n">_mk_func_nodes</span><span class="p">,</span>
    <span class="n">_func_nodes_to_graph_dict</span><span class="p">,</span>
    <span class="n">is_func_node</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">meshed.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">lambda_name</span><span class="p">,</span>
    <span class="n">ValidationError</span><span class="p">,</span>
    <span class="n">NotUniqueError</span><span class="p">,</span>
    <span class="n">NotFound</span><span class="p">,</span>
    <span class="n">NameValidationError</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">meshed.itools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">topological_sort</span><span class="p">,</span>
    <span class="n">leaf_nodes</span><span class="p">,</span>
    <span class="n">root_nodes</span><span class="p">,</span>
    <span class="n">descendants</span><span class="p">,</span>
    <span class="n">ancestors</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">find_first_free_name</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">(),</span> <span class="n">start_at</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_names</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prefix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">start_at</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s1">__</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_names</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">mk_func_name</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">()):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&lt;lambda&gt;&#39;</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">lambda_name</span><span class="p">()</span>  <span class="c1"># make a lambda name that is a unique identifier</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">partial</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mk_func_name</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NameValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t make a name for func: </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">find_first_free_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">arg_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">()):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
        <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">exclude_names</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_exclude_names</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found_name</span> <span class="o">=</span> <span class="n">find_first_free_name</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s1">__</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">_exclude_names</span>
                <span class="p">)</span>
                <span class="k">yield</span> <span class="n">found_name</span>
                <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">_exclude_names</span> <span class="o">+</span> <span class="p">(</span><span class="n">found_name</span><span class="p">,)</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>


<div class="viewcode-block" id="named_partial"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.named_partial">[docs]</a><span class="k">def</span> <span class="nf">named_partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="vm">__name__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;functools.partial, but with a __name__</span>

<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;print&#39;</span>

<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;, __name__=&#39;now_partial_has_a_name&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;now_partial_has_a_name&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="ow">or</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="n">f</span></div>


<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">ch_func_to_all_pk</span>


<div class="viewcode-block" id="hook_up"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.hook_up">[docs]</a><span class="k">def</span> <span class="nf">hook_up</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Source inputs and write outputs to given variables mapping.</span>

<span class="sd">    Returns inputless and outputless function that will, when called,</span>
<span class="sd">    get relevant inputs from the provided variables mapping and write it&#39;s</span>
<span class="sd">    output there as well.</span>

<span class="sd">    :param variables: The MutableMapping (like... a dict) where the function</span>
<span class="sd">    should both read it&#39;s input and write it&#39;s output.</span>
<span class="sd">    :param output_name: The key of the variables mapping that should be used</span>
<span class="sd">    to write the output of the function</span>
<span class="sd">    :return: A function</span>

<span class="sd">    &gt;&gt;&gt; def formula1(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">    ...     return ((w + x) * y) ** z</span>

<span class="sd">    &gt;&gt;&gt; d = {}</span>
<span class="sd">    &gt;&gt;&gt; f = hook_up(formula1, d)</span>
<span class="sd">    &gt;&gt;&gt; # NOTE: update d, not d = dict(...), which would make a DIFFERENT d</span>
<span class="sd">    &gt;&gt;&gt; d.update(w=2, x=3, y=4)  # not d = dict(w=2, x=3, y=4), which would</span>
<span class="sd">    &gt;&gt;&gt; f()</span>

<span class="sd">    Note that there&#39;s no output. The output is in d</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;w&#39;: 2, &#39;x&#39;: 3, &#39;y&#39;: 4, &#39;formula1&#39;: 20}</span>

<span class="sd">    Again...</span>

<span class="sd">    &gt;&gt;&gt; d.clear()</span>
<span class="sd">    &gt;&gt;&gt; d.update(w=1, x=2, y=3)</span>
<span class="sd">    &gt;&gt;&gt; f()</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;formula1&#39;]</span>
<span class="sd">    9</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_func</span> <span class="o">=</span> <span class="n">ch_func_to_all_pk</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>  <span class="c1"># makes a position-keyword copy of func</span>
    <span class="n">output_key</span> <span class="o">=</span> <span class="n">output_name</span>
    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_key</span> <span class="o">=</span> <span class="n">_func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">source_from_decorated</span><span class="p">():</span>
        <span class="n">variables</span><span class="p">[</span><span class="n">output_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="p">(),</span> <span class="n">variables</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">source_from_decorated</span></div>


<span class="k">def</span> <span class="nf">_complete_dict_with_iterable_of_required_keys</span><span class="p">(</span>
    <span class="n">to_complete</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">complete_with</span><span class="p">:</span> <span class="n">Iterable</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Complete `to_complete` (in place) with `complete_with`</span>
<span class="sd">    `complete_with` contains values that must be covered by `to_complete`</span>
<span class="sd">    Those values that are not covered will be inserted in to_complete,</span>
<span class="sd">    with key=val</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;a&#39;: &#39;A&#39;, &#39;c&#39;: &#39;C&#39;}</span>
<span class="sd">    &gt;&gt;&gt; _complete_dict_with_iterable_of_required_keys(d, &#39;abc&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;a&#39;: &#39;A&#39;, &#39;c&#39;: &#39;C&#39;, &#39;b&#39;: &#39;b&#39;}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys_already_covered</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">to_complete</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">required_key</span> <span class="ow">in</span> <span class="n">complete_with</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">required_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys_already_covered</span><span class="p">:</span>
            <span class="n">to_complete</span><span class="p">[</span><span class="n">required_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">required_key</span>


<span class="k">def</span> <span class="nf">_inverse_dict_asserting_losslessness</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">inv_d</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_d</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;can&#39;t invert: You have some duplicate values in this dict: &quot;</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">inv_d</span>


<span class="k">def</span> <span class="nf">_extract_values</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;generator of values extracted from d for keys&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>


<div class="viewcode-block" id="extract_values"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.extract_values">[docs]</a><span class="k">def</span> <span class="nf">extract_values</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract values from dict ``d``, returning them:</span>

<span class="sd">    - as a tuple if len(keys) &gt; 1</span>

<span class="sd">    - a single value if len(keys) == 1</span>

<span class="sd">    - None if not</span>

<span class="sd">    This is used as the default extractor in DAG</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">keys</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tup</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="extract_items"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.extract_items">[docs]</a><span class="k">def</span> <span class="nf">extract_items</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;generator of (k, v) pairs extracted from d for keys&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_separate_func_nodes_and_var_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
    <span class="n">func_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">var_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_func_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">func_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func_nodes</span><span class="p">,</span> <span class="n">var_nodes</span>


<span class="n">_not_found</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_find_unique_element</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">search_iterable</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Find item in search_iterable, using key as the matching function,</span>
<span class="sd">    raising a NotFound error if no match and a NotUniqueError if more than one.&quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">search_iterable</span><span class="p">)</span>
    <span class="n">first</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">_not_found</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="n">_not_found</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NotFound</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> wasn&#39;t found&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">the_next_match</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">_not_found</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_next_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_not_found</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotUniqueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> wasn&#39;t unique&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">first</span>


<span class="n">ParameterMerger</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]],</span> <span class="n">Parameter</span><span class="p">]</span>
<span class="n">conservative_parameter_merge</span><span class="p">:</span> <span class="n">ParameterMerger</span>


<div class="viewcode-block" id="conservative_parameter_merge"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.conservative_parameter_merge">[docs]</a><span class="k">def</span> <span class="nf">conservative_parameter_merge</span><span class="p">(</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">same_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">same_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">same_annotation</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Validates that all the params are exactly the same, returning the first if so.</span>

<span class="sd">    This is used when hooking up functions that use the same parameters (i.e. arg</span>
<span class="sd">    names). When the name of an argument is used more than once, which kind, default,</span>
<span class="sd">    and annotation should be used in the interface of the DAG?</span>

<span class="sd">    If they&#39;re all the same, there&#39;s no problem.</span>

<span class="sd">    But if they&#39;re not the same, we need to provide control on which to ignore.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">suggestion_on_error</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;To resolve this you have several choices:</span>
<span class="s1">    </span>
<span class="s1">    - Change the properties of the param (kind, default, annotation) to be those you </span>
<span class="s1">      want. For example, you can use ``i2.Sig.ch_param_attrs`` </span>
<span class="s1">      (or ``i2.Sig.ch_defaults``, ``i2.Sig.ch_kinds``, ``i2.Sig.ch_annotations``)</span>
<span class="s1">      to get a function decorator that will do that for you.</span>
<span class="s1">    - If you&#39;re making a DAG, consider specifying a different ``parameter_merge``.</span>
<span class="s1">      For example you can use ``functools.partial`` on </span>
<span class="s1">      ``i2.dag.conservative_parameter_merge``, fixing ``same_kind``, ``same_default``, </span>
<span class="s1">      and/or ``same_annotation`` to ``False`` to get a more lenient version of it.</span>
<span class="s1">      </span>
<span class="s1">    See https://github.com/i2mint/meshed/issues/7 (description and comments) for more</span>
<span class="s1">    info.</span>
<span class="s1">    &#39;&#39;&#39;</span>
    <span class="n">first_param</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">params</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same name: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">suggestion_on_error</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">same_kind</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same kind: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">suggestion_on_error</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">same_default</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same default: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">suggestion_on_error</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">same_annotation</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">p</span><span class="o">.</span><span class="n">annotation</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">annotation</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same annotation: &quot;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">suggestion_on_error</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">first_param</span></div>


<span class="k">def</span> <span class="nf">modified_func_node</span><span class="p">(</span><span class="n">func_node</span><span class="p">,</span> <span class="o">**</span><span class="n">modifications</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FuncNode</span><span class="p">:</span>
    <span class="n">modifiable_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;bind&#39;</span><span class="p">,</span> <span class="s1">&#39;out&#39;</span><span class="p">}</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">modifications</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span>
        <span class="n">modifiable_attrs</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Can only modify these: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">modifiable_attrs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">original_func_node_kwargs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">func_node</span><span class="o">.</span><span class="n">func</span><span class="p">,</span>
        <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">func_node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="s1">&#39;bind&#39;</span><span class="p">:</span> <span class="n">func_node</span><span class="o">.</span><span class="n">bind</span><span class="p">,</span>
        <span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">func_node</span><span class="o">.</span><span class="n">out</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">FuncNode</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">original_func_node_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">modifications</span><span class="p">))</span>


<span class="kn">from</span> <span class="nn">meshed.util</span> <span class="kn">import</span> <span class="n">partialx</span>

<span class="c1"># TODO: doctests</span>
<span class="k">def</span> <span class="nf">partialized_funcnodes</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">,</span> <span class="o">**</span><span class="n">keyword_defaults</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="n">func_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">argnames_to_be_bound</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">(</span><span class="n">keyword_defaults</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
            <span class="n">func_node</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span>
        <span class="p">):</span>
            <span class="n">bindings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">extract_items</span><span class="p">(</span><span class="n">keyword_defaults</span><span class="p">,</span> <span class="n">argnames_to_be_bound</span><span class="p">))</span>
            <span class="c1"># partialize the func and move defaulted params to the end</span>
            <span class="n">partialized_func</span> <span class="o">=</span> <span class="n">partialx</span><span class="p">(</span>
                <span class="n">func_node</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">bindings</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="c1"># get rid of kinds  # TODO: This is a bit extreme -- consider gentler touch</span>
            <span class="n">nice_kinds_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">partialized_func</span><span class="p">)</span><span class="o">.</span><span class="n">ch_kinds_to_position_or_keyword</span><span class="p">()</span>
            <span class="n">nice_kinds_partialized_func</span> <span class="o">=</span> <span class="n">nice_kinds_sig</span><span class="p">(</span><span class="n">partialized_func</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">modified_func_node</span><span class="p">(</span>
                <span class="n">func_node</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">nice_kinds_partialized_func</span>
            <span class="p">)</span>  <span class="c1"># TODO: A better way without partial?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">func_node</span>


<span class="n">Scope</span> <span class="o">=</span> <span class="nb">dict</span>
<span class="n">VarNames</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="n">DagOutput</span> <span class="o">=</span> <span class="n">Any</span>


<span class="k">def</span> <span class="nf">_name_attr_or_x</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="c1"># TODO: caching last scope isn&#39;t really the DAG&#39;s direct concern -- it&#39;s a debugging</span>
<span class="c1">#  concern. Perhaps a more general form would be to define a cache factory defaulting</span>
<span class="c1">#  to a dict, but that could be a &quot;dict&quot; that logs writes (even to an attribute of self)</span>
<div class="viewcode-block" id="DAG"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">DAG</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; from meshed.dag import DAG, Sig</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def this(a, b=1):</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def that(x, b=1):</span>
<span class="sd">    ...     return x * b</span>
<span class="sd">    &gt;&gt;&gt; def combine(this, that):</span>
<span class="sd">    ...     return (this, that)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; dag = DAG((this, that, combine))</span>
<span class="sd">    &gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">    x,b -&gt; that_ -&gt; that</span>
<span class="sd">    a,b -&gt; this_ -&gt; this</span>
<span class="sd">    this,that -&gt; combine_ -&gt; combine</span>

<span class="sd">    But what does it do?</span>

<span class="sd">    It&#39;s a callable, with a signature:</span>

<span class="sd">    &gt;&gt;&gt; Sig(dag)  # doctest: +SKIP</span>
<span class="sd">    &lt;Sig (x, a, b=1)&gt;</span>

<span class="sd">    And when you call it, it executes the dag from the root values you give it and</span>
<span class="sd">    returns the leaf output values.</span>

<span class="sd">    &gt;&gt;&gt; dag(1, 2, 3)  # (a+b,x*b) == (2+3,1*3) == (5, 3)</span>
<span class="sd">    (5, 3)</span>
<span class="sd">    &gt;&gt;&gt; dag(1, 2)  # (a+b,x*b) == (2+1,1*1) == (3, 1)</span>
<span class="sd">    (3, 1)</span>

<span class="sd">    The above DAG was created straight from the functions, using only the names of the</span>
<span class="sd">    functions and their arguments to define how to hook the network up.</span>

<span class="sd">    But if you didn&#39;t write those functions specifically for that purpose, or you want</span>
<span class="sd">    to use someone else&#39;s functions, we got you covered.</span>

<span class="sd">    You can define the name of the node (the `name` argument), the name of the output</span>
<span class="sd">    (the `out` argument) and a mapping from the function&#39;s arguments names to</span>
<span class="sd">    &quot;network names&quot; (through the `bind` argument).</span>
<span class="sd">    The edges of the DAG are defined by matching `out` TO `bind`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">func_nodes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span>
    <span class="n">cache_last_scope</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">parameter_merge</span><span class="p">:</span> <span class="n">ParameterMerger</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="n">conservative_parameter_merge</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="c1"># can return a prepopulated scope too!</span>
    <span class="n">new_scope</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">extract_output_from_scope</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Scope</span><span class="p">,</span> <span class="n">VarNames</span><span class="p">],</span> <span class="n">DagOutput</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="n">extract_values</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_mk_func_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">_func_nodes_to_graph_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">topological_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="c1"># reorder the nodes to fit topological order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_nodes</span> <span class="o">=</span> <span class="n">_separate_func_nodes_and_var_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="c1"># self.sig = Sig(dict(extract_items(sig.parameters, &#39;xz&#39;)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>  <span class="c1"># make a signature</span>
            <span class="n">sort_params</span><span class="p">(</span>  <span class="c1"># with the sorted params (sorted to satisfy kind/default order)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">src_name_params</span><span class="p">(</span><span class="n">root_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># to put the signature on the callable DAG</span>
        <span class="c1"># figure out the roots and leaves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>  <span class="c1"># roots in the same order as signature</span>
        <span class="n">leafs</span> <span class="o">=</span> <span class="n">leaf_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="c1"># But we want leafs in topological order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leafs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_scope</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Get a dict of {argname: argval} pairs from positional and keyword arguments</span>
        <span class="c1"># How positionals are resolved is determined by sels.sig</span>
        <span class="c1"># The result is the initial ``scope`` the func nodes will both read from</span>
        <span class="c1"># to get their arguments, and write their outputs to.</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Go through self.func_nodes in order and call them on scope (performing said</span>
        <span class="c1"># read_input -&gt; call_func -&gt; write_output operations)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_on_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="c1"># From the scope, that may contain all intermediary results,</span>
        <span class="c1"># extract the desired final output and return it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_output_from_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">leafs</span><span class="p">)</span>

<div class="viewcode-block" id="DAG.call_on_scope"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.call_on_scope">[docs]</a>    <span class="k">def</span> <span class="nf">call_on_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls the func_nodes using scope (a dict or MutableMapping) both to</span>
<span class="sd">        source it&#39;s arguments and write it&#39;s results.</span>

<span class="sd">        Note: This method is only meant to be used as a backend to __call__, not as</span>
<span class="sd">        an actual interface method. Additional control/constraints on read and writes</span>
<span class="sd">        can be implemented by providing a custom scope for that. For example, one could</span>
<span class="sd">        log read and/or writes to specific keys, or disallow overwriting to an existing</span>
<span class="sd">        key (useful for pipeline sanity), etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scope</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_scope</span><span class="p">()</span>  <span class="c1"># fresh new scope</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_last_scope</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_scope</span> <span class="o">=</span> <span class="n">scope</span>  <span class="c1"># just to remember it, for debugging purposes ONLY!</span>

        <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">:</span>
            <span class="n">func_node</span><span class="o">.</span><span class="n">call_on_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span></div>

    <span class="c1"># def clone(self, *args, **kwargs):</span>
    <span class="c1">#     &quot;&quot;&quot;Use args, kwargs to make an instance, using self attributes for</span>
    <span class="c1">#     unspecified arguments.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a sub-dag from a specification of (var or fun) input and output nodes.</span>

<span class="sd">        ``dag[input_nodes:output_nodes]`` is the sub-dag made of intersection of all</span>
<span class="sd">        descendants of ``input_nodes``</span>
<span class="sd">        (inclusive) and ancestors of ``output_nodes`` (inclusive), where additionally,</span>
<span class="sd">        when a func node is contained, it takes with it the input and output nodes</span>
<span class="sd">        it needs.</span>

<span class="sd">        &gt;&gt;&gt; def f(a): ...</span>
<span class="sd">        &gt;&gt;&gt; def g(f): ...</span>
<span class="sd">        &gt;&gt;&gt; def h(g): ...</span>
<span class="sd">        &gt;&gt;&gt; def i(h): ...</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g, h, i])</span>

<span class="sd">        See what this dag looks like (it&#39;s a simple pipeline):</span>

<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g, h, i])</span>
<span class="sd">        &gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">        a -&gt; f_ -&gt; f</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>
<span class="sd">        h -&gt; i_ -&gt; i</span>

<span class="sd">        Get a subdag from ``g_`` (indicates the function here) to the end of ``dag``</span>

<span class="sd">        &gt;&gt;&gt; subdag = dag[&#39;g_&#39;:]</span>
<span class="sd">        &gt;&gt;&gt; print(subdag.synopsis_string())</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>
<span class="sd">        h -&gt; i_ -&gt; i</span>

<span class="sd">        From the beginning to ``h_``</span>

<span class="sd">        &gt;&gt;&gt; print(dag[:&#39;h_&#39;].synopsis_string())</span>
<span class="sd">        a -&gt; f_ -&gt; f</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>

<span class="sd">        From ``g_`` to ``h_`` (both inclusive)</span>

<span class="sd">        &gt;&gt;&gt; print(dag[&#39;g_&#39;:&#39;h_&#39;].synopsis_string())</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>

<span class="sd">        Above we used function (node names) to specify what we wanted, but we can also</span>
<span class="sd">        use names of input/output var-nodes. Do note the difference though.</span>
<span class="sd">        The nodes you specify to get a sub-dag are INCLUSIVE, but when you</span>
<span class="sd">        specify function nodes, you also get the input and output nodes of these</span>
<span class="sd">        functions.</span>

<span class="sd">        The ``dag[&#39;g_&#39;, &#39;h_&#39;]`` give us a sub-dag starting at ``f`` (the input node),</span>
<span class="sd">        but when we ask ``dag[&#39;g&#39;, &#39;h_&#39;]`` instead, ``g`` being the output node of</span>
<span class="sd">        function node ``g_``, we only get ``g -&gt; h_ -&gt; h``:</span>

<span class="sd">        &gt;&gt;&gt; print(dag[&#39;g&#39;:&#39;h&#39;].synopsis_string())</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>

<span class="sd">        If we wanted to include ``f`` we&#39;d have to specify it:</span>

<span class="sd">        &gt;&gt;&gt; print(dag[&#39;f&#39;:&#39;h&#39;].synopsis_string())</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>

<span class="sd">        Those were for simple pipelines, but let&#39;s now look at a more complex dag.</span>

<span class="sd">        We&#39;ll let the following examples self-comment:</span>

<span class="sd">        &gt;&gt;&gt; def f(u, v): ...</span>
<span class="sd">        &gt;&gt;&gt; def g(f): ...</span>
<span class="sd">        &gt;&gt;&gt; def h(f, w): ...</span>
<span class="sd">        &gt;&gt;&gt; def i(g, h): ...</span>
<span class="sd">        &gt;&gt;&gt; def j(h, x): ...</span>
<span class="sd">        &gt;&gt;&gt; def k(i): ...</span>
<span class="sd">        &gt;&gt;&gt; def l(i, j): ...</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g, h, i, j, k, l])</span>
<span class="sd">        &gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">        u,v -&gt; f_ -&gt; f</span>
<span class="sd">        f,w -&gt; h_ -&gt; h</span>
<span class="sd">        h,x -&gt; j_ -&gt; j</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g,h -&gt; i_ -&gt; i</span>
<span class="sd">        i,j -&gt; l_ -&gt; l</span>
<span class="sd">        i -&gt; k_ -&gt; k</span>

<span class="sd">        A little util to get consistent prints:</span>

<span class="sd">        &gt;&gt;&gt; def print_sorted_synopsis(dag):</span>
<span class="sd">        ...     t = sorted(dag.synopsis_string().split(&#39;\\n&#39;))</span>
<span class="sd">        ...     print(&#39;\\n&#39;.join(t))</span>

<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[[&#39;u&#39;, &#39;f&#39;]:&#39;h&#39;])</span>
<span class="sd">        f,w -&gt; h_ -&gt; h</span>
<span class="sd">        u,v -&gt; f_ -&gt; f</span>
<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[&#39;u&#39;:&#39;h&#39;])</span>
<span class="sd">        f,w -&gt; h_ -&gt; h</span>
<span class="sd">        u,v -&gt; f_ -&gt; f</span>
<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[[&#39;u&#39;, &#39;f&#39;]:[&#39;h&#39;, &#39;g&#39;]])</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        f,w -&gt; h_ -&gt; h</span>
<span class="sd">        u,v -&gt; f_ -&gt; f</span>
<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[[&#39;x&#39;, &#39;g&#39;]:&#39;k&#39;])</span>
<span class="sd">        g,h -&gt; i_ -&gt; i</span>
<span class="sd">        i -&gt; k_ -&gt; k</span>
<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[[&#39;x&#39;, &#39;g&#39;]:[&#39;l&#39;, &#39;k&#39;]])</span>
<span class="sd">        g,h -&gt; i_ -&gt; i</span>
<span class="sd">        h,x -&gt; j_ -&gt; j</span>
<span class="sd">        i -&gt; k_ -&gt; k</span>
<span class="sd">        i,j -&gt; l_ -&gt; l</span>

<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">ins</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">_descendants</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="n">FuncNode</span><span class="o">.</span><span class="n">has_as_instance</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span> <span class="o">|</span> <span class="n">descendants</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">ins</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">_ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="n">FuncNode</span><span class="o">.</span><span class="n">has_as_instance</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">|</span> <span class="n">ancestors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">outs</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">subgraph_nodes</span> <span class="o">=</span> <span class="n">_descendants</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">_ancestors</span><span class="p">)</span>
        <span class="c1"># TODO: When clone ready, use to do `constructor = type(self)` instead of DAG</span>
        <span class="c1"># constructor = type(self)  # instead of DAG</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span>
            <span class="n">func_nodes</span><span class="o">=</span><span class="n">subgraph_nodes</span><span class="p">,</span>
            <span class="n">cache_last_scope</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_last_scope</span><span class="p">,</span>
            <span class="n">parameter_merge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_merge</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># TODO: Think about adding a ``_roll_in_orphaned_nodes=False`` argument:</span>
    <span class="c1">#   See https://github.com/i2mint/meshed/issues/14 for more information.</span>
<div class="viewcode-block" id="DAG.partial"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.partial">[docs]</a>    <span class="k">def</span> <span class="nf">partial</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">positional_dflts</span><span class="p">,</span>
        <span class="n">_remove_bound_arguments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_consider_defaulted_arguments_as_bound</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">keyword_dflts</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a curried version of the DAG.</span>

<span class="sd">        Like ``functools.partial``, but returns a DAG (not just a callable) and allows</span>
<span class="sd">        you to remove bound arguments as well as roll in orphaned_nodes.</span>

<span class="sd">        :param positional_dflts: Bind arguments positionally</span>
<span class="sd">        :param keyword_dflts: Bind arguments through their names</span>
<span class="sd">        :param _remove_bound_arguments: False -- set to True if you don&#39;t want bound</span>
<span class="sd">            arguments to show up in the signature.</span>
<span class="sd">        :param _consider_defaulted_arguments_as_bound: False -- set to True if</span>
<span class="sd">            you want to also consider arguments that already had defaults as bound</span>
<span class="sd">            (and be removed).</span>
<span class="sd">        :return:</span>

<span class="sd">        &gt;&gt;&gt; def f(a, b):</span>
<span class="sd">        ...     return a + b</span>
<span class="sd">        &gt;&gt;&gt; def g(c, d=4):</span>
<span class="sd">        ...     return c * d</span>
<span class="sd">        &gt;&gt;&gt; def h(f, g):</span>
<span class="sd">        ...     return g - f</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g, h])</span>
<span class="sd">        &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">        &gt;&gt;&gt; str(signature(dag))</span>
<span class="sd">        &#39;(c, a, b, d=4)&#39;</span>
<span class="sd">        &gt;&gt;&gt; dag(3, 1, 2, 4)  # == (3 * 4) - (1 + 2) == 12 - 3 == 9</span>
<span class="sd">        9</span>
<span class="sd">        &gt;&gt;&gt; dag(c=3, a=1, b=2, d=4)  # same as above</span>
<span class="sd">        9</span>

<span class="sd">        &gt;&gt;&gt; new_dag = dag.partial(c=3)</span>
<span class="sd">        &gt;&gt;&gt; isinstance(new_dag, DAG)  # it&#39;s a dag (not just a partialized callable!)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; str(signature(new_dag))</span>
<span class="sd">        &#39;(a, b, c=3, d=4)&#39;</span>
<span class="sd">        &gt;&gt;&gt; new_dag(1, 2)  # same as dag(c=3, a=1, b=2, d=4), so:</span>
<span class="sd">        9</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">keyword_dflts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="o">=</span><span class="n">positional_dflts</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">keyword_dflts</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_consider_defaulted_arguments_as_bound</span><span class="p">,</span>
            <span class="c1"># positional_dflts and keyword_dflts usually don&#39;t cover all arguments, so:</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="c1"># we prefer to let the user know if they&#39;re trying to bind arguments</span>
            <span class="c1"># that don&#39;t exist, so:</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="c1"># we don&#39;t really care about kind, so:</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># TODO: mk_instance: What about other init args (cache_last_scope, ...)?</span>
        <span class="n">mk_instance</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">func_nodes</span> <span class="o">=</span> <span class="n">partialized_funcnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">keyword_dflts</span><span class="p">)</span>
        <span class="n">new_dag</span> <span class="o">=</span> <span class="n">mk_instance</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_remove_bound_arguments</span><span class="p">:</span>
            <span class="n">new_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">new_dag</span><span class="p">)</span><span class="o">.</span><span class="n">remove_names</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">keyword_dflts</span><span class="p">))</span>
            <span class="n">new_sig</span><span class="p">(</span><span class="n">new_dag</span><span class="p">)</span>  <span class="c1"># Change the signature of new_dag with bound args removed</span>
        <span class="k">return</span> <span class="n">new_dag</span></div>

    <span class="k">def</span> <span class="nf">process_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;must be a slice, was: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">stop</span>

        <span class="n">empty_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">ensure_variable_list</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_nodes</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_matching</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_matching</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unrecognized variables specification: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># assert len(item) == 2, f&quot;Only items of size 1 or 2 are supported&quot;</span>
        <span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">ensure_variable_list</span><span class="p">,</span> <span class="p">[</span><span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span>

    <span class="k">def</span> <span class="nf">get_node_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_nodes</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pattern</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_node_for_name</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_node_for_func</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">NotFound</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No matching node: </span><span class="si">{</span><span class="n">pattern</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">func_node_for_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_find_unique_element</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">name</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">name</span> <span class="o">==</span> <span class="n">fn</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">func_node_for_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_find_unique_element</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">func</span> <span class="o">==</span> <span class="n">fn</span><span class="o">.</span><span class="n">func</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yields the self.func_nodes</span>
<span class="sd">        Note: The raison d&#39;etre of this ``__iter__`` is simply because if no custom one</span>
<span class="sd">        is provided, python defaults to yielding ``__getitem__[i]`` for integers,</span>
<span class="sd">        which leads to an error being raised.</span>

<span class="sd">        At least here we yield something sensible.</span>

<span class="sd">        A consequence of the `__iter__` being the iterable of func_nodes is that we</span>
<span class="sd">        can extend dags using the star operator. Consider the following dag;</span>

<span class="sd">        &gt;&gt;&gt; def f(a): return a * 2</span>
<span class="sd">        &gt;&gt;&gt; def g(f, b): return f + b</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g])</span>
<span class="sd">        &gt;&gt;&gt; assert dag(2, 3) == 7</span>

<span class="sd">        Say you wanted to now take a, b, and the output og g, and feed it to another</span>
<span class="sd">        function...</span>

<span class="sd">        &gt;&gt;&gt; def h(a, b, g): return f&quot;{a=} {b=} {g=}&quot;</span>
<span class="sd">        &gt;&gt;&gt; extended_dag = DAG([*dag, h])</span>
<span class="sd">        &gt;&gt;&gt; extended_dag(a=2, b=3)</span>
<span class="sd">        &#39;a=2 b=3 g=7&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span>

    <span class="c1"># ------------ utils --------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">params_for_src</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The ``{src_name: list_of_params_using_that_src,...}`` dictionary.</span>
<span class="sd">        That is, a ``dict`` having lists of all ``Parameter`` objs that are used by a</span>
<span class="sd">        ``node.bind`` source (value of ``node.bind``) for each such source in the graph</span>

<span class="sd">        For each ``func_node``, ``func_node.bind`` gives us the</span>
<span class="sd">        ``{param: varnode_src_name}`` specification that tells us where (key of scope)</span>
<span class="sd">        to source the arguments of the ``func_node.func`` for each ``param`` of that</span>
<span class="sd">        function.</span>

<span class="sd">        What ``params_for_src`` is, is the corresponding inverse map.</span>
<span class="sd">        The ``{varnode_src_name: list_of_params}`` gathered by scanning each</span>
<span class="sd">        ``func_node`` of the DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">src_name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">bind</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">d</span><span class="p">[</span><span class="n">src_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">arg_name</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">src_name_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="c1"># see params_for_src property to see what d is</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_for_src</span>
        <span class="k">if</span> <span class="n">src_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if no src_names given, use the names of all var_nodes</span>
            <span class="n">src_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># For every src_name of the DAG that is in ``src_name``...</span>
        <span class="k">for</span> <span class="n">src_name</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">src_names</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">src_name</span><span class="p">]</span>  <span class="c1"># consider all the params that use it</span>
            <span class="c1"># make version of these params that have the same name (namely src_name)</span>
            <span class="n">params_with_name_changed_to_src_name</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">src_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params_with_name_changed_to_src_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if there&#39;s only one param, return it (there can be no conflict)</span>
                <span class="k">yield</span> <span class="n">params_with_name_changed_to_src_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># if there&#39;s more than one param, merge them</span>
                <span class="c1"># How to resolve conflicts (different defaults, annotations or kinds)</span>
                <span class="c1"># is determined by what ``parameter_merge`` specified, which is,</span>
                <span class="c1"># by default, strict (everything needs to be the same, or</span>
                <span class="c1"># ``parameter_merge`` with raise an error.</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_merge</span><span class="p">(</span><span class="n">params_with_name_changed_to_src_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">graph_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The dict representing the ``{from_node: to_nodes}`` graph.</span>
<span class="sd">        Like ``.graph``, but with node ids (names).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">_name_attr_or_x</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_name_attr_or_x</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="c1"># ------------ display --------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">synopsis_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func_node</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">()</span> <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span>

    <span class="c1"># TODO: Give more control (merge with lined)</span>
<div class="viewcode-block" id="DAG.dot_digraph_body"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.dot_digraph_body">[docs]</a>    <span class="k">def</span> <span class="nf">dot_digraph_body</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_lines</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Make lines for dot (graphviz) specification of DAG</span>

<span class="sd">        &gt;&gt;&gt; def add(a, b=1): return a + b</span>
<span class="sd">        &gt;&gt;&gt; def mult(x, y=3): return x * y</span>
<span class="sd">        &gt;&gt;&gt; def exp(mult, a): return mult ** a</span>
<span class="sd">        &gt;&gt;&gt; func_nodes = [</span>
<span class="sd">        ...     FuncNode(add, out=&#39;x&#39;), FuncNode(mult, name=&#39;the_product&#39;), FuncNode(exp)</span>
<span class="sd">        ... ]</span>

<span class="sd">        #</span>
<span class="sd">        # &gt;&gt;&gt; assert list(DAG(func_nodes).dot_digraph_body()) == [</span>
<span class="sd">        # ]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="n">dot_lines_of_func_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="n">start_lines</span><span class="o">=</span><span class="n">start_lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.dot_digraph_ascii"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.dot_digraph_ascii">[docs]</a>    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph_ascii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an ascii art string that represents the pipeline&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">meshed.util</span> <span class="kn">import</span> <span class="n">dot_to_ascii</span>

        <span class="k">return</span> <span class="n">dot_to_ascii</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot_digraph_body</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span></div>

<div class="viewcode-block" id="DAG.dot_digraph"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.dot_digraph">[docs]</a>    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">graphviz</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="se">\n</span><span class="s1">You may not have graphviz installed. &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;See https://pypi.org/project/graphviz/.&#39;</span>
            <span class="p">)</span>
        <span class="c1"># Note: Since graphviz 0.18, need to have a newline in body lines!</span>
        <span class="n">body</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_add_new_line_if_none</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot_digraph_body</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="n">body</span><span class="p">)</span></div></div>


<span class="c1"># These are the defaults used in lined.</span>
<span class="c1"># TODO: Merge some of the functionalities around graph displays in lined and meshed</span>
<span class="n">dflt_configs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">fnode_shape</span><span class="o">=</span><span class="s1">&#39;box&#39;</span><span class="p">,</span>
    <span class="n">vnode_shape</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
    <span class="n">display_all_arguments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">edge_kind</span><span class="o">=</span><span class="s1">&#39;to_args_on_edge&#39;</span><span class="p">,</span>
    <span class="n">input_node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">output_node</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">param_to_dot_definition</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">dflt_configs</span><span class="p">[</span><span class="s1">&#39;vnode_shape&#39;</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span>
    <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> [label=&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; shape=&quot;</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>


<span class="k">def</span> <span class="nf">call_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dot_lines_of_func_parameters</span><span class="p">(</span>
    <span class="n">parameters</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">],</span>
    <span class="n">out</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">func_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">func_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">dflt_configs</span><span class="p">[</span><span class="s1">&#39;vnode_shape&#39;</span><span class="p">],</span>
    <span class="n">func_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">dflt_configs</span><span class="p">[</span><span class="s1">&#39;fnode_shape&#39;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="k">assert</span> <span class="n">func_id</span> <span class="o">!=</span> <span class="n">out</span><span class="p">,</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Your func and output name shouldn&#39;t be the &quot;</span> <span class="sa">f</span><span class="s1">&#39;same: </span><span class="si">{</span><span class="n">out</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">func_id</span><span class="si">=}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="n">func_label</span> <span class="o">=</span> <span class="n">func_label</span> <span class="ow">or</span> <span class="n">func_id</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1"> [label=&quot;</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1">&quot; shape=&quot;</span><span class="si">{</span><span class="n">output_shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_id</span><span class="si">}</span><span class="s1"> [label=&quot;</span><span class="si">{</span><span class="n">func_label</span><span class="si">}</span><span class="s1">&quot; shape=&quot;</span><span class="si">{</span><span class="n">func_shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_id</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="c1"># args -&gt; func</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">param_to_dot_definition</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">func_id</span><span class="si">}</span><span class="s1">&#39;</span>


<span class="k">def</span> <span class="nf">_parameters_and_names_from_sig</span><span class="p">(</span>
    <span class="n">sig</span><span class="p">:</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="n">func_name</span> <span class="ow">or</span> <span class="n">sig</span><span class="o">.</span><span class="n">name</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="ow">or</span> <span class="n">sig</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="n">func_name</span> <span class="o">==</span> <span class="n">out</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">func_name</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">func_name</span>


<div class="viewcode-block" id="dot_lines_of_func_nodes"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.dot_lines_of_func_nodes">[docs]</a><span class="k">def</span> <span class="nf">dot_lines_of_func_nodes</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">],</span> <span class="n">start_lines</span><span class="o">=</span><span class="p">()):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Got lines generator for the graphviz.DiGraph(body=list(...))</span>

<span class="sd">    &gt;&gt;&gt; def add(a, b=1):</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def mult(x, y=3):</span>
<span class="sd">    ...     return x * y</span>
<span class="sd">    &gt;&gt;&gt; def exp(mult, a):</span>
<span class="sd">    ...     return mult ** a</span>
<span class="sd">    &gt;&gt;&gt; func_nodes = [</span>
<span class="sd">    ...     FuncNode(add, out=&#39;x&#39;),</span>
<span class="sd">    ...     FuncNode(mult, name=&#39;the_product&#39;),</span>
<span class="sd">    ...     FuncNode(exp)</span>
<span class="sd">    ... ]</span>
<span class="sd">    &gt;&gt;&gt; lines = list(dot_lines_of_func_nodes(func_nodes))</span>
<span class="sd">    &gt;&gt;&gt; assert lines == [</span>
<span class="sd">    ... &#39;x [label=&quot;x&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;_add [label=&quot;_add&quot; shape=&quot;box&quot;]&#39;,</span>
<span class="sd">    ... &#39;_add -&gt; x&#39;,</span>
<span class="sd">    ... &#39;a [label=&quot;a&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;b [label=&quot;b=&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;a -&gt; _add&#39;,</span>
<span class="sd">    ... &#39;b -&gt; _add&#39;,</span>
<span class="sd">    ... &#39;mult [label=&quot;mult&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;the_product [label=&quot;the_product&quot; shape=&quot;box&quot;]&#39;,</span>
<span class="sd">    ... &#39;the_product -&gt; mult&#39;,</span>
<span class="sd">    ... &#39;x [label=&quot;x&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;y [label=&quot;y=&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;x -&gt; the_product&#39;,</span>
<span class="sd">    ... &#39;y -&gt; the_product&#39;,</span>
<span class="sd">    ... &#39;exp [label=&quot;exp&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;_exp [label=&quot;_exp&quot; shape=&quot;box&quot;]&#39;,</span>
<span class="sd">    ... &#39;_exp -&gt; exp&#39;,</span>
<span class="sd">    ... &#39;mult [label=&quot;mult&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;a [label=&quot;a&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;mult -&gt; _exp&#39;,</span>
<span class="sd">    ... &#39;a -&gt; _exp&#39;</span>
<span class="sd">    ... ]  # doctest: +SKIP</span>

<span class="sd">    &gt;&gt;&gt; from meshed.util import dot_to_ascii</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(dot_to_ascii(&#39;\n&#39;.join(lines)))  # doctest: +SKIP</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">                    a        </span>
<span class="sd">                              </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">               </span>
<span class="sd">     b=       _add       </span>
<span class="sd">               </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">                              </span>
<span class="sd">                    x         </span>
<span class="sd">                              </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">               </span>
<span class="sd">     y=    the_product   </span>
<span class="sd">               </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">                              </span>
<span class="sd">                  mult        </span>
<span class="sd">                              </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">                             </span>
<span class="sd">               </span>
<span class="sd">                 _exp      </span>
<span class="sd">             </span>
<span class="sd">               </span>
<span class="sd">               </span>
<span class="sd">               </span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">                   exp</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">yield from</span> <span class="n">start_lines</span>
    <span class="n">validate_that_func_node_names_are_sane</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="n">func_nodes</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">dot_lines_of_func_node</span><span class="p">(</span><span class="n">func_node</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">dot_lines_of_func_node</span><span class="p">(</span><span class="n">func_node</span><span class="p">:</span> <span class="n">FuncNode</span><span class="p">):</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">func_node</span><span class="o">.</span><span class="n">out</span>
    <span class="n">func_id</span> <span class="o">=</span> <span class="n">func_node</span><span class="o">.</span><span class="n">name</span>
    <span class="n">func_label</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func_node</span><span class="p">,</span> <span class="s1">&#39;func_label&#39;</span><span class="p">,</span> <span class="n">func_id</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="n">func_id</span><span class="p">:</span>  <span class="c1"># though forbidden in default FuncNode validation</span>
        <span class="n">func_id</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">func_id</span>

    <span class="c1"># Get the Parameter objects for sig, with names changed to bind ones</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">func_node</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">ch_names</span><span class="p">(</span><span class="o">**</span><span class="n">func_node</span><span class="o">.</span><span class="n">bind</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>

    <span class="k">yield from</span> <span class="n">dot_lines_of_func_parameters</span><span class="p">(</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">func_id</span><span class="o">=</span><span class="n">func_id</span><span class="p">,</span> <span class="n">func_label</span><span class="o">=</span><span class="n">func_label</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_add_new_line_if_none</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Since graphviz 0.18, need to have a newline in body lines.</span>
<span class="sd">    This util is there to address that, adding newlines to body lines</span>
<span class="sd">    when missing.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">s</span>


<span class="c1"># ---------- with ext.gk -------------------------------------------------------</span>

<span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">meshed.ext.gk</span> <span class="kn">import</span> <span class="n">operation</span><span class="p">,</span> <span class="n">Operation</span>

<div class="viewcode-block" id="funcs_to_operations"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.funcs_to_operations">[docs]</a>    <span class="k">def</span> <span class="nf">funcs_to_operations</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">Operation</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get an operation from a callable&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">_func_name</span> <span class="o">=</span> <span class="n">mk_func_name</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span>
            <span class="n">exclude_names</span> <span class="o">=</span> <span class="n">exclude_names</span> <span class="o">+</span> <span class="p">(</span><span class="n">_func_name</span><span class="p">,)</span>
            <span class="n">needs</span> <span class="o">=</span> <span class="n">arg_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">_func_name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span>
            <span class="n">exclude_names</span> <span class="o">=</span> <span class="n">exclude_names</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">needs</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">operation</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">_func_name</span><span class="p">,</span> <span class="n">needs</span><span class="o">=</span><span class="n">needs</span><span class="p">,</span> <span class="n">provides</span><span class="o">=</span><span class="n">_func_name</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="funcs_to_operators"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.funcs_to_operators">[docs]</a>    <span class="k">def</span> <span class="nf">funcs_to_operators</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">Operation</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get an operation from a callable&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">operation</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">funcs_to_operations</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">operation</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>