
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>meshed.dag &#8212; meshed 0.1.10 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for meshed.dag</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Making DAGs</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">suppress</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">Sized</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Any</span>

<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">call_forgivingly</span><span class="p">,</span>
    <span class="n">call_somewhat_forgivingly</span><span class="p">,</span>
    <span class="n">Parameter</span><span class="p">,</span>
    <span class="n">empty</span><span class="p">,</span>
    <span class="n">Sig</span><span class="p">,</span>
    <span class="n">sort_params</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">meshed.util</span> <span class="kn">import</span> <span class="n">lambda_name</span>
<span class="kn">from</span> <span class="nn">meshed.itools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">topological_sort</span><span class="p">,</span>
    <span class="n">add_edge</span><span class="p">,</span>
    <span class="n">leaf_nodes</span><span class="p">,</span>
    <span class="n">root_nodes</span><span class="p">,</span>
    <span class="n">descendants</span><span class="p">,</span>
    <span class="n">ancestors</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="ValidationError"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.ValidationError">[docs]</a><span class="k">class</span> <span class="nc">ValidationError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error that is raised when an object&#39;s validation failed&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="NotUniqueError"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.NotUniqueError">[docs]</a><span class="k">class</span> <span class="nc">NotUniqueError</span><span class="p">(</span><span class="n">ValidationError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Error to be raised when unicity is expected, but violated&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="NotFound"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.NotFound">[docs]</a><span class="k">class</span> <span class="nc">NotFound</span><span class="p">(</span><span class="n">ValidationError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;To be raised when something is expected to exist, but doesn&#39;t&quot;&quot;&quot;</span></div>


<span class="k">def</span> <span class="nf">find_first_free_name</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">(),</span> <span class="n">start_at</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_names</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prefix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">start_at</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s1">__</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_names</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">mk_func_name</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">()):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&lt;lambda&gt;&#39;</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">lambda_name</span><span class="p">()</span>  <span class="c1"># make a lambda name that is a unique identifier</span>
    <span class="k">return</span> <span class="n">find_first_free_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">arg_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">()):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
        <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">exclude_names</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_exclude_names</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found_name</span> <span class="o">=</span> <span class="n">find_first_free_name</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s1">__</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">_exclude_names</span>
                <span class="p">)</span>
                <span class="k">yield</span> <span class="n">found_name</span>
                <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">_exclude_names</span> <span class="o">+</span> <span class="p">(</span><span class="n">found_name</span><span class="p">,)</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>


<div class="viewcode-block" id="named_partial"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.named_partial">[docs]</a><span class="k">def</span> <span class="nf">named_partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="vm">__name__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;functools.partial, but with a __name__</span>
<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;print&#39;</span>
<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;, __name__=&#39;now_partial_has_a_name&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;now_partial_has_a_name&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="ow">or</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="n">f</span></div>


<span class="kn">from</span> <span class="nn">i2.deco</span> <span class="kn">import</span> <span class="n">ch_func_to_all_pk</span>


<div class="viewcode-block" id="hook_up"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.hook_up">[docs]</a><span class="k">def</span> <span class="nf">hook_up</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Source inputs and write outputs to given variables mapping.</span>

<span class="sd">    Returns inputless and outputless function that will, when called,</span>
<span class="sd">    get relevant inputs from the provided variables mapping and write it&#39;s</span>
<span class="sd">    output there as well.</span>

<span class="sd">    :param variables: The MutableMapping (like... a dict) where the function</span>
<span class="sd">    should both read it&#39;s input and write it&#39;s output.</span>
<span class="sd">    :param output_name: The key of the variables mapping that should be used</span>
<span class="sd">    to write the output of the function</span>
<span class="sd">    :return: A function</span>

<span class="sd">    &gt;&gt;&gt; def formula1(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">    ...     return ((w + x) * y) ** z</span>

<span class="sd">    &gt;&gt;&gt; d = {}</span>
<span class="sd">    &gt;&gt;&gt; f = hook_up(formula1, d)</span>
<span class="sd">    &gt;&gt;&gt; # NOTE: update d, not d = dict(...), which would make a DIFFERENT d</span>
<span class="sd">    &gt;&gt;&gt; d.update(w=2, x=3, y=4)  # not d = dict(w=2, x=3, y=4), which would</span>
<span class="sd">    &gt;&gt;&gt; f()</span>

<span class="sd">    Note that there&#39;s no output. The output is in d</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;w&#39;: 2, &#39;x&#39;: 3, &#39;y&#39;: 4, &#39;formula1&#39;: 20}</span>

<span class="sd">    Again...</span>

<span class="sd">    &gt;&gt;&gt; d.clear()</span>
<span class="sd">    &gt;&gt;&gt; d.update(w=1, x=2, y=3)</span>
<span class="sd">    &gt;&gt;&gt; f()</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;formula1&#39;]</span>
<span class="sd">    9</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_func</span> <span class="o">=</span> <span class="n">ch_func_to_all_pk</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>  <span class="c1"># makes a position-keyword copy of func</span>
    <span class="n">output_key</span> <span class="o">=</span> <span class="n">output_name</span>
    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_key</span> <span class="o">=</span> <span class="n">_func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">source_from_decorated</span><span class="p">():</span>
        <span class="n">variables</span><span class="p">[</span><span class="n">output_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">call_forgivingly</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="o">**</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">source_from_decorated</span></div>


<span class="c1"># replaced by call_forgivingly</span>
<span class="c1"># def call_func_ignoring_excess(func, **kwargs):</span>
<span class="c1">#     &quot;&quot;&quot;Call func, sourcing the arguments from kwargs and ignoring the excess arguments.</span>
<span class="c1">#     Also works if func has some position only arguments.</span>
<span class="c1">#     &quot;&quot;&quot;</span>
<span class="c1">#     s = Sig(func)</span>
<span class="c1">#     args, kwargs = s.args_and_kwargs_from_kwargs(s.source_kwargs(**kwargs))</span>
<span class="c1">#     return func(*args, **kwargs)</span>


<span class="k">def</span> <span class="nf">_complete_dict_with_iterable_of_required_keys</span><span class="p">(</span>
    <span class="n">to_complete</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">complete_with</span><span class="p">:</span> <span class="n">Iterable</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Complete `to_complete` (in place) with `complete_with`</span>
<span class="sd">    `complete_with` contains values that must be covered by `to_complete`</span>
<span class="sd">    Those values that are not covered will be inserted in to_complete,</span>
<span class="sd">    with key=val</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;a&#39;: &#39;A&#39;, &#39;c&#39;: &#39;C&#39;}</span>
<span class="sd">    &gt;&gt;&gt; _complete_dict_with_iterable_of_required_keys(d, &#39;abc&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;a&#39;: &#39;A&#39;, &#39;c&#39;: &#39;C&#39;, &#39;b&#39;: &#39;b&#39;}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys_already_covered</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">to_complete</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">required_key</span> <span class="ow">in</span> <span class="n">complete_with</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">required_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys_already_covered</span><span class="p">:</span>
            <span class="n">to_complete</span><span class="p">[</span><span class="n">required_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">required_key</span>


<span class="k">def</span> <span class="nf">_inverse_dict_asserting_losslessness</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">inv_d</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_d</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;can&#39;t invert: You have some duplicate values in this dict: &quot;</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">inv_d</span>


<span class="k">def</span> <span class="nf">_old_mapped_extraction</span><span class="p">(</span><span class="n">extract_from</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">key_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Deprecated: Old version of _mapped_extraction.</span>

<span class="sd">    for every (k, v) of key_map whose v is a key of extract_from, yields</span>
<span class="sd">    (v, extract_from[v])</span>

<span class="sd">    Meant to be curried into an extractor, and wrapped in dict.</span>

<span class="sd">    &gt;&gt;&gt; extracted = _old_mapped_extraction(</span>
<span class="sd">    ...     {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}, # extract_from</span>
<span class="sd">    ...     {&#39;A&#39;: &#39;a&#39;, &#39;C&#39;: &#39;c&#39;, &#39;D&#39;: &#39;d&#39;}  # note that there&#39;s no &#39;d&#39; in extract_from</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; dict(extracted)</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;c&#39;: 3}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">key_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">extract_from</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">v</span><span class="p">,</span> <span class="n">extract_from</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_mapped_extraction</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">to_extract</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;for every (desired_name, src_name) of to_extract whose v is a key of source,</span>
<span class="sd">    yields (desired_name, source[src_name])</span>

<span class="sd">    It&#39;s purpose is to extract inputs from a src.</span>
<span class="sd">    The names used in the src may be different from those desired by the function,</span>
<span class="sd">    those to_extract specifies what to extract by a {desired_name: src_name, ...}</span>
<span class="sd">    map.</span>

<span class="sd">    _mapped_extraction_ is mant to be curried into an extractor.</span>

<span class="sd">    &gt;&gt;&gt; extracted = _mapped_extraction(</span>
<span class="sd">    ...     src={&#39;A&#39;: 1, &#39;B&#39;: 2, &#39;C&#39;: 3},</span>
<span class="sd">    ...     to_extract={&#39;a&#39;: &#39;A&#39;, &#39;c&#39;: &#39;C&#39;, &#39;d&#39;: &#39;D&#39;}  # note that there&#39;s no &#39;d&#39; here</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; dict(extracted)</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;c&#39;: 3}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">desired_name</span><span class="p">,</span> <span class="n">src_name</span> <span class="ow">in</span> <span class="n">to_extract</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">src_name</span> <span class="ow">in</span> <span class="n">src</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">desired_name</span><span class="p">,</span> <span class="n">src</span><span class="p">[</span><span class="n">src_name</span><span class="p">]</span>


<div class="viewcode-block" id="underscore_func_node_names_maker"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.underscore_func_node_names_maker">[docs]</a><span class="k">def</span> <span class="nf">underscore_func_node_names_maker</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This name maker will resolve names in the following fashion:</span>
<span class="sd">     (1) look at the (func) name and out given as arguments, if None...</span>
<span class="sd">     (3) use mk_func_name(func) to make names.</span>

<span class="sd">    It will use the mk_func_name(func)  itself for out, but suffix the same with</span>
<span class="sd">    an underscore to provide a mk_func_name.</span>

<span class="sd">    This is so because here we want to allow easy construction of function networks</span>
<span class="sd">    where a function&#39;s output will be used as another&#39;s input argument when</span>
<span class="sd">    that argument has the the function&#39;s (output) name.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="n">out</span>

    <span class="n">name_of_func</span> <span class="o">=</span> <span class="n">mk_func_name</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name_of_func</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">name_of_func</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">name</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name_of_func</span><span class="p">,</span> <span class="n">out</span></div>


<span class="k">def</span> <span class="nf">duplicates</span><span class="p">(</span><span class="n">elements</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">,</span> <span class="n">Sized</span><span class="p">]):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">basic_node_validator</span><span class="p">(</span><span class="n">func_node</span><span class="p">):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">func_node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func_node</span><span class="o">.</span><span class="n">out</span><span class="p">,</span> <span class="o">*</span><span class="n">func_node</span><span class="o">.</span><span class="n">bind</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

    <span class="c1"># Make sure there&#39;s no name duplicates</span>
    <span class="n">_duplicates</span> <span class="o">=</span> <span class="n">duplicates</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">_duplicates</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_node</span><span class="si">}</span><span class="s1"> has duplicate names: </span><span class="si">{</span><span class="n">_duplicates</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Make sure all names are identifiers</span>
    <span class="n">_non_identifiers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="ow">not</span> <span class="n">name</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">(),</span> <span class="n">names</span><span class="p">))</span>
    <span class="c1"># print(_non_identifiers, names)</span>
    <span class="k">if</span> <span class="n">_non_identifiers</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_node</span><span class="si">}</span><span class="s1"> non-identifier names: </span><span class="si">{</span><span class="n">_non_identifiers</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># Making sure all src_name keys are in the function&#39;s signature</span>
    <span class="n">bind_names_not_in_sig_names</span> <span class="o">=</span> <span class="n">func_node</span><span class="o">.</span><span class="n">bind</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">func_node</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">bind_names_not_in_sig_names</span><span class="p">,</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;some bind keys weren&#39;t found as function argnames: &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bind_names_not_in_sig_names</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>


<span class="c1"># TODO: Think of the hash more carefully.</span>
<span class="c1"># TODO: Allo</span>
<div class="viewcode-block" id="FuncNode"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.FuncNode">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">FuncNode</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A function wrapper that makes the function amenable to operating in a network.</span>

<span class="sd">    :param func: Function to wrap</span>
<span class="sd">    :param name: The name to associate to the function</span>
<span class="sd">    :param bind: The {func_argname: external_name,...} mapping that defines where</span>
<span class="sd">        the node will source the data to call the function.</span>
<span class="sd">        This only has to be used if the external names are different from the names</span>
<span class="sd">        of the arguments of the function.</span>
<span class="sd">    :param out: The variable name the function should write it&#39;s result to</span>

<span class="sd">    Like we stated: `FuncNode` is meant to operate in computational networks.</span>
<span class="sd">    But knowing what it does will help you make the networks you want, so we commend</span>
<span class="sd">    your curiousity, and will oblige with an explanation.</span>

<span class="sd">    Say you have a function to multiply numbers.</span>

<span class="sd">    &gt;&gt;&gt; def multiply(x, y):</span>
<span class="sd">    ...     return x * y</span>

<span class="sd">    And you use it in some code like this:</span>

<span class="sd">    &gt;&gt;&gt; item_price = 3.5</span>
<span class="sd">    &gt;&gt;&gt; num_of_items = 2</span>
<span class="sd">    &gt;&gt;&gt; total_price = multiply(item_price, num_of_items)</span>

<span class="sd">    What the execution of `total_price = multiply(item_price, num_of_items)` does is</span>
<span class="sd">    - grab the values (in the locals scope -- a dict), of ``item_price`` and ``num_of_items``,</span>
<span class="sd">    - call the multiply function on these, and then</span>
<span class="sd">    - write the result to a variable (in locals) named ``total_price``</span>

<span class="sd">    `FuncNode` is a function wrapper that specification of such a</span>
<span class="sd">    `output = function(...inputs...)` assignment statement</span>
<span class="sd">    in such a way that it can carry it out on a `scope`.</span>
<span class="sd">    A `scope` is a `dict` where the function can find it&#39;s input values and write its</span>
<span class="sd">    output values.</span>

<span class="sd">    For example, the `FuncNode` form of the above statement would be:</span>

<span class="sd">    &gt;&gt;&gt; func_node = FuncNode(</span>
<span class="sd">    ...     func=multiply,</span>
<span class="sd">    ...     bind={&#39;x&#39;: &#39;item_price&#39;, &#39;y&#39;: &#39;num_of_items&#39;})</span>
<span class="sd">    &gt;&gt;&gt; func_node</span>
<span class="sd">    FuncNode(item_price,num_of_items -&gt; multiply_ -&gt; multiply)</span>

<span class="sd">    Note the `bind` is a mapping **from** the variable names of the wrapped function</span>
<span class="sd">    **to** the names of the scope.</span>

<span class="sd">    That is, when it&#39;s time to execute, it tells the `FuncNode` where to find the values</span>
<span class="sd">    of its inputs.</span>

<span class="sd">    If an input is not specified in this `bind` mapping, the scope</span>
<span class="sd">    (external) name is supposed to be the same as the function&#39;s (internal) name.</span>

<span class="sd">    The purpose of a `FuncNode` is to source some inputs somewhere, compute something</span>
<span class="sd">    with these, and write the result somewhere. That somewhere is what we call a</span>
<span class="sd">    scope. A scope is a dictionary (or any mutuable mapping to be precise) and it works</span>
<span class="sd">    like this:</span>

<span class="sd">    &gt;&gt;&gt; scope = {&#39;item_price&#39;: 3.5, &#39;num_of_items&#39;: 2}</span>
<span class="sd">    &gt;&gt;&gt; func_node(scope)  # see that it returns 7.0</span>
<span class="sd">    7.0</span>
<span class="sd">    &gt;&gt;&gt; scope  # but also wrote this in the scope</span>
<span class="sd">    {&#39;item_price&#39;: 3.5, &#39;num_of_items&#39;: 2, &#39;multiply&#39;: 7.0}</span>

<span class="sd">    Consider ``item_price,num_of_items -&gt; multiply_ -&gt; multiply``.</span>
<span class="sd">    See that the name of the function is used for the name of its output,</span>
<span class="sd">    and an underscore-suffixed name for its function name.</span>
<span class="sd">    That&#39;s the default behavior if you don&#39;t specify either a name (of the function)</span>
<span class="sd">    for the `FuncNode`, or a `out`.</span>
<span class="sd">    The underscore is to distinguish from the name of the function itself.</span>
<span class="sd">    The function gets the underscore because this favors particular naming style.</span>

<span class="sd">    You can give it a custom name as well.</span>

<span class="sd">    &gt;&gt;&gt; FuncNode(multiply, name=&#39;total_price&#39;, out=&#39;daily_expense&#39;)</span>
<span class="sd">    FuncNode(x,y -&gt; total_price -&gt; daily_expense)</span>

<span class="sd">    If you give an `out`, but not a `name` (for the function), the function&#39;s</span>
<span class="sd">    name will be taken:</span>

<span class="sd">    &gt;&gt;&gt; FuncNode(multiply, out=&#39;daily_expense&#39;)</span>
<span class="sd">    FuncNode(x,y -&gt; multiply -&gt; daily_expense)</span>

<span class="sd">    If you give a `name`, but not a `out`, an underscore-prefixed version of</span>
<span class="sd">    the `name` will be taken:</span>
<span class="sd">    &gt;&gt;&gt; FuncNode(multiply, name=&#39;total_price&#39;)</span>
<span class="sd">    FuncNode(x,y -&gt; total_price -&gt; _total_price)</span>

<span class="sd">    Note: In the context of networks if you want to reuse a same function</span>
<span class="sd">    (say, `multiply`) in multiple places</span>
<span class="sd">    you&#39;ll **need** to give it a custom name because the functions are identified by</span>
<span class="sd">    this name in the network.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">bind</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">out</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">write_output_into_scope</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># TODO: Do we really want to allow False?</span>
    <span class="n">names_maker</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">underscore_func_node_names_maker</span>
    <span class="n">node_validator</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">basic_node_validator</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names_maker</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">)</span>

        <span class="c1"># The wrapped function&#39;s signature will be useful</span>
        <span class="c1"># when interfacing with it and the scope.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>

        <span class="c1"># complete bind with the argnames of the signature</span>
        <span class="n">_complete_dict_with_iterable_of_required_keys</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extractor</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_mapped_extraction</span><span class="p">,</span> <span class="n">to_extract</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_validator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">synopsis_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> &quot;</span> <span class="sa">f</span><span class="s1">&#39;-&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="si">}</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;FuncNode(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">()</span><span class="si">}</span><span class="s1">)&#39;</span>

<div class="viewcode-block" id="FuncNode.call_on_scope"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.FuncNode.call_on_scope">[docs]</a>    <span class="k">def</span> <span class="nf">call_on_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">:</span> <span class="n">MutableMapping</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call the function using the given scope both to source arguments and write</span>
<span class="sd">        results.</span>

<span class="sd">        Note: This method is only meant to be used as a backend to __call__, not as</span>
<span class="sd">        an actual interface method. Additional control/constraints on read and writes</span>
<span class="sd">        can be implemented by providing a custom scope for that.&quot;&quot;&quot;</span>
        <span class="n">relevant_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extractor</span><span class="p">(</span><span class="n">scope</span><span class="p">))</span>
        <span class="c1"># print(scope, relevant_kwargs)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="p">(),</span> <span class="n">relevant_kwargs</span><span class="p">,</span> <span class="n">enforce_sig</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sig</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">write_output_into_scope</span><span class="p">:</span>
            <span class="n">scope</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>
        <span class="k">return</span> <span class="n">output</span></div>

    <span class="k">def</span> <span class="nf">_hash_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Design ideo.</span>
<span class="sd">        Attempt to construct a hash that reflects the actual identity we want.</span>
<span class="sd">        Need to transform to int. Only identifier chars alphanumerics and underscore</span>
<span class="sd">        and space are used, so could possibly encode as int (for __hash__ method)</span>
<span class="sd">        in a way that is reverse-decodable and with reasonable int size.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;::&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">out</span>

    <span class="c1"># TODO: Find a better one</span>
    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_hash_str</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deprecated: Don&#39;t use. Might be a normal function with a signature&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_on_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>

<div class="viewcode-block" id="FuncNode.has_as_instance"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.FuncNode.has_as_instance">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">has_as_instance</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Verify if obj is an instance of a FuncNode (or specific sub-class).</span>

<span class="sd">        The usefulness of this method is to not have to make a lambda with isinstance</span>
<span class="sd">        when filtering.</span>

<span class="sd">        &gt;&gt;&gt; FuncNode.has_as_instance(FuncNode(lambda x: x))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; FuncNode.has_as_instance(&quot;I am not a FuncNode: I&#39;m a string&quot;)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="validate_that_func_node_names_are_sane"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.validate_that_func_node_names_are_sane">[docs]</a><span class="k">def</span> <span class="nf">validate_that_func_node_names_are_sane</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Assert that the names of func_nodes are sane.</span>
<span class="sd">    That is:</span>
<span class="sd">        - are valid dot (graphviz) names (we&#39;ll use str.isidentifier because lazy)</span>
<span class="sd">        - All the func.name and func.out are unique</span>
<span class="sd">        - more to come</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">)</span>
    <span class="n">node_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">func_nodes</span><span class="p">]</span>
    <span class="n">outs</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">out</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">func_nodes</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">,</span> <span class="n">node_names</span><span class="p">)</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;some node names weren&#39;t valid identifiers: </span><span class="si">{</span><span class="n">node_names</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">isidentifier</span><span class="p">,</span> <span class="n">outs</span><span class="p">)</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;some return names weren&#39;t valid identifiers: </span><span class="si">{</span><span class="n">outs</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">outs</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">node_names</span> <span class="o">+</span> <span class="n">outs</span><span class="p">)</span>
        <span class="n">offending_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Some of your node names and/or outs where used more than once. &#39;</span>
            <span class="sa">f</span><span class="s2">&quot;They shouldn&#39;t. These are the names I find offensive: </span><span class="si">{</span><span class="n">offending_names</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_mk_func_nodes</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">):</span>
    <span class="c1"># TODO: Take care of names (or track and take care if collision)</span>
    <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="n">func_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_node</span><span class="p">,</span> <span class="n">FuncNode</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">func_node</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_node</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">func_node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t convert this to a FuncNode: </span><span class="si">{</span><span class="n">func_node</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_func_nodes_to_graph_dict</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">func_nodes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">src_name</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">bind</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">add_edge</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">src_name</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">add_edge</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">g</span>


<div class="viewcode-block" id="is_func_node"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.is_func_node">[docs]</a><span class="k">def</span> <span class="nf">is_func_node</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; is_func_node(FuncNode(lambda x: x))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; is_func_node(&quot;I am not a FuncNode: I&#39;m a string&quot;)</span>
<span class="sd">    False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">FuncNode</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_not_func_node"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.is_not_func_node">[docs]</a><span class="k">def</span> <span class="nf">is_not_func_node</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; is_not_func_node(FuncNode(lambda x: x))</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; is_not_func_node(&quot;I am not a FuncNode: I&#39;m a string&quot;)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">FuncNode</span><span class="o">.</span><span class="n">has_as_instance</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></div>


<div class="viewcode-block" id="extract_values"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.extract_values">[docs]</a><span class="k">def</span> <span class="nf">extract_values</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;generator of values extracted from d for keys&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></div>


<div class="viewcode-block" id="extract_items"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.extract_items">[docs]</a><span class="k">def</span> <span class="nf">extract_items</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;generator of (k, v) pairs extracted from d for keys&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></div>


<span class="k">def</span> <span class="nf">_separate_func_nodes_and_var_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
    <span class="n">func_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">var_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_func_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">func_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func_nodes</span><span class="p">,</span> <span class="n">var_nodes</span>


<span class="n">_not_found</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_find_unique_element</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">search_iterable</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Find item in search_iterable, using key as the matching function,</span>
<span class="sd">    raising a NotFound error if no match and a NotUniqueError if more than one.&quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">search_iterable</span><span class="p">)</span>
    <span class="n">first</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">_not_found</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="n">_not_found</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NotFound</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> wasn&#39;t found&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">the_next_match</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">_not_found</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_next_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_not_found</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotUniqueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> wasn&#39;t unique&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">first</span>


<span class="n">ParameterMerger</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]],</span> <span class="n">Parameter</span><span class="p">]</span>
<span class="n">conservative_parameter_merge</span><span class="p">:</span> <span class="n">ParameterMerger</span>


<div class="viewcode-block" id="conservative_parameter_merge"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.conservative_parameter_merge">[docs]</a><span class="k">def</span> <span class="nf">conservative_parameter_merge</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Validates that all the params are exactly the same, returning the first is so.&quot;&quot;&quot;</span>
    <span class="n">first_param</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">params</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same name: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same kind: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same default: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">annotation</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">annotation</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same annotation: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">first_param</span></div>


<span class="c1"># TODO: caching last scope isn&#39;t really the DAG&#39;s direct concern -- it&#39;s a debugging</span>
<span class="c1">#  concern. Perhaps a more general form would be to define a cache factory defaulting</span>
<span class="c1">#  to a dict, but that could be a &quot;dict&quot; that logs writes (even to an attribute of self)</span>
<div class="viewcode-block" id="DAG"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">DAG</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; from meshed.dag import DAG, Sig</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def this(a, b=1):</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def that(x, b=1):</span>
<span class="sd">    ...     return x * b</span>
<span class="sd">    &gt;&gt;&gt; def combine(this, that):</span>
<span class="sd">    ...     return (this, that)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; dag = DAG((this, that, combine))</span>
<span class="sd">    &gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">    x,b -&gt; that_ -&gt; that</span>
<span class="sd">    a,b -&gt; this_ -&gt; this</span>
<span class="sd">    this,that -&gt; combine_ -&gt; combine</span>

<span class="sd">    But what does it do?</span>

<span class="sd">    It&#39;s a callable, with a signature:</span>

<span class="sd">    &gt;&gt;&gt; Sig(dag)  # doctest: +SKIP</span>
<span class="sd">    &lt;Sig (x, a, b=1)&gt;</span>

<span class="sd">    And when you call it, it executes the dag from the root values you give it and</span>
<span class="sd">    returns the leaf output values.</span>

<span class="sd">    &gt;&gt;&gt; dag(1, 2, 3)  # (a+b,x*b) == (2+3,1*3) == (5, 3)</span>
<span class="sd">    (5, 3)</span>
<span class="sd">    &gt;&gt;&gt; dag(1, 2)  # (a+b,x*b) == (2+1,1*1) == (3, 1)</span>
<span class="sd">    (3, 1)</span>

<span class="sd">    The above DAG was created straight from the functions, using only the names of the</span>
<span class="sd">    functions and their arguments to define how to hook the network up.</span>

<span class="sd">    But if you didn&#39;t write those functions specifically for that purpose, or you want</span>
<span class="sd">    to use someone else&#39;s functions, we got you covered.</span>

<span class="sd">    You can define the name of the node (the `name` argument), the name of the output</span>
<span class="sd">    (the `out` argument) and a mapping from the function&#39;s arguments names to</span>
<span class="sd">    &quot;network names&quot; (through the `bind` argument).</span>
<span class="sd">    The edges of the DAG are defined by matching `out` TO `bind`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">func_nodes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span>
    <span class="n">cache_last_scope</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">parameter_merge</span><span class="p">:</span> <span class="n">ParameterMerger</span> <span class="o">=</span> <span class="n">conservative_parameter_merge</span>
    <span class="n">new_scope</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="nb">dict</span>  <span class="c1"># can return a prepopulated scope too!</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_mk_func_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">_func_nodes_to_graph_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">topological_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="c1"># reorder the nodes to fit topological order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_nodes</span> <span class="o">=</span> <span class="n">_separate_func_nodes_and_var_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="c1"># figure out the roots and leaves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">root_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leafs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">leaf_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
        <span class="c1"># self.sig = Sig(dict(extract_items(sig.parameters, &#39;xz&#39;)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">sort_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">src_name_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">roots</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># to put the signature on the callable DAG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_scope</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_on_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">extract_values</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">leafs</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tup</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="DAG.call_on_scope"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.call_on_scope">[docs]</a>    <span class="k">def</span> <span class="nf">call_on_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls the func_nodes using scope (a dict or MutableMapping) both to</span>
<span class="sd">        source it&#39;s arguments and write it&#39;s results.</span>

<span class="sd">        Note: This method is only meant to be used as a backend to __call__, not as</span>
<span class="sd">        an actual interface method. Additional control/constraints on read and writes</span>
<span class="sd">        can be implemented by providing a custom scope for that. For example, one could</span>
<span class="sd">        log read and/or writes to specific keys, or disallow overwriting to an existing</span>
<span class="sd">        key (useful for pipeline sanity), etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scope</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_scope</span><span class="p">()</span>  <span class="c1"># fresh new scope</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_last_scope</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_scope</span> <span class="o">=</span> <span class="n">scope</span>  <span class="c1"># just to remember it, for debugging purposes ONLY!</span>

        <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">:</span>
            <span class="n">func_node</span><span class="o">.</span><span class="n">call_on_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span></div>

    <span class="c1"># def clone(self, *args, **kwargs):</span>
    <span class="c1">#     &quot;&quot;&quot;Use args, kwargs to make an instance, using self attributes for</span>
    <span class="c1">#     unspecified arguments.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">ins</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">_descendants</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="n">FuncNode</span><span class="o">.</span><span class="n">has_as_instance</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span> <span class="o">|</span> <span class="n">descendants</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">ins</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">_ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="n">FuncNode</span><span class="o">.</span><span class="n">has_as_instance</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">|</span> <span class="n">ancestors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">outs</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">subgraph_nodes</span> <span class="o">=</span> <span class="n">_descendants</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">_ancestors</span><span class="p">)</span>
        <span class="c1"># TODO: When clone ready, use to do `constructor = type(self)` instead of DAG</span>
        <span class="c1"># constructor = type(self)  # instead of DAG</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span>
            <span class="n">func_nodes</span><span class="o">=</span><span class="n">subgraph_nodes</span><span class="p">,</span>
            <span class="n">cache_last_scope</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_last_scope</span><span class="p">,</span>
            <span class="n">parameter_merge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_merge</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">process_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>

        <span class="n">empty_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">ensure_variable_list</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="o">==</span> <span class="n">empty_slice</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_nodes</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">)):</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_matching</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_matching</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unrecognized variables specification: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Only items of size 1 or 2 are supported&#39;</span>
        <span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">ensure_variable_list</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span>

    <span class="k">def</span> <span class="nf">get_node_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">pattern</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_nodes</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pattern</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_node_for_name</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_node_for_func</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">NotFound</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No matching node: </span><span class="si">{</span><span class="n">pattern</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">func_node_for_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_find_unique_element</span><span class="p">(</span>
            <span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">name</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">name</span> <span class="o">==</span> <span class="n">fn</span><span class="o">.</span><span class="n">name</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">func_node_for_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_find_unique_element</span><span class="p">(</span>
            <span class="n">func</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">,</span> <span class="n">fn</span><span class="p">:</span> <span class="n">func</span> <span class="o">==</span> <span class="n">fn</span><span class="o">.</span><span class="n">func</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Yields the self.func_nodes</span>
<span class="sd">        Note: The raison d&#39;etre of this ``__iter__`` is simply because if no custom one</span>
<span class="sd">        is provided, python defaults to yielding ``__getitem__[i]`` for integers,</span>
<span class="sd">        which leads to an error being raised.</span>

<span class="sd">        At least here we yield something sensible.</span>

<span class="sd">        A consequence of the `__iter__` being the iterable of func_nodes is that we</span>
<span class="sd">        can extend dags using the star operator. Consider the following dag;</span>

<span class="sd">        &gt;&gt;&gt; def f(a): return a * 2</span>
<span class="sd">        &gt;&gt;&gt; def g(f, b): return f + b</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g])</span>
<span class="sd">        &gt;&gt;&gt; assert dag(2, 3) == 7</span>

<span class="sd">        Say you wanted to now take a, b, and the output og g, and feed it to another</span>
<span class="sd">        function...</span>

<span class="sd">        &gt;&gt;&gt; def h(a, b, g): return f&quot;{a=} {b=} {g=}&quot;</span>
<span class="sd">        &gt;&gt;&gt; extended_dag = DAG([*dag, h])</span>
<span class="sd">        &gt;&gt;&gt; extended_dag(a=2, b=3)</span>
<span class="sd">        &#39;a=2 b=3 g=7&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span>

    <span class="c1"># ------------ utils --------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">src_name_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">src_name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">bind</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">d</span><span class="p">[</span><span class="n">src_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">arg_name</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">bind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">src_name</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">bind</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">src_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">src_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_merge</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">src_name</span><span class="p">)</span>

    <span class="c1"># ------------ display --------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">synopsis_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func_node</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">()</span> <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span>

    <span class="c1"># TODO: Give more control (merge with lined)</span>
    <span class="k">def</span> <span class="nf">dot_digraph_body</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">yield from</span> <span class="n">dot_lines_of_func_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph_ascii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an ascii art string that represents the pipeline&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">lined.util</span> <span class="kn">import</span> <span class="n">dot_to_ascii</span>

        <span class="k">return</span> <span class="n">dot_to_ascii</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot_digraph_body</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>

    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">graphviz</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="se">\n</span><span class="s1">You may not have graphviz installed. &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;See https://pypi.org/project/graphviz/.&#39;</span>
            <span class="p">)</span>

        <span class="n">body</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot_digraph_body</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="n">body</span><span class="p">)</span></div>


<span class="c1"># These are the defaults used in lined.</span>
<span class="c1"># TODO: Merge some of the functionalities around graph displays in lined and meshed</span>
<span class="n">dflt_configs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">fnode_shape</span><span class="o">=</span><span class="s1">&#39;box&#39;</span><span class="p">,</span>
    <span class="n">vnode_shape</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
    <span class="n">display_all_arguments</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">edge_kind</span><span class="o">=</span><span class="s1">&#39;to_args_on_edge&#39;</span><span class="p">,</span>
    <span class="n">input_node</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">output_node</span><span class="o">=</span><span class="s1">&#39;output&#39;</span><span class="p">,</span>
<span class="p">)</span>


<span class="k">def</span> <span class="nf">param_to_dot_definition</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">dflt_configs</span><span class="p">[</span><span class="s1">&#39;vnode_shape&#39;</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">empty</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;=&#39;</span>
    <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;**&#39;</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> [label=&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; shape=&quot;</span><span class="si">{</span><span class="n">shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>


<span class="k">def</span> <span class="nf">call_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dot_lines_of_func_parameters</span><span class="p">(</span>
    <span class="n">parameters</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">],</span>
    <span class="n">out</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">output_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">dflt_configs</span><span class="p">[</span><span class="s1">&#39;vnode_shape&#39;</span><span class="p">],</span>
    <span class="n">func_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">dflt_configs</span><span class="p">[</span><span class="s1">&#39;fnode_shape&#39;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
    <span class="k">assert</span> <span class="n">func_name</span> <span class="o">!=</span> <span class="n">out</span><span class="p">,</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Your func and output name shouldn&#39;t be the &quot;</span> <span class="sa">f</span><span class="s1">&#39;same: </span><span class="si">{</span><span class="n">out</span><span class="si">=}</span><span class="s1"> </span><span class="si">{</span><span class="n">func_name</span><span class="si">=}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1"> [label=&quot;</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1">&quot; shape=&quot;</span><span class="si">{</span><span class="n">output_shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s1"> [label=&quot;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s1">&quot; shape=&quot;</span><span class="si">{</span><span class="n">func_shape</span><span class="si">}</span><span class="s1">&quot;]&#39;</span>
    <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="c1"># args -&gt; func</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">param_to_dot_definition</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parameters</span><span class="p">:</span>
        <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s1">&#39;</span>


<span class="k">def</span> <span class="nf">_parameters_and_names_from_sig</span><span class="p">(</span>
    <span class="n">sig</span><span class="p">:</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="n">func_name</span> <span class="ow">or</span> <span class="n">sig</span><span class="o">.</span><span class="n">name</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="ow">or</span> <span class="n">sig</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="n">func_name</span> <span class="o">==</span> <span class="n">out</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">func_name</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">func_name</span>


<div class="viewcode-block" id="dot_lines_of_func_nodes"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.dot_lines_of_func_nodes">[docs]</a><span class="k">def</span> <span class="nf">dot_lines_of_func_nodes</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">]):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Got lines generator for the graphviz.DiGraph(body=list(...))</span>

<span class="sd">    &gt;&gt;&gt; def add(a, b=1):</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def mult(x, y=3):</span>
<span class="sd">    ...     return x * y</span>
<span class="sd">    &gt;&gt;&gt; def exp(mult, a):</span>
<span class="sd">    ...     return mult ** a</span>
<span class="sd">    &gt;&gt;&gt; func_nodes = [</span>
<span class="sd">    ...     FuncNode(add, out=&#39;x&#39;),</span>
<span class="sd">    ...     FuncNode(mult, name=&#39;the_product&#39;),</span>
<span class="sd">    ...     FuncNode(exp)</span>
<span class="sd">    ... ]</span>
<span class="sd">    &gt;&gt;&gt; lines = list(dot_lines_of_func_nodes(func_nodes))</span>
<span class="sd">    &gt;&gt;&gt; assert lines == [</span>
<span class="sd">    ... &#39;x [label=&quot;x&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;_add [label=&quot;_add&quot; shape=&quot;box&quot;]&#39;,</span>
<span class="sd">    ... &#39;_add -&gt; x&#39;,</span>
<span class="sd">    ... &#39;a [label=&quot;a&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;b [label=&quot;b=&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;a -&gt; _add&#39;,</span>
<span class="sd">    ... &#39;b -&gt; _add&#39;,</span>
<span class="sd">    ... &#39;mult [label=&quot;mult&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;the_product [label=&quot;the_product&quot; shape=&quot;box&quot;]&#39;,</span>
<span class="sd">    ... &#39;the_product -&gt; mult&#39;,</span>
<span class="sd">    ... &#39;x [label=&quot;x&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;y [label=&quot;y=&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;x -&gt; the_product&#39;,</span>
<span class="sd">    ... &#39;y -&gt; the_product&#39;,</span>
<span class="sd">    ... &#39;exp [label=&quot;exp&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;_exp [label=&quot;_exp&quot; shape=&quot;box&quot;]&#39;,</span>
<span class="sd">    ... &#39;_exp -&gt; exp&#39;,</span>
<span class="sd">    ... &#39;mult [label=&quot;mult&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;a [label=&quot;a&quot; shape=&quot;none&quot;]&#39;,</span>
<span class="sd">    ... &#39;mult -&gt; _exp&#39;,</span>
<span class="sd">    ... &#39;a -&gt; _exp&#39;</span>
<span class="sd">    ... ]  # doctest: +SKIP</span>

<span class="sd">    &gt;&gt;&gt; from lined.util import dot_to_ascii</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(dot_to_ascii(&#39;\n&#39;.join(lines)))  # doctest: +SKIP</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">                    a        ─┐</span>
<span class="sd">                              │</span>
<span class="sd">               │              │</span>
<span class="sd">               │              │</span>
<span class="sd">               ▼              │</span>
<span class="sd">             ┌─────────────┐  │</span>
<span class="sd">     b=  ──▶ │    _add     │  │</span>
<span class="sd">             └─────────────┘  │</span>
<span class="sd">               │              │</span>
<span class="sd">               │              │</span>
<span class="sd">               ▼              │</span>
<span class="sd">                              │</span>
<span class="sd">                    x         │</span>
<span class="sd">                              │</span>
<span class="sd">               │              │</span>
<span class="sd">               │              │</span>
<span class="sd">               ▼              │</span>
<span class="sd">             ┌─────────────┐  │</span>
<span class="sd">     y=  ──▶ │ the_product │  │</span>
<span class="sd">             └─────────────┘  │</span>
<span class="sd">               │              │</span>
<span class="sd">               │              │</span>
<span class="sd">               ▼              │</span>
<span class="sd">                              │</span>
<span class="sd">                  mult        │</span>
<span class="sd">                              │</span>
<span class="sd">               │              │</span>
<span class="sd">               │              │</span>
<span class="sd">               ▼              │</span>
<span class="sd">             ┌─────────────┐  │</span>
<span class="sd">             │    _exp     │ ◀┘</span>
<span class="sd">             └─────────────┘</span>
<span class="sd">               │</span>
<span class="sd">               │</span>
<span class="sd">               ▼</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">                   exp</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">validate_that_func_node_names_are_sane</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="n">func_nodes</span><span class="p">:</span>
        <span class="k">yield from</span> <span class="n">dot_lines_of_func_node</span><span class="p">(</span><span class="n">func_node</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">dot_lines_of_func_node</span><span class="p">(</span><span class="n">func_node</span><span class="p">:</span> <span class="n">FuncNode</span><span class="p">):</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">func_node</span><span class="o">.</span><span class="n">out</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="n">func_node</span><span class="o">.</span><span class="n">name</span>
    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="n">func_name</span><span class="p">:</span>  <span class="c1"># though forbidden in default FuncNode validation</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">func_name</span>

    <span class="c1"># Get the Parameter objects for sig, with names changed to bind ones</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">func_node</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">ch_names</span><span class="p">(</span><span class="o">**</span><span class="n">func_node</span><span class="o">.</span><span class="n">bind</span><span class="p">)</span><span class="o">.</span><span class="n">params</span>

    <span class="k">yield from</span> <span class="n">dot_lines_of_func_parameters</span><span class="p">(</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="n">func_name</span><span class="p">,</span>
    <span class="p">)</span>


<span class="c1"># ---------- with ext.gk -------------------------------------------------------</span>

<span class="k">with</span> <span class="n">suppress</span><span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">meshed.ext.gk</span> <span class="kn">import</span> <span class="n">operation</span><span class="p">,</span> <span class="n">Network</span><span class="p">,</span> <span class="n">Operation</span>

<div class="viewcode-block" id="funcs_to_operations"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.funcs_to_operations">[docs]</a>    <span class="k">def</span> <span class="nf">funcs_to_operations</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">Operation</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get an operation from a callable&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
            <span class="n">_func_name</span> <span class="o">=</span> <span class="n">mk_func_name</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span>
            <span class="n">exclude_names</span> <span class="o">=</span> <span class="n">exclude_names</span> <span class="o">+</span> <span class="p">(</span><span class="n">_func_name</span><span class="p">,)</span>
            <span class="n">needs</span> <span class="o">=</span> <span class="n">arg_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">_func_name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span>
            <span class="n">exclude_names</span> <span class="o">=</span> <span class="n">exclude_names</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">needs</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">operation</span><span class="p">(</span>
                <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">_func_name</span><span class="p">,</span> <span class="n">needs</span><span class="o">=</span><span class="n">needs</span><span class="p">,</span> <span class="n">provides</span><span class="o">=</span><span class="n">_func_name</span><span class="p">,</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="funcs_to_operators"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.funcs_to_operators">[docs]</a>    <span class="k">def</span> <span class="nf">funcs_to_operators</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">())</span> <span class="o">-&gt;</span> <span class="n">Operation</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get an operation from a callable&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">func</span><span class="p">,</span> <span class="n">operation</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">funcs_to_operations</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)):</span>
            <span class="k">yield</span> <span class="n">operation</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">meshed</a></h1>








<h3>Navigation</h3>
<p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed.html">meshed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/dag.html">meshed.dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/dag_experiments.html">meshed.dag_experiments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/dag_experiments/misc_utils.html">meshed.dag_experiments.misc_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext.html">meshed.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk.html">meshed.ext.gk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk_tests.html">meshed.ext.gk_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/itools.html">meshed.itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/makers.html">meshed.makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap.html">meshed.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/gk_with_networkx.html">meshed.scrap.gk_with_networkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests.html">meshed.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag.html">meshed.tests.test_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/utils_for_testing.html">meshed.tests.utils_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/util.html">meshed.util</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;NO COPYRIGHT.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>