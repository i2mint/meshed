<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>meshed.util &mdash; meshed 0.1.142 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            meshed
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed.html">meshed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/base.html">meshed.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/caching.html">meshed.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/components.html">meshed.components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/composition.html">meshed.composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/dag.html">meshed.dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples.html">meshed.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/online_marketing.html">meshed.examples.online_marketing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/price_elasticity.html">meshed.examples.price_elasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/vaccine_vs_no_vaccine.html">meshed.examples.vaccine_vs_no_vaccine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext.html">meshed.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk.html">meshed.ext.gk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk_tests.html">meshed.ext.gk_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/itools.html">meshed.itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/makers.html">meshed.makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap.html">meshed.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/annotations_to_meshes.html">meshed.scrap.annotations_to_meshes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/cached_dag.html">meshed.scrap.cached_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/collapse_and_expand.html">meshed.scrap.collapse_and_expand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/conversion.html">meshed.scrap.conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/dask_graph_language.html">meshed.scrap.dask_graph_language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/flow_control_script.html">meshed.scrap.flow_control_script</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/gk_with_networkx.html">meshed.scrap.gk_with_networkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/gui_interaction.html">meshed.scrap.gui_interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/misc_utils.html">meshed.scrap.misc_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/reactive_scope.html">meshed.scrap.reactive_scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/wrapping_dags.html">meshed.scrap.wrapping_dags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/slabs.html">meshed.slabs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests.html">meshed.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/objects_for_testing.html">meshed.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_base.html">meshed.tests.test_base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_caching.html">meshed.tests.test_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_ch_funcs.html">meshed.tests.test_ch_funcs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_components.html">meshed.tests.test_components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_composition.html">meshed.tests.test_composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag.html">meshed.tests.test_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_2.html">meshed.tests.test_dag_2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_defaults.html">meshed.tests.test_dag_defaults</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_variadics.html">meshed.tests.test_dag_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_getitem.html">meshed.tests.test_getitem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_itools.html">meshed.tests.test_itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_makers.html">meshed.tests.test_makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_tools.html">meshed.tests.test_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_util.html">meshed.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/utils_for_testing.html">meshed.tests.utils_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tools.html">meshed.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/util.html">meshed.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/viz.html">meshed.viz</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">meshed</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">meshed.util</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for meshed.util</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;util functions&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span><span class="p">,</span> <span class="n">getmodule</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="kn">import</span> <span class="n">ModuleType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">TypeVar</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">import_module</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

<span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">name_of_obj</span><span class="p">,</span> <span class="n">LiteralVal</span><span class="p">,</span> <span class="n">FuncFanout</span><span class="p">,</span> <span class="n">Pipe</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="objects_defined_in_module"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.objects_defined_in_module">[docs]</a><span class="k">def</span> <span class="nf">objects_defined_in_module</span><span class="p">(</span>
    <span class="n">module</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ModuleType</span><span class="p">],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">name_filt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">obj_filt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a dictionary of objects defined in a Python module, optionally filtered by their names and values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    module: Union[str, ModuleType]</span>
<span class="sd">        The module to look up. Can either be the module object itself, or a string specifying the</span>
<span class="sd">        module&#39;s fully qualified name (e.g., &#39;os.path&#39;).</span>

<span class="sd">    name_filt: Optional[Callable], default=None</span>
<span class="sd">        An optional function used to filter the names of objects in the module.</span>
<span class="sd">        This function should take a single argument (the object name as a string)</span>
<span class="sd">        and return a boolean. Only objects whose names pass the filter (i.e.,</span>
<span class="sd">        for which the function returns True) are included.</span>
<span class="sd">        If None, no name filtering is applied.</span>

<span class="sd">    obj_filt: Optional[Callable], default=None</span>
<span class="sd">        An optional function used to filter the objects in the module. This function should take a</span>
<span class="sd">        single argument (the object itself) and return a boolean. Only objects that pass the filter</span>
<span class="sd">        (i.e., for which the function returns True) are included.</span>
<span class="sd">        If None, no object filtering is applied.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        A dictionary where keys are names of objects defined in the module (filtered by name_filt and obj_filt)</span>
<span class="sd">        and values are the corresponding objects.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import os</span>
<span class="sd">    &gt;&gt;&gt; all_os_objects = objects_defined_in_module(os)</span>
<span class="sd">    &gt;&gt;&gt; &#39;removedirs&#39; in all_os_objects</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; all_os_objects[&#39;removedirs&#39;] == os.removedirs</span>
<span class="sd">    True</span>

<span class="sd">    See that you can specify the module via a string too, and filter to get only</span>
<span class="sd">    callables that don&#39;t start with an underscore:</span>

<span class="sd">    &gt;&gt;&gt; this_modules_funcs = objects_defined_in_module(</span>
<span class="sd">    ...     &#39;meshed.util&#39;,</span>
<span class="sd">    ...     name_filt=lambda name: not name.startswith(&#39;_&#39;),</span>
<span class="sd">    ...     obj_filt=callable,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; callable(this_modules_funcs[&#39;objects_defined_in_module&#39;])</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">import_module</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="n">name_filt</span> <span class="o">=</span> <span class="n">name_filt</span> <span class="ow">or</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">obj_filt</span> <span class="o">=</span> <span class="n">obj_filt</span> <span class="ow">or</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">module_objs</span> <span class="o">=</span> <span class="nb">vars</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="c1"># Note we only filter for names here, not objects, because we want to keep the</span>
    <span class="c1"># object filtering for after we&#39;ve gotten the module objects</span>
    <span class="n">name_and_module</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">getmodule</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">module_objs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name_filt</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">}</span>
    <span class="n">obj_names</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">obj_name</span>
        <span class="k">for</span> <span class="n">obj_name</span><span class="p">,</span> <span class="n">obj_module</span> <span class="ow">in</span> <span class="n">name_and_module</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">obj_module</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">obj_module</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="n">module</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">module_objs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">obj_names</span> <span class="k">if</span> <span class="n">obj_filt</span><span class="p">(</span><span class="n">module_objs</span><span class="p">[</span><span class="n">k</span><span class="p">])}</span></div>


<div class="viewcode-block" id="provides"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.provides">[docs]</a><span class="k">def</span> <span class="nf">provides</span><span class="p">(</span><span class="o">*</span><span class="n">var_names</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Callable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decorator to assign ``var_names`` to a ``_provides`` attribute of function.</span>

<span class="sd">    This is meant to be used to indicate to a mesh what var nodes a function can source</span>
<span class="sd">    values for.</span>

<span class="sd">    &gt;&gt;&gt; @provides(&#39;a&#39;, &#39;b&#39;)</span>
<span class="sd">    ... def f(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    &gt;&gt;&gt; f._provides</span>
<span class="sd">    (&#39;a&#39;, &#39;b&#39;)</span>

<span class="sd">    If no ``var_names`` are given, then the function name is used as the var name:</span>

<span class="sd">    &gt;&gt;&gt; @provides()</span>
<span class="sd">    ... def g(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    &gt;&gt;&gt; g._provides</span>
<span class="sd">    (&#39;g&#39;,)</span>

<span class="sd">    If ``var_names`` contains ``&#39;_&#39;``, then the function name is used as the var name</span>
<span class="sd">    for that position:</span>

<span class="sd">    &gt;&gt;&gt; @provides(&#39;b&#39;, &#39;_&#39;)</span>
<span class="sd">    ... def h(x):</span>
<span class="sd">    ...     return x + 1</span>
<span class="sd">    &gt;&gt;&gt; h._provides</span>
<span class="sd">    (&#39;b&#39;, &#39;h&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">add_provides_attribute</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">var_names</span><span class="p">:</span>
            <span class="n">var_names_</span> <span class="o">=</span> <span class="p">(</span><span class="n">name_of_obj</span><span class="p">(</span><span class="n">func</span><span class="p">),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_names_</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="p">[</span><span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span> <span class="k">else</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="n">func</span><span class="o">.</span><span class="n">_provides</span> <span class="o">=</span> <span class="n">var_names_</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="k">return</span> <span class="n">add_provides_attribute</span></div>


<div class="viewcode-block" id="if_then_else"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.if_then_else">[docs]</a><span class="k">def</span> <span class="nf">if_then_else</span><span class="p">(</span><span class="n">if_func</span><span class="p">,</span> <span class="n">then_func</span><span class="p">,</span> <span class="n">else_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tool to &quot;functionalize&quot; the if-then-else logic.</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; f = partial(if_then_else, str.isnumeric, int, str)</span>
<span class="sd">    &gt;&gt;&gt; f(&#39;a string&#39;)</span>
<span class="sd">    &#39;a string&#39;</span>
<span class="sd">    &gt;&gt;&gt; f(&#39;42&#39;)</span>
<span class="sd">    42</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">if_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">then_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">else_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<span class="c1"># TODO: Revise FuncFanout so it makes a generator of values, or items, instead of a dict</span>
<div class="viewcode-block" id="funcs_conjunction"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.funcs_conjunction">[docs]</a><span class="k">def</span> <span class="nf">funcs_conjunction</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a conjunction of functions. That is, ``func1(x) and func2(x) and ...``</span>

<span class="sd">    &gt;&gt;&gt; f = funcs_conjunction(lambda x: isinstance(x, str), lambda x: len(x) &gt;= 5)</span>
<span class="sd">    &gt;&gt;&gt; f(&#39;app&#39;)  # because length is less than 5...</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; f(&#39;apple&#39;)  # length at least 5 so...</span>
<span class="sd">    True</span>

<span class="sd">    Note that in:</span>

<span class="sd">    &gt;&gt;&gt; f(42)</span>
<span class="sd">    False</span>

<span class="sd">    it is ``False`` because it is not a string.</span>
<span class="sd">    This shows that the second function is not applied to the input at all, since it</span>
<span class="sd">    doesn&#39;t need to, and if it were, we&#39;d get an error (length of a number?!).</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">FuncFanout</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">),</span> <span class="n">partial</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="nb">all</span><span class="p">)</span></div>


<div class="viewcode-block" id="funcs_disjunction"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.funcs_disjunction">[docs]</a><span class="k">def</span> <span class="nf">funcs_disjunction</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Makes a disjunction of functions. That is, ``func1(x) or func2(x) or ...``</span>

<span class="sd">    &gt;&gt;&gt; f = funcs_disjunction(lambda x: x &gt; 10, lambda x: x &lt; -5)</span>
<span class="sd">    &gt;&gt;&gt; f(7)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; f(-7)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Pipe</span><span class="p">(</span><span class="n">FuncFanout</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">),</span> <span class="n">partial</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span> <span class="nb">any</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">extra_wraps</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc_prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">func_name</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">func</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="n">doc_prefix</span> <span class="o">+</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span>


<span class="k">def</span> <span class="nf">mywraps</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">doc_prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">wrapped</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">extra_wraps</span><span class="p">(</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)(</span><span class="n">wrapped</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">doc_prefix</span><span class="o">=</span><span class="n">doc_prefix</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrapper</span>


<div class="viewcode-block" id="iterize"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.iterize">[docs]</a><span class="k">def</span> <span class="nf">iterize</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From an Input-&gt;Ouput function, makes a Iterator[Input]-&gt;Itertor[Output]</span>
<span class="sd">    Some call this &quot;vectorization&quot;, but it&#39;s not really a vector, but an</span>
<span class="sd">    iterable, thus the name.</span>

<span class="sd">    `iterize` is a partial of `map`.</span>

<span class="sd">    &gt;&gt;&gt; f = lambda x: x * 10</span>
<span class="sd">    &gt;&gt;&gt; f(2)</span>
<span class="sd">    20</span>
<span class="sd">    &gt;&gt;&gt; iterized_f = iterize(f)</span>
<span class="sd">    &gt;&gt;&gt; list(iterized_f(iter([1,2,3])))</span>
<span class="sd">    [10, 20, 30]</span>

<span class="sd">    Consider the following pipeline:</span>

<span class="sd">    &gt;&gt;&gt; from i2 import Pipe</span>
<span class="sd">    &gt;&gt;&gt; pipe = Pipe(lambda x: x * 2, lambda x: f&quot;hello {x}&quot;)</span>
<span class="sd">    &gt;&gt;&gt; pipe(1)</span>
<span class="sd">    &#39;hello 2&#39;</span>

<span class="sd">    But what if you wanted to use the pipeline on a &quot;stream&quot; of data. The</span>
<span class="sd">    following wouldn&#39;t work:</span>

<span class="sd">    &gt;&gt;&gt; try:</span>
<span class="sd">    ...     pipe(iter([1,2,3]))</span>
<span class="sd">    ... except TypeError as e:</span>
<span class="sd">    ...     print(f&quot;{type(e).__name__}: {e}&quot;)</span>
<span class="sd">    ...</span>
<span class="sd">    ...</span>
<span class="sd">    TypeError: unsupported operand type(s) for *: &#39;list_iterator&#39; and &#39;int&#39;</span>

<span class="sd">    Remember that error: You&#39;ll surely encounter it at some point.</span>

<span class="sd">    The solution to it is (often): ``iterize``,</span>
<span class="sd">    which transforms a function that is meant to be applied to a single object,</span>
<span class="sd">    into a function that is meant to be applied to an array, or any iterable</span>
<span class="sd">    of such objects.</span>
<span class="sd">    (You might be familiar (if you use `numpy` for example) with the related</span>
<span class="sd">    concept of &quot;vectorization&quot;,</span>
<span class="sd">    or [array programming](https://en.wikipedia.org/wiki/Array_programming).)</span>


<span class="sd">    &gt;&gt;&gt; from i2 import Pipe</span>
<span class="sd">    &gt;&gt;&gt; from meshed.util import iterize</span>
<span class="sd">    &gt;&gt;&gt; from typing import Iterable</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; pipe = Pipe(</span>
<span class="sd">    ...     iterize(lambda x: x * 2),</span>
<span class="sd">    ...     iterize(lambda x: f&quot;hello {x}&quot;)</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; iterable = pipe([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; # see that the result is an iterable</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(iterable, Iterable)</span>
<span class="sd">    &gt;&gt;&gt; list(iterable)  # consume the iterable and gather it&#39;s items</span>
<span class="sd">    [&#39;hello 2&#39;, &#39;hello 4&#39;, &#39;hello 6&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: See if partialx can be used instead</span>
    <span class="n">wrapper</span> <span class="o">=</span> <span class="n">mywraps</span><span class="p">(</span>
        <span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">doc_prefix</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;generator version of </span><span class="si">{</span><span class="n">func_name</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="si">}</span><span class="s1">:</span><span class="se">\n</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="n">func</span><span class="p">))</span></div>


<span class="c1"># from typing import Callable, Any</span>
<span class="c1"># from functools import wraps</span>
<span class="c1"># from i2 import Sig, name_of_obj</span>


<div class="viewcode-block" id="my_isinstance"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.my_isinstance">[docs]</a><span class="k">def</span> <span class="nf">my_isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as builtin instance, but without position only constraint.</span>
<span class="sd">    Therefore, we can partialize class_or_tuple:</span>

<span class="sd">    Otherwise, couldn&#39;t do:</span>

<span class="sd">    &gt;&gt;&gt; isinstance_of_str = partial(my_isinstance, class_or_tuple=str)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(&#39;asdf&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(3)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="p">)</span></div>


<div class="viewcode-block" id="instance_checker"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.instance_checker">[docs]</a><span class="k">def</span> <span class="nf">instance_checker</span><span class="p">(</span><span class="n">class_or_tuple</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Makes a boolean function that checks the instance of an object</span>

<span class="sd">    &gt;&gt;&gt; isinstance_of_str = instance_checker(str)</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(&#39;asdf&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; isinstance_of_str(3)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">my_isinstance</span><span class="p">,</span> <span class="n">class_or_tuple</span><span class="o">=</span><span class="n">class_or_tuple</span><span class="p">)</span></div>


<div class="viewcode-block" id="ConditionalIterize"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.ConditionalIterize">[docs]</a><span class="k">class</span> <span class="nc">ConditionalIterize</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A decorator that &quot;iterizes&quot; a function call if input satisfies a condition.</span>
<span class="sd">    That is, apply ``map(func, input)`` (iterize) or ``func(input)`` according to some</span>
<span class="sd">    conidition on ``input``.</span>

<span class="sd">    &gt;&gt;&gt; def foo(x, y=2):</span>
<span class="sd">    ...     return x * y</span>

<span class="sd">    The function does this:</span>

<span class="sd">    &gt;&gt;&gt; foo(3)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; foo(&#39;string&#39;)</span>
<span class="sd">    &#39;stringstring&#39;</span>

<span class="sd">    The iterized version of the function does this:</span>

<span class="sd">    &gt;&gt;&gt; iterized_foo = iterize(foo)</span>
<span class="sd">    &gt;&gt;&gt; list(iterized_foo([1, 2, 3]))</span>
<span class="sd">    [2, 4, 6]</span>

<span class="sd">    &gt;&gt;&gt; from typing import Iterable</span>
<span class="sd">    &gt;&gt;&gt; new_foo = ConditionalIterize(foo, Iterable)</span>
<span class="sd">    &gt;&gt;&gt; new_foo(3)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; list(new_foo([1, 2, 3]))</span>
<span class="sd">    [2, 4, 6]</span>

<span class="sd">    See what happens if we do this:</span>

<span class="sd">    &gt;&gt;&gt; list(new_foo(&#39;string&#39;))</span>
<span class="sd">    [&#39;ss&#39;, &#39;tt&#39;, &#39;rr&#39;, &#39;ii&#39;, &#39;nn&#39;, &#39;gg&#39;]</span>

<span class="sd">    Maybe you expected `&#39;stringstring&#39;` because you are thinking of `string` as a valid,</span>
<span class="sd">    single input. But the condition of iterization is to be an Iterable, which a</span>
<span class="sd">    string is, thus the (perhaps) unexpected result.</span>

<span class="sd">    In fact, this problem is a general one:</span>
<span class="sd">    If your base function doesn&#39;t process iterables, the ``isinstance(x, Iterable)``</span>
<span class="sd">    is good enough -- but if it is supposed to process an iterable in the first place,</span>
<span class="sd">    how can you distinguish whether to use the iterized version or not?</span>
<span class="sd">    The solution depends on the situation and the iterface you want. You choose.</span>

<span class="sd">    Since the situation where you&#39;ll want to iterize functions in the first place is when</span>
<span class="sd">    you&#39;re building streaming pipelines, a good fallback choice is to iterize if and</span>
<span class="sd">    only if the input is an iterator. This is condition will trigger the iterization</span>
<span class="sd">    when the input has a ``__next__`` -- so things like generators, but not lists,</span>
<span class="sd">    tuples, sets, etc.</span>

<span class="sd">    See in the following that ``ConditionalIterize`` also has a ``wrap`` class method</span>
<span class="sd">    that can be used to wrap a function at definition time.</span>

<span class="sd">    &gt;&gt;&gt; @ConditionalIterize.wrap(Iterator)  # Iterator is the default, so no need here</span>
<span class="sd">    ... def foo(x, y=2):</span>
<span class="sd">    ...     return x * y</span>
<span class="sd">    &gt;&gt;&gt; foo(3)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; foo(&#39;string&#39;)</span>
<span class="sd">    &#39;stringstring&#39;</span>

<span class="sd">    If you want to process a &quot;stream&quot; of numbers 1, 2, 3, don&#39;t do it this way:</span>

<span class="sd">    &gt;&gt;&gt; foo([1, 2, 3])</span>
<span class="sd">    [1, 2, 3, 1, 2, 3]</span>

<span class="sd">    Instead, you should explicitly wrap that iterable in an iterator, to trigger the</span>
<span class="sd">    iterization:</span>

<span class="sd">    &gt;&gt;&gt; list(foo(iter([1, 2, 3])))</span>
<span class="sd">    [2, 4, 6]</span>

<span class="sd">    So far, the only way we controlled the iterize condition is through a type.</span>
<span class="sd">    Really, the condition that is used behind the scenes is</span>
<span class="sd">    ``isinstance(obj, self.iterize_type)``.</span>
<span class="sd">    If you need more complex conditions though, you can specify it through the</span>
<span class="sd">    ``iterize_condition`` argument. The ``iterize_type`` is also used to</span>
<span class="sd">    annotate the resulting wrapped function if it&#39;s first argument is annotated.</span>
<span class="sd">    As a consequence, ``iterize_type`` needs to be a &quot;generic&quot; type.</span>

<span class="sd">    &gt;&gt;&gt; @ConditionalIterize.wrap(Iterable, lambda x: isinstance(x, (list, tuple)))</span>
<span class="sd">    ... def foo(x: int, y=2):</span>
<span class="sd">    ...     return x * y</span>
<span class="sd">    &gt;&gt;&gt; foo(3)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; list(foo([1, 2, 3]))</span>
<span class="sd">    [2, 4, 6]</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>

<span class="sd">    We annotated ``x`` as ``int``, so see now the annotation of the wrapped function:</span>

<span class="sd">    &gt;&gt;&gt; str(signature(foo))</span>
<span class="sd">    &#39;(x: Union[int, Iterable[int]], y=2)&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">iterize_type</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">Iterator</span><span class="p">,</span>
        <span class="n">iterize_condition</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param func:</span>
<span class="sd">        :param iterize_type: The generic type to use for the new annotation</span>
<span class="sd">        :param iterize_condition: The condition to use to check if we should use</span>
<span class="sd">            the iterized version or not. If not given, will use</span>
<span class="sd">            ``functools.partial(my_isinstance, iterize_type)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterize_type</span> <span class="o">=</span> <span class="n">iterize_type</span>
        <span class="k">if</span> <span class="n">iterize_condition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">iterize_condition</span> <span class="o">=</span> <span class="n">instance_checker</span><span class="p">(</span><span class="n">iterize_type</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterize_condition</span> <span class="o">=</span> <span class="n">iterize_condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iterized_func</span> <span class="o">=</span> <span class="n">iterize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="n">wraps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">)(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_sig</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_partial</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">first_arg</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterize_condition</span><span class="p">(</span><span class="n">first_arg</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterized_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&lt;ConditionalIterize </span><span class="si">{</span><span class="n">name_of_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}{</span><span class="n">Sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s1">&gt;&#39;</span>

    <span class="k">def</span> <span class="nf">_new_sig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;You can only apply conditional iterization on functions that have &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;at least one input. This one had none: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
        <span class="n">first_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">new_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span>  <span class="c1"># same sig by default</span>
        <span class="k">if</span> <span class="n">first_param</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">annotations</span><span class="p">:</span>
            <span class="n">obj_annot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">annotations</span><span class="p">[</span><span class="n">first_param</span><span class="p">]</span>
            <span class="n">new_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">ch_annotations</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span><span class="n">first_param</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">obj_annot</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterize_type</span><span class="p">[</span><span class="n">obj_annot</span><span class="p">]]}</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">new_sig</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">wrap</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">iterize_type</span><span class="p">:</span> <span class="nb">type</span> <span class="o">=</span> <span class="n">Iterator</span><span class="p">,</span>
        <span class="n">iterize_condition</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">return</span> <span class="n">partial</span><span class="p">(</span>
            <span class="bp">cls</span><span class="p">,</span> <span class="n">iterize_type</span><span class="o">=</span><span class="n">iterize_type</span><span class="p">,</span> <span class="n">iterize_condition</span><span class="o">=</span><span class="n">iterize_condition</span>
        <span class="p">)</span></div>


<span class="k">class</span> <span class="nc">ModuleNotFoundIgnore</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">exc_type</span> <span class="ow">is</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="kc">True</span>


<div class="viewcode-block" id="incremental_str_maker"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.incremental_str_maker">[docs]</a><span class="k">def</span> <span class="nf">incremental_str_maker</span><span class="p">(</span><span class="n">str_format</span><span class="o">=</span><span class="s1">&#39;{:03.f}&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a function that will produce a (incrementally) new string at every call.&quot;&quot;&quot;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">mk_next_str</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">i</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">str_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mk_next_str</span></div>


<span class="n">lambda_name</span> <span class="o">=</span> <span class="n">incremental_str_maker</span><span class="p">(</span><span class="n">str_format</span><span class="o">=</span><span class="s1">&#39;lambda_</span><span class="si">{:03.0f}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">unnameable_func_name</span> <span class="o">=</span> <span class="n">incremental_str_maker</span><span class="p">(</span><span class="n">str_format</span><span class="o">=</span><span class="s1">&#39;unnameable_func_</span><span class="si">{:03.0f}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">FunctionNamer</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span>

<span class="n">func_name</span><span class="p">:</span> <span class="n">FunctionNamer</span>


<div class="viewcode-block" id="func_name"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.func_name">[docs]</a><span class="k">def</span> <span class="nf">func_name</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The func.__name__ of a callable func, or makes and returns one if that fails.</span>
<span class="sd">    To make one, it calls unamed_func_name which produces incremental names to reduce the chances of clashing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&lt;lambda&gt;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lambda_name</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">name</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unnameable_func_name</span><span class="p">()</span></div>


<span class="c1"># ---------------------------------------------------------------------------------------</span>
<span class="c1"># Misc</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Optional</span>


<div class="viewcode-block" id="args_funcnames"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.args_funcnames">[docs]</a><span class="k">def</span> <span class="nf">args_funcnames</span><span class="p">(</span>
    <span class="n">funcs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">name_of_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FunctionNamer</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_name</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generates (arg_name, func_id) pairs from the iterable of functions&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span>

    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">arg_name</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>  <span class="c1"># initialize</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                <span class="n">arg_name</span> <span class="o">+=</span> <span class="s1">&#39;*&#39;</span>
            <span class="k">elif</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span>
                <span class="n">arg_name</span> <span class="o">+=</span> <span class="s1">&#39;**&#39;</span>
            <span class="n">arg_name</span> <span class="o">+=</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span>  <span class="c1"># append name of param</span>
            <span class="k">yield</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">name_of_func</span><span class="p">(</span><span class="n">func</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">funcs_to_digraph</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">graph</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">graphviz</span> <span class="kn">import</span> <span class="n">Digraph</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">graph</span> <span class="ow">or</span> <span class="n">Digraph</span><span class="p">()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">args_funcnames</span><span class="p">(</span><span class="n">funcs</span><span class="p">)))</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; [shape=box]&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">graph</span>


<div class="viewcode-block" id="dot_to_ascii"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.dot_to_ascii">[docs]</a><span class="k">def</span> <span class="nf">dot_to_ascii</span><span class="p">(</span><span class="n">dot</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fancy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a dot string to an ascii rendering of the diagram.</span>

<span class="sd">    Needs a connection to the internet to work.</span>


<span class="sd">    &gt;&gt;&gt; graph_dot = &#39;&#39;&#39;</span>
<span class="sd">    ...     graph {</span>
<span class="sd">    ...         rankdir=LR</span>
<span class="sd">    ...         0 -- {1 2}</span>
<span class="sd">    ...         1 -- {2}</span>
<span class="sd">    ...         2 -&gt; {0 1 3}</span>
<span class="sd">    ...         3</span>
<span class="sd">    ...     }</span>
<span class="sd">    ... &#39;&#39;&#39;</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; graph_ascii = dot_to_ascii(graph_dot)  # doctest: +SKIP</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; print(graph_ascii)  # doctest: +SKIP</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">                     </span>
<span class="sd">                              </span>
<span class="sd">                        </span>
<span class="sd">        0    1         3 </span>
<span class="sd">                          </span>
<span class="sd">                              </span>
<span class="sd">            2 </span>
<span class="sd">                               </span>
<span class="sd">                               </span>
<span class="sd">          </span>
<span class="sd">                             </span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">requests</span>

    <span class="n">url</span> <span class="o">=</span> <span class="s1">&#39;https://dot-to-ascii.ggerganov.com/dot-to-ascii.php&#39;</span>
    <span class="n">boxart</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># use nice box drawing char instead of + , | , -</span>
    <span class="k">if</span> <span class="n">fancy</span><span class="p">:</span>
        <span class="n">boxart</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">stripped_dot_str</span> <span class="o">=</span> <span class="n">dot</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
        <span class="n">stripped_dot_str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;graph&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">stripped_dot_str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;digraph&#39;</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">dot</span> <span class="o">=</span> <span class="s1">&#39;graph {</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">dot</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">}&#39;</span>

    <span class="n">params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;boxart&#39;</span><span class="p">:</span> <span class="n">boxart</span><span class="p">,</span>
        <span class="s1">&#39;src&#39;</span><span class="p">:</span> <span class="n">dot</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">text</span>
    <span class="k">except</span> <span class="n">requests</span><span class="o">.</span><span class="n">exceptions</span><span class="o">.</span><span class="n">ConnectionError</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;ConnectionError: You need the internet to convert dot into ascii!&#39;</span>

    <span class="k">if</span> <span class="n">response</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s1">&#39;DOT string is not formatted correctly&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">response</span></div>


<span class="k">def</span> <span class="nf">print_ascii_graph</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
    <span class="n">digraph</span> <span class="o">=</span> <span class="n">funcs_to_digraph</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
    <span class="n">dot_str</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">digraph</span><span class="o">.</span><span class="n">body</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">dot_to_ascii</span><span class="p">(</span><span class="n">dot_str</span><span class="p">))</span>


<div class="viewcode-block" id="ValidationError"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.ValidationError">[docs]</a><span class="k">class</span> <span class="nc">ValidationError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Error that is raised when an object&#39;s validation failed&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="NotUniqueError"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.NotUniqueError">[docs]</a><span class="k">class</span> <span class="nc">NotUniqueError</span><span class="p">(</span><span class="n">ValidationError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Error to be raised when unicity is expected, but violated&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="NotFound"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.NotFound">[docs]</a><span class="k">class</span> <span class="nc">NotFound</span><span class="p">(</span><span class="n">ValidationError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;To be raised when something is expected to exist, but doesn&#39;t&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="NameValidationError"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.NameValidationError">[docs]</a><span class="k">class</span> <span class="nc">NameValidationError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use to indicate that there&#39;s a problem with a name or generating a valid name&quot;&quot;&quot;</span></div>


<span class="k">def</span> <span class="nf">find_first_free_name</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">(),</span> <span class="n">start_at</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_names</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prefix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">start_at</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s1">__</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_names</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<div class="viewcode-block" id="mk_func_name"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.mk_func_name">[docs]</a><span class="k">def</span> <span class="nf">mk_func_name</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Makes a function name that doesn&#39;t clash with the exclude_names iterable.</span>
<span class="sd">    Tries it&#39;s best to not be lazy, but instead extract a name from the function</span>
<span class="sd">    itself.&quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;func&#39;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&lt;lambda&gt;&#39;</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">lambda_name</span><span class="p">()</span>  <span class="c1"># make a lambda name that is a unique identifier</span>
    <span class="k">return</span> <span class="n">find_first_free_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">arg_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">()):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
        <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">exclude_names</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_exclude_names</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found_name</span> <span class="o">=</span> <span class="n">find_first_free_name</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s1">__</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">_exclude_names</span>
                <span class="p">)</span>
                <span class="k">yield</span> <span class="n">found_name</span>
                <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">_exclude_names</span> <span class="o">+</span> <span class="p">(</span><span class="n">found_name</span><span class="p">,)</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>


<div class="viewcode-block" id="named_partial"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.named_partial">[docs]</a><span class="k">def</span> <span class="nf">named_partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="vm">__name__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;functools.partial, but with a __name__</span>

<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;print&#39;</span>

<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;, __name__=&#39;now_partial_has_a_name&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;now_partial_has_a_name&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="ow">or</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="n">f</span></div>


<span class="k">def</span> <span class="nf">_place_holder_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">_sig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">_kwargs</span> <span class="o">=</span> <span class="n">_sig</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
    <span class="n">_kwargs_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s1">=</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">_kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_sig</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="n">_kwargs_str</span><span class="si">}</span><span class="s1">)&#39;</span>


<div class="viewcode-block" id="mk_place_holder_func"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.mk_place_holder_func">[docs]</a><span class="k">def</span> <span class="nf">mk_place_holder_func</span><span class="p">(</span><span class="n">arg_names_or_sig</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">defaults</span><span class="o">=</span><span class="p">(),</span> <span class="n">annotations</span><span class="o">=</span><span class="p">()):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make (working and picklable) function with a specific signature.</span>

<span class="sd">    This is useful for testing as well as injecting compliant functions in DAG templates.</span>

<span class="sd">    :param arg_names_or_sig: Anything that i2.Sig can accept as it&#39;s first input.</span>
<span class="sd">        (Such as a string of argument(s), function, signature, etc.)</span>
<span class="sd">    :param name: The ``__name__`` to give the function.</span>
<span class="sd">    :param defaults: If you want to add/change defaults</span>
<span class="sd">    :param annotations: If you want to add/change annotations</span>
<span class="sd">    :return: A (working and picklable) function with a specific signature</span>


<span class="sd">    &gt;&gt;&gt; f = mk_place_holder_func(&#39;a b&#39;, &#39;my_func&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f(1,2)</span>
<span class="sd">    &#39;my_func(a=1, b=2)&#39;</span>

<span class="sd">    The first argument can be any expression of a signature that ``i2.Sig`` can</span>
<span class="sd">    understand. For instance, it could be a function itself.</span>
<span class="sd">    See how the function takes on ``mk_place_holder_func``&#39;s signature and name in the</span>
<span class="sd">    following example:</span>

<span class="sd">    &gt;&gt;&gt; g = mk_place_holder_func(mk_place_holder_func)</span>
<span class="sd">    &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">    &gt;&gt;&gt; str(signature(g))  # should give the same signature as mk_place_holder_func</span>
<span class="sd">    &#39;(arg_names_or_sig, name=None, defaults=(), annotations=())&#39;</span>
<span class="sd">    &gt;&gt;&gt; g(1,2,defaults=3, annotations=4)</span>
<span class="sd">    &#39;mk_place_holder_func(arg_names_or_sig=1, name=2, defaults=3, annotations=4)&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">defaults</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">defaults</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">arg_names_or_sig</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">ch_defaults</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">defaults</span><span class="p">))</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">ch_annotations</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">annotations</span><span class="p">))</span>

    <span class="n">sig</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="n">sig</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;place_holder_func&#39;</span>

    <span class="n">func</span> <span class="o">=</span> <span class="n">sig</span><span class="p">(</span><span class="n">partial</span><span class="p">(</span><span class="n">_place_holder_func</span><span class="p">,</span> <span class="n">_sig</span><span class="o">=</span><span class="n">sig</span><span class="p">))</span>
    <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">name</span>

    <span class="k">return</span> <span class="n">func</span></div>


<span class="c1"># utils to reorder funcnodes</span>


<span class="k">def</span> <span class="nf">pairs</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xs</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">return</span> <span class="n">pairs</span>


<span class="k">def</span> <span class="nf">curry</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">res</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">uncurry</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">res</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">tup</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span>


<span class="n">Renamer</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">_if_none_return_input</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wraps a function so that when the original func outputs None, the wrapped will</span>
<span class="sd">    return the original input instead.</span>

<span class="sd">    &gt;&gt;&gt; def func(x):</span>
<span class="sd">    ...     if x % 2 == 0:</span>
<span class="sd">    ...         return None</span>
<span class="sd">    ...     else:</span>
<span class="sd">    ...         return x * 10</span>
<span class="sd">    &gt;&gt;&gt; wfunc = _if_none_return_input(func)</span>
<span class="sd">    &gt;&gt;&gt; func(3)</span>
<span class="sd">    30</span>
<span class="sd">    &gt;&gt;&gt; wfunc(3)</span>
<span class="sd">    30</span>
<span class="sd">    &gt;&gt;&gt; assert func(4) is None</span>
<span class="sd">    &gt;&gt;&gt; wfunc(4)</span>
<span class="sd">    4</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="n">input_val</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">output_val</span> <span class="o">:=</span> <span class="n">func</span><span class="p">(</span><span class="n">input_val</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output_val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">input_val</span>

    <span class="k">return</span> <span class="n">_func</span>


<div class="viewcode-block" id="numbered_suffix_renamer"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.numbered_suffix_renamer">[docs]</a><span class="k">def</span> <span class="nf">numbered_suffix_renamer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; numbered_suffix_renamer(&#39;item&#39;)</span>
<span class="sd">    &#39;item_1&#39;</span>
<span class="sd">    &gt;&gt;&gt; numbered_suffix_renamer(&#39;item_1&#39;)</span>
<span class="sd">    &#39;item_2&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">sep</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39;(\d+)$&#39;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">sep</span><span class="si">}</span><span class="s1">1&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sep</span><span class="si">}{</span><span class="n">num</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span></div>


<div class="viewcode-block" id="InvalidFunctionParameters"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.InvalidFunctionParameters">[docs]</a><span class="k">class</span> <span class="nc">InvalidFunctionParameters</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;To be used when a function&#39;s parameters are not compliant with some rule about</span>
<span class="sd">    them.&quot;&quot;&quot;</span></div>


<span class="k">def</span> <span class="nf">_suffix</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">start</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">yield</span> <span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">_add_suffix</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s1">&#39;</span>


<span class="n">incremental_suffixes</span> <span class="o">=</span> <span class="n">_suffix</span><span class="p">()</span>
<span class="n">_renamers</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">x</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">suffix</span> <span class="ow">in</span> <span class="n">incremental_suffixes</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_return_val</span><span class="p">(</span><span class="n">first_arg</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_equality_checker</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">val</span>


<span class="k">def</span> <span class="nf">_not_callable</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>


<span class="c1"># Pattern: routing</span>
<span class="c1"># TODO: Replace</span>
<div class="viewcode-block" id="conditional_trans"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.conditional_trans">[docs]</a><span class="k">def</span> <span class="nf">conditional_trans</span><span class="p">(</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="nb">bool</span><span class="p">],</span> <span class="n">trans</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">T</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Conditionally transform an object unless it is marked as a literal.</span>

<span class="sd">    &gt;&gt;&gt; from functools import partial</span>
<span class="sd">    &gt;&gt;&gt; trans = partial(</span>
<span class="sd">    ...     conditional_trans, condition=str.isnumeric, trans=float</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; trans(&#39;not a number&#39;)</span>
<span class="sd">    &#39;not a number&#39;</span>
<span class="sd">    &gt;&gt;&gt; trans(&#39;10&#39;)</span>
<span class="sd">    10.0</span>

<span class="sd">    To use this function but tell it to not transform some a specific input no matter</span>
<span class="sd">    what, wrap the input with ``Literal``</span>

<span class="sd">    &gt;&gt;&gt; # from meshed import Literal</span>
<span class="sd">    &gt;&gt;&gt; conditional_trans(LiteralVal(&#39;10&#39;), str.isnumeric, float)</span>
<span class="sd">    &#39;10&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Maybe make Literal checking less sensitive to isinstance checks, using</span>
    <span class="c1">#   hasattr instead for example.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">LiteralVal</span><span class="p">):</span>  <span class="c1"># If val is a Literal, return its value as is</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">val</span>
    <span class="k">elif</span> <span class="n">condition</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>  <span class="c1"># If obj satisfies condition, return the alternative_obj</span>
        <span class="k">return</span> <span class="n">trans</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># If not, just return object</span>
        <span class="k">return</span> <span class="n">obj</span></div>


<div class="viewcode-block" id="replace_item_in_iterable"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.replace_item_in_iterable">[docs]</a><span class="k">def</span> <span class="nf">replace_item_in_iterable</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">replacement</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">egress</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a list where all items satisfying ``condition(item)`` were replaced</span>
<span class="sd">    with ``replacement(item)``.</span>

<span class="sd">    If ``condition`` is not a callable, it will be considered as a value to check</span>
<span class="sd">    against using ``==``.</span>

<span class="sd">    If ``replacement`` is not a callable, it will be considered as the actual</span>
<span class="sd">    value to replace by.</span>

<span class="sd">    :param iterable: Input iterable of items</span>
<span class="sd">    :param condition: Condition to apply to item to see if it should be replaced</span>
<span class="sd">    :param replacement: (Conditional) replacement value or function</span>
<span class="sd">    :param egress: The function to apply to transformed iterable</span>

<span class="sd">    &gt;&gt;&gt; replace_item_in_iterable([1,2,3,4,5], condition=2, replacement = &#39;two&#39;)</span>
<span class="sd">    [1, &#39;two&#39;, 3, 4, 5]</span>
<span class="sd">    &gt;&gt;&gt; is_even = lambda x: x % 2 == 0</span>
<span class="sd">    &gt;&gt;&gt; replace_item_in_iterable([1,2,3,4,5], condition=is_even, replacement = &#39;even&#39;)</span>
<span class="sd">    [1, &#39;even&#39;, 3, &#39;even&#39;, 5]</span>
<span class="sd">    &gt;&gt;&gt; replace_item_in_iterable([1,2,3,4,5], is_even, replacement=lambda x: x * 10)</span>
<span class="sd">    [1, 20, 3, 40, 5]</span>

<span class="sd">    Note that if the input iterable is not a ``list``, ``tuple``, or ``set``,</span>
<span class="sd">    your output will be an iterator that you&#39;ll have to iterate through to gather</span>
<span class="sd">    transformed items.</span>

<span class="sd">    &gt;&gt;&gt; g = replace_item_in_iterable(iter([1,2,3,4,5]), condition=2, replacement = &#39;two&#39;)</span>
<span class="sd">    &gt;&gt;&gt; isinstance(g, Iterator)</span>
<span class="sd">    True</span>

<span class="sd">    Unless you specify an egress of your choice:</span>

<span class="sd">    &gt;&gt;&gt; replace_item_in_iterable(</span>
<span class="sd">    ... iter([1,2,3,4,5]), is_even, lambda x: x * 10, egress=sorted</span>
<span class="sd">    ... )</span>
<span class="sd">    [1, 3, 5, 20, 40]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If condition or replacement are not callable, make them so</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="n">conditional_trans</span><span class="p">(</span>
        <span class="n">condition</span><span class="p">,</span> <span class="n">_not_callable</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">_equality_checker</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">replacement</span> <span class="o">=</span> <span class="n">conditional_trans</span><span class="p">(</span>
        <span class="n">replacement</span><span class="p">,</span> <span class="n">_not_callable</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">_return_val</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">val</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="c1"># Handle the egress argument</span>
    <span class="k">if</span> <span class="n">egress</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">)):</span>
            <span class="n">egress</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">egress</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span>  <span class="c1"># that is return &quot;as is&quot;</span>

    <span class="c1"># Make the item replacer</span>
    <span class="n">item_replacer</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">conditional_trans</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="n">replacement</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">egress</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">item_replacer</span><span class="p">,</span> <span class="n">iterable</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">_complete_dict_with_iterable_of_required_keys</span><span class="p">(</span>
    <span class="n">to_complete</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">complete_with</span><span class="p">:</span> <span class="n">Iterable</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Complete `to_complete` (in place) with `complete_with`</span>
<span class="sd">    `complete_with` contains values that must be covered by `to_complete`</span>
<span class="sd">    Those values that are not covered will be inserted in to_complete,</span>
<span class="sd">    with key=val</span>

<span class="sd">    &gt;&gt;&gt; d = {&#39;a&#39;: &#39;A&#39;, &#39;c&#39;: &#39;C&#39;}</span>
<span class="sd">    &gt;&gt;&gt; _complete_dict_with_iterable_of_required_keys(d, &#39;abc&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;a&#39;: &#39;A&#39;, &#39;c&#39;: &#39;C&#39;, &#39;b&#39;: &#39;b&#39;}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">keys_already_covered</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">to_complete</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">required_key</span> <span class="ow">in</span> <span class="n">complete_with</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">required_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keys_already_covered</span><span class="p">:</span>
            <span class="n">to_complete</span><span class="p">[</span><span class="n">required_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">required_key</span>


<span class="k">def</span> <span class="nf">inverse_dict_asserting_losslessness</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
    <span class="n">inv_d</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">inv_d</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;can&#39;t invert: You have some duplicate values in this dict: &quot;</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">inv_d</span>


<span class="k">def</span> <span class="nf">_extract_values</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;generator of values extracted from d for keys&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>


<div class="viewcode-block" id="extract_values"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.extract_values">[docs]</a><span class="k">def</span> <span class="nf">extract_values</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract values from dict ``d``, returning them:</span>

<span class="sd">    - as a tuple if len(keys) &gt; 1</span>

<span class="sd">    - a single value if len(keys) == 1</span>

<span class="sd">    - None if not</span>

<span class="sd">    This is used as the default extractor in DAG</span>

<span class="sd">    &gt;&gt;&gt; extract_values({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}, [&#39;a&#39;, &#39;c&#39;])</span>
<span class="sd">    (1, 3)</span>

<span class="sd">    Order matters!</span>

<span class="sd">    &gt;&gt;&gt; extract_values({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}, [&#39;c&#39;, &#39;a&#39;])</span>
<span class="sd">    (3, 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_extract_values</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">keys</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tup</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="extract_items"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.extract_items">[docs]</a><span class="k">def</span> <span class="nf">extract_items</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;generator of (k, v) pairs extracted from d for keys</span>

<span class="sd">    &gt;&gt;&gt; list(extract_items({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}, [&#39;a&#39;, &#39;c&#39;]))</span>
<span class="sd">    [(&#39;a&#39;, 1), (&#39;c&#39;, 3)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">k</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span></div>


<div class="viewcode-block" id="extract_dict"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.extract_dict">[docs]</a><span class="k">def</span> <span class="nf">extract_dict</span><span class="p">(</span><span class="n">d</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract items from dict ``d``, returning them as a dict.</span>

<span class="sd">    &gt;&gt;&gt; extract_dict({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}, [&#39;a&#39;, &#39;c&#39;])</span>
<span class="sd">    {&#39;a&#39;: 1, &#39;c&#39;: 3}</span>

<span class="sd">    Order matters!</span>

<span class="sd">    &gt;&gt;&gt; extract_dict({&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}, [&#39;c&#39;, &#39;a&#39;])</span>
<span class="sd">    {&#39;c&#39;: 3, &#39;a&#39;: 1}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">extract_items</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">keys</span><span class="p">))</span></div>


<span class="n">ParameterMerger</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]],</span> <span class="n">Parameter</span><span class="p">]</span>
<span class="n">parameter_merger</span><span class="p">:</span> <span class="n">ParameterMerger</span>


<span class="c1"># TODO: Be aware of i2.signatures.param_comparator in</span>
<span class="c1">#  https://github.com/i2mint/i2/blob/2bd43b350a3ae29f1e6c587dbe15d6f536635173/i2/signatures.py#L4247</span>
<span class="c1">#  and related funnctions, which are meant to be a more general approach. Consider</span>
<span class="c1">#  merging parameter_merger to use that general tooling.</span>
<span class="c1"># TODO: Make the ValidationError be even more specific, indicating what parameters</span>
<span class="c1">#  are different and how.</span>
<div class="viewcode-block" id="parameter_merger"><a class="viewcode-back" href="../../module_docs/meshed/util.html#meshed.dag.parameter_merger">[docs]</a><span class="k">def</span> <span class="nf">parameter_merger</span><span class="p">(</span>
    <span class="o">*</span><span class="n">params</span><span class="p">,</span> <span class="n">same_name</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">same_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">same_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">same_annotation</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates that all the params are exactly the same, returning the first if so.</span>

<span class="sd">    This is used when hooking up functions that use the same parameters (i.e. arg</span>
<span class="sd">    names). When the name of an argument is used more than once, which kind, default,</span>
<span class="sd">    and annotation should be used in the interface of the DAG?</span>

<span class="sd">    If they&#39;re all the same, there&#39;s no problem.</span>

<span class="sd">    But if they&#39;re not the same, we need to provide control on which to ignore.</span>

<span class="sd">    &gt;&gt;&gt; from inspect import Parameter as P</span>
<span class="sd">    &gt;&gt;&gt; PK = P.POSITIONAL_OR_KEYWORD</span>
<span class="sd">    &gt;&gt;&gt; KO = P.KEYWORD_ONLY</span>
<span class="sd">    &gt;&gt;&gt; parameter_merger(P(&#39;a&#39;, PK), P(&#39;a&#39;, PK))</span>
<span class="sd">    &lt;Parameter &quot;a&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; parameter_merger(P(&#39;a&#39;, PK), P(&#39;different_name&#39;, PK), same_name=False)</span>
<span class="sd">    &lt;Parameter &quot;a&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; parameter_merger(P(&#39;a&#39;, PK), P(&#39;a&#39;, KO), same_kind=False)</span>
<span class="sd">    &lt;Parameter &quot;a&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; parameter_merger(P(&#39;a&#39;, PK), P(&#39;a&#39;, PK,  default=42), same_default=False)</span>
<span class="sd">    &lt;Parameter &quot;a&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; parameter_merger(P(&#39;a&#39;, PK, default=42), P(&#39;a&#39;, PK), same_default=False)</span>
<span class="sd">    &lt;Parameter &quot;a=42&quot;&gt;</span>
<span class="sd">    &gt;&gt;&gt; parameter_merger(P(&#39;a&#39;, PK, annotation=int), P(&#39;a&#39;, PK), same_annotation=False)</span>
<span class="sd">    &lt;Parameter &quot;a: int&quot;&gt;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">suggestion_on_error</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;To resolve this you have several choices:</span>

<span class="s1">    - Change the properties of the param (kind, default, annotation) to be those you </span>
<span class="s1">      want. For example, you can use ``i2.Sig.ch_param_attrs`` on the signatures </span>
<span class="s1">      (or ``i2.Sig.ch_names``, ``i2.Sig.ch_defaults``, ``i2.Sig.ch_kinds``, </span>
<span class="s1">      ``i2.Sig.ch_annotations``)</span>
<span class="s1">      to get a function decorator that will do that for you.</span>
<span class="s1">    - If you&#39;re making a DAG, consider specifying a different ``parameter_merge``.</span>
<span class="s1">      For example you can use ``functools.partial`` on </span>
<span class="s1">      ``meshed.parameter_merger``, fixing ``same_kind``, ``same_default``, </span>
<span class="s1">      and/or ``same_annotation`` to ``False`` to get a more lenient version of it.</span>
<span class="s1">      (See also i2.signatures.param_comparator.)</span>

<span class="s1">    See https://github.com/i2mint/i2/discussions/63 and </span>
<span class="s1">    https://github.com/i2mint/meshed/issues/7 (description and comments) for more</span>
<span class="s1">    info.</span>
<span class="s1">    &#39;&#39;&#39;</span>
    <span class="n">first_param</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">params</span>
    <span class="k">if</span> <span class="n">same_name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same name: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">suggestion_on_error</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">same_kind</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same kind: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">suggestion_on_error</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">same_default</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">default</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">default</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same default: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">suggestion_on_error</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">same_annotation</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">p</span><span class="o">.</span><span class="n">annotation</span> <span class="o">==</span> <span class="n">first_param</span><span class="o">.</span><span class="n">annotation</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Some params didn&#39;t have the same annotation: &quot;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">suggestion_on_error</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">first_param</span></div>


<span class="n">conservative_parameter_merge</span><span class="p">:</span> <span class="n">ParameterMerger</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
    <span class="n">parameter_merger</span><span class="p">,</span> <span class="n">same_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">same_default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">same_annotation</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>