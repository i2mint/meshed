<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>meshed.dag &mdash; meshed 0.1.145 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            meshed
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed.html">meshed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/base.html">meshed.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/caching.html">meshed.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/components.html">meshed.components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/composition.html">meshed.composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/dag.html">meshed.dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples.html">meshed.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/online_marketing.html">meshed.examples.online_marketing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/price_elasticity.html">meshed.examples.price_elasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/vaccine_vs_no_vaccine.html">meshed.examples.vaccine_vs_no_vaccine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext.html">meshed.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk.html">meshed.ext.gk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk_tests.html">meshed.ext.gk_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/itools.html">meshed.itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/makers.html">meshed.makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap.html">meshed.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/annotations_to_meshes.html">meshed.scrap.annotations_to_meshes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/cached_dag.html">meshed.scrap.cached_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/collapse_and_expand.html">meshed.scrap.collapse_and_expand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/conversion.html">meshed.scrap.conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/dask_graph_language.html">meshed.scrap.dask_graph_language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/flow_control_script.html">meshed.scrap.flow_control_script</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/gk_with_networkx.html">meshed.scrap.gk_with_networkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/gui_interaction.html">meshed.scrap.gui_interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/misc_utils.html">meshed.scrap.misc_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/reactive_scope.html">meshed.scrap.reactive_scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/wrapping_dags.html">meshed.scrap.wrapping_dags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/slabs.html">meshed.slabs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests.html">meshed.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/objects_for_testing.html">meshed.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_base.html">meshed.tests.test_base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_caching.html">meshed.tests.test_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_ch_funcs.html">meshed.tests.test_ch_funcs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_components.html">meshed.tests.test_components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_composition.html">meshed.tests.test_composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag.html">meshed.tests.test_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_2.html">meshed.tests.test_dag_2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_defaults.html">meshed.tests.test_dag_defaults</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_variadics.html">meshed.tests.test_dag_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_getitem.html">meshed.tests.test_getitem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_itools.html">meshed.tests.test_itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_makers.html">meshed.tests.test_makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_tools.html">meshed.tests.test_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_util.html">meshed.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/utils_for_testing.html">meshed.tests.utils_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tools.html">meshed.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/util.html">meshed.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/viz.html">meshed.viz</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">meshed</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">meshed.dag</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for meshed.dag</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Making DAGs</span>

<span class="sd">In it&#39;s simplest form, consider this:</span>

<span class="sd">&gt;&gt;&gt; from meshed import DAG</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; def this(a, b=1):</span>
<span class="sd">...     return a + b</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; def that(x, b=1):</span>
<span class="sd">...     return x * b</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt; def combine(this, that):</span>
<span class="sd">...     return (this, that)</span>
<span class="sd">...</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; dag = DAG((this, that, combine))</span>
<span class="sd">&gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">a,b -&gt; this_ -&gt; this</span>
<span class="sd">x,b -&gt; that_ -&gt; that</span>
<span class="sd">this,that -&gt; combine_ -&gt; combine</span>

<span class="sd">But don&#39;t be fooled: There&#39;s much more to it!</span>


<span class="sd">FAQ and Troubleshooting</span>
<span class="sd">=======================</span>

<span class="sd">DAGs and Pipelines</span>
<span class="sd">------------------</span>

<span class="sd">&gt;&gt;&gt; from functools import partial</span>
<span class="sd">&gt;&gt;&gt; from meshed import DAG</span>
<span class="sd">&gt;&gt;&gt; def chunker(sequence, chk_size: int):</span>
<span class="sd">...     return zip(*[iter(sequence)] * chk_size)</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; my_chunker = partial(chunker, chk_size=3)</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; vec = range(8)  # when appropriate, use easier to read sequences</span>
<span class="sd">&gt;&gt;&gt; list(my_chunker(vec))</span>
<span class="sd">[(0, 1, 2), (3, 4, 5)]</span>

<span class="sd">Oh, that&#39;s just a ``my_chunker -&gt; list`` pipeline!</span>
<span class="sd">A pipeline is a subset of DAG, so let me do this:</span>

<span class="sd">&gt;&gt;&gt; dag = DAG([my_chunker, list])</span>
<span class="sd">&gt;&gt;&gt; dag(vec)</span>
<span class="sd">Traceback (most recent call last):</span>
<span class="sd">...</span>
<span class="sd">TypeError: missing a required argument: &#39;sequence&#39;</span>

<span class="sd">What happened here?</span>
<span class="sd">You&#39;re assuming that saying ``[my_chunker, list]`` is enough for DAG to know that</span>
<span class="sd">what you meant is for ``my_chunker`` to feed it&#39;s input to ``list``.</span>
<span class="sd">Sure, DAG has enough information to do so, but the default connection policy doesn&#39;t</span>
<span class="sd">assume that it&#39;s a pipeline you want to make.</span>
<span class="sd">In fact, the order you specify the functions doesn&#39;t have an affect on the connections</span>
<span class="sd">with the default connection policy.</span>

<span class="sd">See what the signature of ``dag`` is:</span>

<span class="sd">&gt;&gt;&gt; from inspect import signature</span>
<span class="sd">&gt;&gt;&gt; str(signature(dag))</span>
<span class="sd">&#39;(iterable=(), /, sequence, *, chk_size: int = 3)&#39;</span>

<span class="sd">So dag actually works just fine. Here&#39;s the proof:</span>

<span class="sd">&gt;&gt;&gt; dag([1,2,3], vec)  # doctest: +SKIP</span>
<span class="sd">([1, 2, 3], &lt;zip object at 0x104d7f080&gt;)</span>

<span class="sd">It&#39;s just not what you might have intended.</span>

<span class="sd">Your best bet to get what you intended is to be explicit.</span>

<span class="sd">The way to be explicit is to not specify functions alone, but ``FuncNodes`` that</span>
<span class="sd">wrap them, along with the specification</span>
<span class="sd">the ``name`` the function will be referred to by,</span>
<span class="sd">the names that it&#39;s parameters should ``bind`` to (that is, where the function</span>
<span class="sd">will get it&#39;s import arguments from), and</span>
<span class="sd">the ``out`` name of where it should be it&#39;s output.</span>

<span class="sd">In the current case a fully specified DAG would look something like this:</span>

<span class="sd">&gt;&gt;&gt; from meshed import FuncNode</span>
<span class="sd">&gt;&gt;&gt; dag = DAG(</span>
<span class="sd">...     [</span>
<span class="sd">...         FuncNode(</span>
<span class="sd">...             func=my_chunker,</span>
<span class="sd">...             name=&#39;chunker&#39;,</span>
<span class="sd">...             bind=dict(sequence=&#39;sequence&#39;, chk_size=&#39;chk_size&#39;),</span>
<span class="sd">...             out=&#39;chks&#39;</span>
<span class="sd">...         ),</span>
<span class="sd">...         FuncNode(</span>
<span class="sd">...             func=list,</span>
<span class="sd">...             name=&#39;gather_chks_into_list&#39;,</span>
<span class="sd">...             bind=dict(iterable=&#39;chks&#39;),</span>
<span class="sd">...             out=&#39;list_of_chks&#39;</span>
<span class="sd">...         ),</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; list(dag(vec))</span>
<span class="sd">[(0, 1, 2), (3, 4, 5)]</span>

<span class="sd">But really, if you didn&#39;t care about the names of things,</span>
<span class="sd">all you need in this case was to make sure that the output of ``my_chunker`` was</span>
<span class="sd">fed to ``list``, and therefore the following was sufficient:</span>

<span class="sd">&gt;&gt;&gt; dag = DAG([</span>
<span class="sd">...     FuncNode(my_chunker, out=&#39;chks&#39;),  # call the output of chunker &quot;chks&quot;</span>
<span class="sd">...     FuncNode(list, bind=dict(iterable=&#39;chks&#39;))  # source list input from &quot;chks&quot;</span>
<span class="sd">... ])</span>
<span class="sd">&gt;&gt;&gt; list(dag(vec))</span>
<span class="sd">[(0, 1, 2), (3, 4, 5)]</span>

<span class="sd">Connection policies are very useful when you want to define ways for DAG to</span>
<span class="sd">&quot;just figure it out&quot; for you.</span>
<span class="sd">That is, you want to tell the machine to adapt to your thoughts, not vice versa.</span>
<span class="sd">We support such technological expectations!</span>
<span class="sd">The default connection policy is there to provide one such ways, but</span>
<span class="sd">by all means, use another!</span>

<span class="sd">Does this mean that connection policies are not for production code?</span>
<span class="sd">Well, it depends. The Zen of Python (``import this``)</span>
<span class="sd">states &quot;explicit is better than implicit&quot;, and indeed it&#39;s often</span>
<span class="sd">a good fallback rule.</span>
<span class="sd">But defining components and the way they should be assembled can go a long way</span>
<span class="sd">in achieving consistency, separation of concerns, adaptability, and flexibility.</span>
<span class="sd">All quite useful things. Also in production. Especially in production.</span>
<span class="sd">That said it is your responsiblity to use the right policy for your particular context.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span><span class="p">,</span> <span class="n">wraps</span><span class="p">,</span> <span class="n">cached_property</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">attrgetter</span><span class="p">,</span> <span class="n">eq</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">MutableMapping</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">KT</span><span class="p">,</span>
    <span class="n">VT</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">double_up_as_factory</span><span class="p">,</span> <span class="n">MultiFunc</span>
<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">call_somewhat_forgivingly</span><span class="p">,</span>
    <span class="n">call_forgivingly</span><span class="p">,</span>
    <span class="n">Parameter</span><span class="p">,</span>
    <span class="n">empty</span><span class="p">,</span>
    <span class="n">Sig</span><span class="p">,</span>
    <span class="n">sort_params</span><span class="p">,</span>
    <span class="c1"># SignatureComparator,</span>
    <span class="n">CallableComparator</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">meshed.base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">FuncNode</span><span class="p">,</span>
    <span class="n">dflt_configs</span><span class="p">,</span>
    <span class="n">BindInfo</span><span class="p">,</span>
    <span class="n">ch_func_node_func</span><span class="p">,</span>
    <span class="n">_mk_func_nodes</span><span class="p">,</span>
    <span class="n">_func_nodes_to_graph_dict</span><span class="p">,</span>
    <span class="n">is_func_node</span><span class="p">,</span>
    <span class="n">FuncNodeAble</span><span class="p">,</span>
    <span class="n">func_node_transformer</span><span class="p">,</span>
    <span class="c1"># compare_signatures,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">meshed.util</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">lambda_name</span><span class="p">,</span>
    <span class="n">ValidationError</span><span class="p">,</span>
    <span class="n">NotUniqueError</span><span class="p">,</span>
    <span class="n">NotFound</span><span class="p">,</span>
    <span class="n">NameValidationError</span><span class="p">,</span>
    <span class="n">Renamer</span><span class="p">,</span>
    <span class="n">_if_none_return_input</span><span class="p">,</span>
    <span class="n">numbered_suffix_renamer</span><span class="p">,</span>
    <span class="n">replace_item_in_iterable</span><span class="p">,</span>
    <span class="n">InvalidFunctionParameters</span><span class="p">,</span>
    <span class="n">extract_values</span><span class="p">,</span>
    <span class="n">extract_items</span><span class="p">,</span>
    <span class="n">ParameterMerger</span><span class="p">,</span>
    <span class="n">conservative_parameter_merge</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">meshed.itools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">topological_sort</span><span class="p">,</span>
    <span class="n">leaf_nodes</span><span class="p">,</span>
    <span class="n">root_nodes</span><span class="p">,</span>
    <span class="n">descendants</span><span class="p">,</span>
    <span class="n">ancestors</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">meshed.viz</span> <span class="kn">import</span> <span class="n">dot_lines_of_objs</span><span class="p">,</span> <span class="n">add_new_line_if_none</span>

<span class="n">FuncMapping</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">Callable</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">KT</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span>


<span class="k">def</span> <span class="nf">order_subset_from_list</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">sublist</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">sublist</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">items</span><span class="p">)),</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">sublist</span><span class="si">}</span><span class="s1"> is not contained in </span><span class="si">{</span><span class="n">items</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">)}</span>

    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">sublist</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">find_first_free_name</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">(),</span> <span class="n">start_at</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_names</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">prefix</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">start_at</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s1">__</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_names</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">mk_mock_funcnode</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">out</span><span class="p">):</span>
    <span class="nd">@Sig</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
        <span class="k">pass</span>

    <span class="c1"># name = &quot;_mock_&quot; + str(arg) + &quot;_&quot; + str(out)  # f-string</span>
    <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;_mock_</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>  <span class="c1"># f-string</span>

    <span class="k">return</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mk_func_name</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">()):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&lt;lambda&gt;&#39;</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">lambda_name</span><span class="p">()</span>  <span class="c1"># make a lambda name that is a unique identifier</span>
    <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">partial</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">mk_func_name</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NameValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Can&#39;t make a name for func: </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">find_first_free_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mk_list_names_unique</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">()):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
        <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">exclude_names</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_exclude_names</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">name</span>
                <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">_exclude_names</span> <span class="o">+</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found_name</span> <span class="o">=</span> <span class="n">find_first_free_name</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">_exclude_names</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">found_name</span>
                <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">_exclude_names</span> <span class="o">+</span> <span class="p">(</span><span class="n">found_name</span><span class="p">,)</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">mk_nodes_names_unique</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
    <span class="n">new_names</span> <span class="o">=</span> <span class="n">mk_list_names_unique</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">new_names</span><span class="p">):</span>
        <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span>
    <span class="k">return</span> <span class="n">nodes</span>


<span class="k">def</span> <span class="nf">arg_names</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="p">()):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">names</span>

    <span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
        <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">exclude_names</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_exclude_names</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">found_name</span> <span class="o">=</span> <span class="n">find_first_free_name</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s1">__</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">_exclude_names</span>
                <span class="p">)</span>
                <span class="k">yield</span> <span class="n">found_name</span>
                <span class="n">_exclude_names</span> <span class="o">=</span> <span class="n">_exclude_names</span> <span class="o">+</span> <span class="p">(</span><span class="n">found_name</span><span class="p">,)</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>


<div class="viewcode-block" id="named_partial"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.named_partial">[docs]</a><span class="k">def</span> <span class="nf">named_partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="vm">__name__</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;functools.partial, but with a __name__</span>

<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;print&#39;</span>

<span class="sd">    &gt;&gt;&gt; f = named_partial(print, sep=&#39;\\n&#39;, __name__=&#39;now_partial_has_a_name&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.__name__</span>
<span class="sd">    &#39;now_partial_has_a_name&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">keywords</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="vm">__name__</span> <span class="ow">or</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">return</span> <span class="n">f</span></div>


<span class="kn">from</span> <span class="nn">i2.signatures</span> <span class="kn">import</span> <span class="n">ch_func_to_all_pk</span>


<div class="viewcode-block" id="hook_up"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.hook_up">[docs]</a><span class="k">def</span> <span class="nf">hook_up</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">MutableMapping</span><span class="p">,</span> <span class="n">output_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Source inputs and write outputs to given variables mapping.</span>

<span class="sd">    Returns inputless and outputless function that will, when called,</span>
<span class="sd">    get relevant inputs from the provided variables mapping and write it&#39;s</span>
<span class="sd">    output there as well.</span>

<span class="sd">    :param variables: The MutableMapping (like... a dict) where the function</span>
<span class="sd">    should both read it&#39;s input and write it&#39;s output.</span>
<span class="sd">    :param output_name: The key of the variables mapping that should be used</span>
<span class="sd">    to write the output of the function</span>
<span class="sd">    :return: A function</span>

<span class="sd">    &gt;&gt;&gt; def formula1(w, /, x: float, y=1, *, z: int = 1):</span>
<span class="sd">    ...     return ((w + x) * y) ** z</span>

<span class="sd">    &gt;&gt;&gt; d = {}</span>
<span class="sd">    &gt;&gt;&gt; f = hook_up(formula1, d)</span>
<span class="sd">    &gt;&gt;&gt; # NOTE: update d, not d = dict(...), which would make a DIFFERENT d</span>
<span class="sd">    &gt;&gt;&gt; d.update(w=2, x=3, y=4)  # not d = dict(w=2, x=3, y=4), which would</span>
<span class="sd">    &gt;&gt;&gt; f()</span>

<span class="sd">    Note that there&#39;s no output. The output is in d</span>
<span class="sd">    &gt;&gt;&gt; d</span>
<span class="sd">    {&#39;w&#39;: 2, &#39;x&#39;: 3, &#39;y&#39;: 4, &#39;formula1&#39;: 20}</span>

<span class="sd">    Again...</span>

<span class="sd">    &gt;&gt;&gt; d.clear()</span>
<span class="sd">    &gt;&gt;&gt; d.update(w=1, x=2, y=3)</span>
<span class="sd">    &gt;&gt;&gt; f()</span>
<span class="sd">    &gt;&gt;&gt; d[&#39;formula1&#39;]</span>
<span class="sd">    9</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_func</span> <span class="o">=</span> <span class="n">ch_func_to_all_pk</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>  <span class="c1"># makes a position-keyword copy of func</span>
    <span class="n">output_key</span> <span class="o">=</span> <span class="n">output_name</span>
    <span class="k">if</span> <span class="n">output_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_key</span> <span class="o">=</span> <span class="n">_func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="k">def</span> <span class="nf">source_from_decorated</span><span class="p">():</span>
        <span class="n">variables</span><span class="p">[</span><span class="n">output_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">call_somewhat_forgivingly</span><span class="p">(</span><span class="n">_func</span><span class="p">,</span> <span class="p">(),</span> <span class="n">variables</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">source_from_decorated</span></div>


<span class="k">def</span> <span class="nf">_separate_func_nodes_and_var_nodes</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>
    <span class="n">func_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">var_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_func_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">func_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func_nodes</span><span class="p">,</span> <span class="n">var_nodes</span>


<span class="n">_not_found</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_find_unique_element</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">search_iterable</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find item in search_iterable, using key as the matching function,</span>
<span class="sd">    raising a NotFound error if no match and a NotUniqueError if more than one.&quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="n">search_iterable</span><span class="p">)</span>
    <span class="n">first</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">_not_found</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">first</span> <span class="o">==</span> <span class="n">_not_found</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">NotFound</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> wasn&#39;t found&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">the_next_match</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">_not_found</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">the_next_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_not_found</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotUniqueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2"> wasn&#39;t unique&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">first</span>


<span class="k">def</span> <span class="nf">modified_func_node</span><span class="p">(</span><span class="n">func_node</span><span class="p">,</span> <span class="o">**</span><span class="n">modifications</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FuncNode</span><span class="p">:</span>
    <span class="n">modifiable_attrs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;bind&#39;</span><span class="p">,</span> <span class="s1">&#39;out&#39;</span><span class="p">}</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="n">modifications</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span>
        <span class="n">modifiable_attrs</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Can only modify these: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">modifiable_attrs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="n">original_func_node_kwargs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;func&#39;</span><span class="p">:</span> <span class="n">func_node</span><span class="o">.</span><span class="n">func</span><span class="p">,</span>
        <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">func_node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="s1">&#39;bind&#39;</span><span class="p">:</span> <span class="n">func_node</span><span class="o">.</span><span class="n">bind</span><span class="p">,</span>
        <span class="s1">&#39;out&#39;</span><span class="p">:</span> <span class="n">func_node</span><span class="o">.</span><span class="n">out</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">FuncNode</span><span class="p">(</span><span class="o">**</span><span class="nb">dict</span><span class="p">(</span><span class="n">original_func_node_kwargs</span><span class="p">,</span> <span class="o">**</span><span class="n">modifications</span><span class="p">))</span>


<span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">partialx</span>


<span class="c1"># TODO: doctests</span>
<span class="k">def</span> <span class="nf">partialized_funcnodes</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">,</span> <span class="o">**</span><span class="n">keyword_defaults</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="n">func_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">argnames_to_be_bound</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">(</span><span class="n">keyword_defaults</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
            <span class="n">func_node</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">names</span>
        <span class="p">):</span>
            <span class="n">bindings</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">extract_items</span><span class="p">(</span><span class="n">keyword_defaults</span><span class="p">,</span> <span class="n">argnames_to_be_bound</span><span class="p">))</span>
            <span class="c1"># partialize the func and move defaulted params to the end</span>
            <span class="n">partialized_func</span> <span class="o">=</span> <span class="n">partialx</span><span class="p">(</span>
                <span class="n">func_node</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="o">**</span><span class="n">bindings</span><span class="p">,</span> <span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="c1"># get rid of kinds  # TODO: This is a bit extreme -- consider gentler touch</span>
            <span class="n">nice_kinds_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">partialized_func</span><span class="p">)</span><span class="o">.</span><span class="n">ch_kinds_to_position_or_keyword</span><span class="p">()</span>
            <span class="n">nice_kinds_partialized_func</span> <span class="o">=</span> <span class="n">nice_kinds_sig</span><span class="p">(</span><span class="n">partialized_func</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">modified_func_node</span><span class="p">(</span>
                <span class="n">func_node</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">nice_kinds_partialized_func</span>
            <span class="p">)</span>  <span class="c1"># TODO: A better way without partial?</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">func_node</span>


<span class="n">Scope</span> <span class="o">=</span> <span class="nb">dict</span>
<span class="n">VarNames</span> <span class="o">=</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="n">DagOutput</span> <span class="o">=</span> <span class="n">Any</span>


<span class="k">def</span> <span class="nf">_name_attr_or_x</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">change_value_on_cond</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">cond</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span>


<span class="k">def</span> <span class="nf">dflt_debugger_feedback</span><span class="p">(</span><span class="n">func_node</span><span class="p">,</span> <span class="n">scope</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s1"> --------------------------------------------------------------&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{</span><span class="n">func_node</span><span class="si">=}</span><span class="se">\n\t</span><span class="si">{</span><span class="n">scope</span><span class="si">=}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>


<span class="c1"># TODO: caching last scope isn&#39;t really the DAG&#39;s direct concern -- it&#39;s a debugging</span>
<span class="c1">#  concern. Perhaps a more general form would be to define a cache factory defaulting</span>
<span class="c1">#  to a dict, but that could be a &quot;dict&quot; that logs writes (even to an attribute of self)</span>
<div class="viewcode-block" id="DAG"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG">[docs]</a><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">DAG</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &gt;&gt;&gt; from meshed.dag import DAG, Sig</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; def this(a, b=1):</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def that(x, b=1):</span>
<span class="sd">    ...     return x * b</span>
<span class="sd">    &gt;&gt;&gt; def combine(this, that):</span>
<span class="sd">    ...     return (this, that)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; dag = DAG((this, that, combine))</span>
<span class="sd">    &gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">    a,b -&gt; this_ -&gt; this</span>
<span class="sd">    x,b -&gt; that_ -&gt; that</span>
<span class="sd">    this,that -&gt; combine_ -&gt; combine</span>

<span class="sd">    But what does it do?</span>

<span class="sd">    It&#39;s a callable, with a signature:</span>

<span class="sd">    &gt;&gt;&gt; Sig(dag)  # doctest: +SKIP</span>
<span class="sd">    &lt;Sig (a, x, b=1)&gt;</span>

<span class="sd">    And when you call it, it executes the dag from the root values you give it and</span>
<span class="sd">    returns the leaf output values.</span>

<span class="sd">    &gt;&gt;&gt; dag(1, 2, 3)  # (a+b,x*b) == (1+3,2*3) == (4, 6)</span>
<span class="sd">    (4, 6)</span>
<span class="sd">    &gt;&gt;&gt; dag(1, 2)  # (a+b,x*b) == (1+1,2*1) == (2, 2)</span>
<span class="sd">    (2, 2)</span>

<span class="sd">    The above DAG was created straight from the functions, using only the names of the</span>
<span class="sd">    functions and their arguments to define how to hook the network up.</span>

<span class="sd">    But if you didn&#39;t write those functions specifically for that purpose, or you want</span>
<span class="sd">    to use someone else&#39;s functions, we got you covered.</span>

<span class="sd">    You can define the name of the node (the `name` argument), the name of the output</span>
<span class="sd">    (the `out` argument) and a mapping from the function&#39;s arguments names to</span>
<span class="sd">    &quot;network names&quot; (through the `bind` argument).</span>
<span class="sd">    The edges of the DAG are defined by matching `out` TO `bind`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">func_nodes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">cache_last_scope</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">parameter_merge</span><span class="p">:</span> <span class="n">ParameterMerger</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="n">conservative_parameter_merge</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>
    <span class="c1"># can return a prepopulated scope too!</span>
    <span class="n">new_scope</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="nb">dict</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">extract_output_from_scope</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Scope</span><span class="p">,</span> <span class="n">VarNames</span><span class="p">],</span> <span class="n">DagOutput</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="n">extract_values</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_mk_func_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">_func_nodes_to_graph_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">topological_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="c1"># reorder the nodes to fit topological order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_nodes</span> <span class="o">=</span> <span class="n">_separate_func_nodes_and_var_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="c1"># self.sig = Sig(dict(extract_items(sig.parameters, &#39;xz&#39;)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span>  <span class="c1"># make a signature</span>
            <span class="n">sort_params</span><span class="p">(</span>  <span class="c1"># with the sorted params (sorted to satisfy kind/default order)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">src_name_params</span><span class="p">(</span><span class="n">root_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># self.__signature__(self)  # to put the signature on the callable DAG</span>
        <span class="c1"># figure out the roots and leaves</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">roots</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span><span class="o">.</span><span class="n">names</span>
        <span class="p">)</span>  <span class="c1"># roots in the same order as signature</span>
        <span class="n">leafs</span> <span class="o">=</span> <span class="n">leaf_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">)</span>
        <span class="c1"># But we want leafs in topological order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leafs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">last_scope</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="ow">or</span> <span class="s1">&#39;DAG&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">bindings_cleaner</span><span class="p">()</span>

    <span class="c1"># TODO: No control of other DAG args (cache_last_scope etc.).</span>
<div class="viewcode-block" id="DAG.from_funcs"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.from_funcs">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_funcs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">named_funcs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :param funcs:</span>
<span class="sd">        :param named_funcs:</span>
<span class="sd">        :return:</span>

<span class="sd">        &gt;&gt;&gt; dag = DAG.from_funcs(</span>
<span class="sd">        ...     lambda a: a * 2,</span>
<span class="sd">        ...     x=lambda: 10,</span>
<span class="sd">        ...     y=lambda x, _0: x + _0  # _0 refers to first arg (lambda a: a * 2)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">        a -&gt; _0_ -&gt; _0</span>
<span class="sd">         -&gt; x_ -&gt; x</span>
<span class="sd">        x,_0 -&gt; y_ -&gt; y</span>
<span class="sd">        &gt;&gt;&gt; dag(3)</span>
<span class="sd">        16</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">named_funcs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">MultiFunc</span><span class="p">(</span><span class="o">*</span><span class="n">funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">named_funcs</span><span class="p">))</span>
        <span class="n">func_nodes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">FuncNode</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">named_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">bindings_cleaner</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span> <span class="o">=</span> <span class="n">mk_nodes_names_unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span>
        <span class="n">funcnodes_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">]</span>
        <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_node_for</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">out</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">funcnodes_names</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">change_value_on_cond</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">bind</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a dict of {argname: argval} pairs from positional and keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">apply_defaults</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Get a dict of {argname: argval} pairs from positional and keyword arguments</span>
        <span class="c1"># How positionals are resolved is determined by self.__signature__</span>
        <span class="c1"># The result is the initial ``scope`` the func nodes will both read from</span>
        <span class="c1"># to get their arguments, and write their outputs to.</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_kwargs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Go through self.func_nodes in order and call them on scope (performing said</span>
        <span class="c1"># read_input -&gt; call_func -&gt; write_output operations)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_on_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="c1"># From the scope, that may contain all intermediary results,</span>
        <span class="c1"># extract the desired final output and return it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extract_output_from_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">leafs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_preprocess_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Take care of the stuff that needs to be taking care of before looping</span>
<span class="sd">        though the func_nodes and calling them on scope. Namely:</span>

<span class="sd">        - If scope is None, create a new one calling self.new_scope()</span>
<span class="sd">        - If self.cache_last_scope is True, remember the scope in self.last_scope</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scope</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_scope</span><span class="p">()</span>  <span class="c1"># fresh new scope</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_last_scope</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">last_scope</span> <span class="o">=</span> <span class="n">scope</span>  <span class="c1"># just to remember it, for debugging purposes ONLY!</span>
        <span class="k">return</span> <span class="n">scope</span>

    <span class="k">def</span> <span class="nf">_call_func_nodes_on_scope_gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Loop over ``func_nodes`` yielding ``func_node.call_on_scope(scope)``.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">func_node</span><span class="o">.</span><span class="n">call_on_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_call_func_nodes_on_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loop over ``func_nodes`` calling func_node.call_on_scope on scope.</span>
<span class="sd">        (Really, just &quot;consumes&quot; the generator output by _call_func_nodes_on_scope_gen)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_func_nodes_on_scope_gen</span><span class="p">(</span><span class="n">scope</span><span class="p">):</span>
            <span class="k">pass</span>

<div class="viewcode-block" id="DAG.call_on_scope"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.call_on_scope">[docs]</a>    <span class="k">def</span> <span class="nf">call_on_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calls the func_nodes using scope (a dict or MutableMapping) both to</span>
<span class="sd">        source it&#39;s arguments and write it&#39;s results.</span>

<span class="sd">        Note: This method is only meant to be used as a backend to __call__, not as</span>
<span class="sd">        an actual interface method. Additional control/constraints on read and writes</span>
<span class="sd">        can be implemented by providing a custom scope for that. For example, one could</span>
<span class="sd">        log read and/or writes to specific keys, or disallow overwriting to an existing</span>
<span class="sd">        key (useful for pipeline sanity), etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_call_func_nodes_on_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span></div>

<div class="viewcode-block" id="DAG.call_on_scope_iteratively"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.call_on_scope_iteratively">[docs]</a>    <span class="k">def</span> <span class="nf">call_on_scope_iteratively</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calls the ``func_nodes`` using scope (a dict or MutableMapping) both to</span>
<span class="sd">        source it&#39;s arguments and write it&#39;s results.</span>

<span class="sd">        Use this function to control each func_node call step iteratively</span>
<span class="sd">        (through a generator)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_preprocess_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_call_func_nodes_on_scope_gen</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span></div>

    <span class="c1"># def clone(self, *args, **kwargs):</span>
    <span class="c1">#     &quot;&quot;&quot;Use args, kwargs to make an instance, using self attributes for</span>
    <span class="c1">#     unspecified arguments.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a sub-dag from a specification of (var or fun) input and output nodes.</span>

<span class="sd">        ``dag[input_nodes:output_nodes]`` is the sub-dag made of intersection of all</span>
<span class="sd">        descendants of ``input_nodes``</span>
<span class="sd">        (inclusive) and ancestors of ``output_nodes`` (inclusive), where additionally,</span>
<span class="sd">        when a func node is contained, it takes with it the input and output nodes</span>
<span class="sd">        it needs.</span>

<span class="sd">        &gt;&gt;&gt; def f(a): ...</span>
<span class="sd">        &gt;&gt;&gt; def g(f): ...</span>
<span class="sd">        &gt;&gt;&gt; def h(g): ...</span>
<span class="sd">        &gt;&gt;&gt; def i(h): ...</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g, h, i])</span>

<span class="sd">        See what this dag looks like (it&#39;s a simple pipeline):</span>

<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g, h, i])</span>
<span class="sd">        &gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">        a -&gt; f_ -&gt; f</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>
<span class="sd">        h -&gt; i_ -&gt; i</span>

<span class="sd">        Get a subdag from ``g_`` (indicates the function here) to the end of ``dag``</span>

<span class="sd">        &gt;&gt;&gt; subdag = dag[&#39;g_&#39;:]</span>
<span class="sd">        &gt;&gt;&gt; print(subdag.synopsis_string())</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>
<span class="sd">        h -&gt; i_ -&gt; i</span>

<span class="sd">        From the beginning to ``h_``</span>

<span class="sd">        &gt;&gt;&gt; print(dag[:&#39;h_&#39;].synopsis_string())</span>
<span class="sd">        a -&gt; f_ -&gt; f</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>

<span class="sd">        From ``g_`` to ``h_`` (both inclusive)</span>

<span class="sd">        &gt;&gt;&gt; print(dag[&#39;g_&#39;:&#39;h_&#39;].synopsis_string())</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>

<span class="sd">        Above we used function (node names) to specify what we wanted, but we can also</span>
<span class="sd">        use names of input/output var-nodes. Do note the difference though.</span>
<span class="sd">        The nodes you specify to get a sub-dag are INCLUSIVE, but when you</span>
<span class="sd">        specify function nodes, you also get the input and output nodes of these</span>
<span class="sd">        functions.</span>

<span class="sd">        The ``dag[&#39;g_&#39;, &#39;h_&#39;]`` give us a sub-dag starting at ``f`` (the input node),</span>
<span class="sd">        but when we ask ``dag[&#39;g&#39;, &#39;h_&#39;]`` instead, ``g`` being the output node of</span>
<span class="sd">        function node ``g_``, we only get ``g -&gt; h_ -&gt; h``:</span>

<span class="sd">        &gt;&gt;&gt; print(dag[&#39;g&#39;:&#39;h&#39;].synopsis_string())</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>

<span class="sd">        If we wanted to include ``f`` we&#39;d have to specify it:</span>

<span class="sd">        &gt;&gt;&gt; print(dag[&#39;f&#39;:&#39;h&#39;].synopsis_string())</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        g -&gt; h_ -&gt; h</span>

<span class="sd">        Those were for simple pipelines, but let&#39;s now look at a more complex dag.</span>

<span class="sd">        We&#39;ll let the following examples self-comment:</span>

<span class="sd">        &gt;&gt;&gt; def f(u, v): ...</span>
<span class="sd">        &gt;&gt;&gt; def g(f): ...</span>
<span class="sd">        &gt;&gt;&gt; def h(f, w): ...</span>
<span class="sd">        &gt;&gt;&gt; def i(g, h): ...</span>
<span class="sd">        &gt;&gt;&gt; def j(h, x): ...</span>
<span class="sd">        &gt;&gt;&gt; def k(i): ...</span>
<span class="sd">        &gt;&gt;&gt; def l(i, j): ...</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g, h, i, j, k, l])</span>
<span class="sd">        &gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">        u,v -&gt; f_ -&gt; f</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        f,w -&gt; h_ -&gt; h</span>
<span class="sd">        g,h -&gt; i_ -&gt; i</span>
<span class="sd">        h,x -&gt; j_ -&gt; j</span>
<span class="sd">        i -&gt; k_ -&gt; k</span>
<span class="sd">        i,j -&gt; l_ -&gt; l</span>

<span class="sd">        A little util to get consistent prints:</span>

<span class="sd">        &gt;&gt;&gt; def print_sorted_synopsis(dag):</span>
<span class="sd">        ...     t = sorted(dag.synopsis_string().split(&#39;\\n&#39;))</span>
<span class="sd">        ...     print(&#39;\\n&#39;.join(t))</span>

<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[[&#39;u&#39;, &#39;f&#39;]:&#39;h&#39;])</span>
<span class="sd">        f,w -&gt; h_ -&gt; h</span>
<span class="sd">        u,v -&gt; f_ -&gt; f</span>
<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[&#39;u&#39;:&#39;h&#39;])</span>
<span class="sd">        f,w -&gt; h_ -&gt; h</span>
<span class="sd">        u,v -&gt; f_ -&gt; f</span>
<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[[&#39;u&#39;, &#39;f&#39;]:[&#39;h&#39;, &#39;g&#39;]])</span>
<span class="sd">        f -&gt; g_ -&gt; g</span>
<span class="sd">        f,w -&gt; h_ -&gt; h</span>
<span class="sd">        u,v -&gt; f_ -&gt; f</span>
<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[[&#39;x&#39;, &#39;g&#39;]:&#39;k&#39;])</span>
<span class="sd">        g,h -&gt; i_ -&gt; i</span>
<span class="sd">        i -&gt; k_ -&gt; k</span>
<span class="sd">        &gt;&gt;&gt; print_sorted_synopsis(dag[[&#39;x&#39;, &#39;g&#39;]:[&#39;l&#39;, &#39;k&#39;]])</span>
<span class="sd">        g,h -&gt; i_ -&gt; i</span>
<span class="sd">        h,x -&gt; j_ -&gt; j</span>
<span class="sd">        i -&gt; k_ -&gt; k</span>
<span class="sd">        i,j -&gt; l_ -&gt; l</span>

<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span>
            <span class="n">func_nodes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ordered_subgraph_nodes</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
            <span class="n">cache_last_scope</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_last_scope</span><span class="p">,</span>
            <span class="n">parameter_merge</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parameter_merge</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ordered_subgraph_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">subgraph_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subgraph_nodes</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># TODO: When clone ready, use to do `constructor = type(self)` instead of DAG</span>
        <span class="c1"># constructor = type(self)  # instead of DAG</span>
        <span class="n">initial_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span>
        <span class="n">ordered_subgraph_nodes</span> <span class="o">=</span> <span class="n">order_subset_from_list</span><span class="p">(</span><span class="n">initial_nodes</span><span class="p">,</span> <span class="n">subgraph_nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ordered_subgraph_nodes</span>

    <span class="k">def</span> <span class="nf">_subgraph_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="n">ins</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">_descendants</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="n">FuncNode</span><span class="o">.</span><span class="n">has_as_instance</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">ins</span><span class="p">)</span> <span class="o">|</span> <span class="n">descendants</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">ins</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">_ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="n">FuncNode</span><span class="o">.</span><span class="n">has_as_instance</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">|</span> <span class="n">ancestors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">,</span> <span class="n">outs</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">subgraph_nodes</span> <span class="o">=</span> <span class="n">_descendants</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">_ancestors</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">subgraph_nodes</span>

    <span class="c1"># TODO: Think about adding a ``_roll_in_orphaned_nodes=False`` argument:</span>
    <span class="c1">#   See https://github.com/i2mint/meshed/issues/14 for more information.</span>
<div class="viewcode-block" id="DAG.partial"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.partial">[docs]</a>    <span class="k">def</span> <span class="nf">partial</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">positional_dflts</span><span class="p">,</span>
        <span class="n">_remove_bound_arguments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">_consider_defaulted_arguments_as_bound</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">keyword_dflts</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get a curried version of the DAG.</span>

<span class="sd">        Like ``functools.partial``, but returns a DAG (not just a callable) and allows</span>
<span class="sd">        you to remove bound arguments as well as roll in orphaned_nodes.</span>

<span class="sd">        :param positional_dflts: Bind arguments positionally</span>
<span class="sd">        :param keyword_dflts: Bind arguments through their names</span>
<span class="sd">        :param _remove_bound_arguments: False -- set to True if you don&#39;t want bound</span>
<span class="sd">            arguments to show up in the signature.</span>
<span class="sd">        :param _consider_defaulted_arguments_as_bound: False -- set to True if</span>
<span class="sd">            you want to also consider arguments that already had defaults as bound</span>
<span class="sd">            (and be removed).</span>
<span class="sd">        :return:</span>

<span class="sd">        &gt;&gt;&gt; def f(a, b):</span>
<span class="sd">        ...     return a + b</span>
<span class="sd">        &gt;&gt;&gt; def g(c, d=4):</span>
<span class="sd">        ...     return c * d</span>
<span class="sd">        &gt;&gt;&gt; def h(f, g):</span>
<span class="sd">        ...     return g - f</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g, h])</span>
<span class="sd">        &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">        &gt;&gt;&gt; str(signature(dag))</span>
<span class="sd">        &#39;(a, b, c, d=4)&#39;</span>
<span class="sd">        &gt;&gt;&gt; dag(1, 2, 3, 4)  # == (3 * 4) - (1 + 2) == 12 - 3 == 9</span>
<span class="sd">        9</span>
<span class="sd">        &gt;&gt;&gt; dag(c=3, a=1, b=2, d=4)  # same as above</span>
<span class="sd">        9</span>

<span class="sd">        &gt;&gt;&gt; new_dag = dag.partial(c=3)</span>
<span class="sd">        &gt;&gt;&gt; isinstance(new_dag, DAG)  # it&#39;s a dag (not just a partialized callable!)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; str(signature(new_dag))</span>
<span class="sd">        &#39;(a, b, c=3, d=4)&#39;</span>
<span class="sd">        &gt;&gt;&gt; new_dag(1, 2)  # same as dag(c=3, a=1, b=2, d=4), so:</span>
<span class="sd">        9</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">keyword_dflts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span><span class="o">.</span><span class="n">kwargs_from_args_and_kwargs</span><span class="p">(</span>
            <span class="n">args</span><span class="o">=</span><span class="n">positional_dflts</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">keyword_dflts</span><span class="p">,</span>
            <span class="n">apply_defaults</span><span class="o">=</span><span class="n">_consider_defaulted_arguments_as_bound</span><span class="p">,</span>
            <span class="c1"># positional_dflts and keyword_dflts usually don&#39;t cover all arguments, so:</span>
            <span class="n">allow_partial</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="c1"># we prefer to let the user know if they&#39;re trying to bind arguments</span>
            <span class="c1"># that don&#39;t exist, so:</span>
            <span class="n">allow_excess</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="c1"># we don&#39;t really care about kind, so:</span>
            <span class="n">ignore_kind</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># TODO: mk_instance: What about other init args (cache_last_scope, ...)?</span>
        <span class="n">mk_instance</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">func_nodes</span> <span class="o">=</span> <span class="n">partialized_funcnodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">keyword_dflts</span><span class="p">)</span>
        <span class="n">new_dag</span> <span class="o">=</span> <span class="n">mk_instance</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_remove_bound_arguments</span><span class="p">:</span>
            <span class="n">new_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">new_dag</span><span class="p">)</span><span class="o">.</span><span class="n">remove_names</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">keyword_dflts</span><span class="p">))</span>
            <span class="n">new_sig</span><span class="p">(</span><span class="n">new_dag</span><span class="p">)</span>  <span class="c1"># Change the signature of new_dag with bound args removed</span>
        <span class="k">return</span> <span class="n">new_dag</span></div>

    <span class="k">def</span> <span class="nf">process_item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;must be a slice, was: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s1">&#39;</span>

        <span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">stop</span>

        <span class="n">empty_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">ensure_variable_list</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_nodes</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">)):</span>
                <span class="c1"># TODO: See if we can use _func_node_for instead</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_matching</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
                <span class="c1"># TODO: See if we can use _func_node_for instead</span>
                <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_matching</span><span class="p">,</span> <span class="n">obj</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ValidationError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unrecognized variables specification: </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># assert len(item) == 2, f&quot;Only items of size 1 or 2 are supported&quot;</span>
        <span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">ensure_variable_list</span><span class="p">,</span> <span class="p">[</span><span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">input_names</span><span class="p">,</span> <span class="n">outs</span>

    <span class="k">def</span> <span class="nf">get_node_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">var_nodes</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">idx</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_node_for</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">Callable</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_node_for</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">raise</span> <span class="n">NotFound</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No matching node for idx: </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># TODO: Reflect: Should we include functions as keys here? Makes existence of the</span>
    <span class="c1">#  item depend on unicity of the function in the DAG, therefore dynamic,</span>
    <span class="c1">#  so instable?</span>
    <span class="c1">#  Should this node indexing be controllable by user?</span>
    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">_func_node_for</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A dictionary mapping identifiers and functions to their FuncNode instances</span>
<span class="sd">        in the DAG. The keys of this dictionary will include:</span>

<span class="sd">        - identifiers (names) of the ``FuncNode`` instances</span>
<span class="sd">        - ``out`` of ``FuncNode`` instances</span>
<span class="sd">        - The ``.func`` of the ``FuncNode`` instances if it&#39;s unique.</span>

<span class="sd">        &gt;&gt;&gt; def foo(x): return x + 1</span>
<span class="sd">        &gt;&gt;&gt; def bar(x): return x * 2</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([</span>
<span class="sd">        ...     FuncNode(foo, out=&#39;foo_output&#39;),</span>
<span class="sd">        ...     FuncNode(bar, name=&#39;B&#39;, out=&#39;b&#39;, bind={&#39;x&#39;: &#39;foo_output&#39;}),</span>
<span class="sd">        ... ])</span>

<span class="sd">        A ``FuncNode`` instance is indexed by both its identifier (``.name``) as well as</span>
<span class="sd">        the identifier of it&#39;s output (``.out``):</span>

<span class="sd">        &gt;&gt;&gt; dag._func_node_for[&#39;foo_output&#39;]</span>
<span class="sd">        FuncNode(x -&gt; foo -&gt; foo_output)</span>
<span class="sd">        &gt;&gt;&gt; dag._func_node_for[&#39;foo&#39;]</span>
<span class="sd">        FuncNode(x -&gt; foo -&gt; foo_output)</span>
<span class="sd">        &gt;&gt;&gt; dag._func_node_for[&#39;b&#39;]</span>
<span class="sd">        FuncNode(x=foo_output -&gt; B -&gt; b)</span>
<span class="sd">        &gt;&gt;&gt; dag._func_node_for[&#39;B&#39;]</span>
<span class="sd">        FuncNode(x=foo_output -&gt; B -&gt; b)</span>

<span class="sd">        If the function is hashable (most are) and unique within the ``DAG``, you</span>
<span class="sd">        can also find the ``FuncNode`` via the ``.func`` it&#39;s wrapping:</span>

<span class="sd">        &gt;&gt;&gt; dag._func_node_for[foo]</span>
<span class="sd">        FuncNode(x -&gt; foo -&gt; foo_output)</span>
<span class="sd">        &gt;&gt;&gt; dag._func_node_for[bar]</span>
<span class="sd">        FuncNode(x=foo_output -&gt; B -&gt; b)</span>

<span class="sd">        A word of warning though: The function index is provided as a convenience, but</span>
<span class="sd">        using identifiers is preferable since referencing via the function object</span>
<span class="sd">        depends on the other functions of the DAG, so could change if we add nodes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="n">func_node</span><span class="o">.</span><span class="n">out</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_node</span>
            <span class="n">d</span><span class="p">[</span><span class="n">func_node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_node</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">func_node</span><span class="o">.</span><span class="n">func</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                    <span class="c1"># if .func not in d already, remember the link</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">func_node</span><span class="o">.</span><span class="n">func</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_node</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if .func was already in there, mark it for removal</span>
                    <span class="c1"># (but leaving the key present so that we know about the duplication)</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">func_node</span><span class="o">.</span><span class="n">func</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># ignore (and don&#39;t include func) if not hashable</span>
                <span class="k">pass</span>

        <span class="c1"># remove the items marked for removal and return</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">find_func_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">FuncNode</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">node</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func_node_for</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Yields the self.func_nodes</span>
<span class="sd">        Note: The raison d&#39;etre of this ``__iter__`` is simply because if no custom one</span>
<span class="sd">        is provided, python defaults to yielding ``__getitem__[i]`` for integers,</span>
<span class="sd">        which leads to an error being raised.</span>

<span class="sd">        At least here we yield something sensible.</span>

<span class="sd">        A consequence of the `__iter__` being the iterable of func_nodes is that we</span>
<span class="sd">        can extend dags using the star operator. Consider the following dag;</span>

<span class="sd">        &gt;&gt;&gt; def f(a): return a * 2</span>
<span class="sd">        &gt;&gt;&gt; def g(f, b): return f + b</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([f, g])</span>
<span class="sd">        &gt;&gt;&gt; assert dag(2, 3) == 7</span>

<span class="sd">        Say you wanted to now take a, b, and the output og g, and feed it to another</span>
<span class="sd">        function...</span>

<span class="sd">        &gt;&gt;&gt; def h(a, b, g): return f&quot;{a=} {b=} {g=}&quot;</span>
<span class="sd">        &gt;&gt;&gt; extended_dag = DAG([*dag, h])</span>
<span class="sd">        &gt;&gt;&gt; extended_dag(a=2, b=3)</span>
<span class="sd">        &#39;a=2 b=3 g=7&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span>

    <span class="c1"># Note: signature_comparator is position only to not conflict with any of the</span>
    <span class="c1">#  func_mapping keys.</span>
<div class="viewcode-block" id="DAG.ch_funcs"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.ch_funcs">[docs]</a>    <span class="k">def</span> <span class="nf">ch_funcs</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="c1"># func_comparator: CallableComparator = compare_signatures,</span>
        <span class="n">ch_func_node_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
            <span class="p">[</span><span class="n">FuncNode</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">CallableComparator</span><span class="p">],</span> <span class="n">FuncNode</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">ch_func_node_func</span><span class="p">,</span>
        <span class="o">/</span><span class="p">,</span>
        <span class="o">**</span><span class="n">func_mapping</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DAG&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change some of the functions in the DAG.</span>
<span class="sd">        More preciseluy get a copy of the DAG where in some of the functions have</span>
<span class="sd">        changed.</span>

<span class="sd">        :param name_and_func: ``name=func`` pairs where ``name`` is the</span>
<span class="sd">            ``FuncNode.name`` of the func nodes you want to change and func is the</span>
<span class="sd">            function you want to change it by.</span>
<span class="sd">        :return: A new DAG with the different functions.</span>

<span class="sd">        &gt;&gt;&gt; from meshed import FuncNode, DAG</span>
<span class="sd">        &gt;&gt;&gt; from i2 import Sig</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def f(a, b):</span>
<span class="sd">        ...     return a + b</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def g(a_plus_b, x):</span>
<span class="sd">        ...     return a_plus_b * x</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; f_node = FuncNode(func=f, out=&#39;a_plus_b&#39;)</span>
<span class="sd">        &gt;&gt;&gt; g_node = FuncNode(func=g, bind={&#39;x&#39;: &#39;b&#39;})</span>
<span class="sd">        &gt;&gt;&gt; d = DAG((f_node, g_node))</span>
<span class="sd">        &gt;&gt;&gt; print(d.synopsis_string())</span>
<span class="sd">        a,b -&gt; f -&gt; a_plus_b</span>
<span class="sd">        b,a_plus_b -&gt; g_ -&gt; g</span>
<span class="sd">        &gt;&gt;&gt; d(2, 3)  # (2 + 3) * 3 == 5 * 3</span>
<span class="sd">        15</span>
<span class="sd">        &gt;&gt;&gt; dd = d.ch_funcs(f=lambda a, b: a - b)</span>
<span class="sd">        &gt;&gt;&gt; dd(2, 3)  # (2 - 3) * 3 == -1 * 3</span>
<span class="sd">        -3</span>

<span class="sd">        You can reference the ``FuncNode`` you want to change through its ``.name`` or</span>
<span class="sd">        ``.out`` attribute (both are unique to this ``FuncNode`` in a ``DAG``).</span>

<span class="sd">        &gt;&gt;&gt; from i2 import Sig</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; dag = DAG([</span>
<span class="sd">        ...     FuncNode(lambda a, b: a + b, name=&#39;f&#39;),</span>
<span class="sd">        ...     FuncNode(lambda y=1, z=2: y * z, name=&#39;g&#39;, bind={&#39;z&#39;: &#39;f&#39;})</span>
<span class="sd">        ... ])</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; Sig(dag)</span>
<span class="sd">        &lt;Sig (a, b, f=2, y=1)&gt;</span>
<span class="sd">        &gt;&gt;&gt;</span>

<span class="sd">        If you replace by a different function with exactly the same signature,</span>
<span class="sd">        all goes well:</span>

<span class="sd">        &gt;&gt;&gt; dag.ch_funcs(g=lambda y=1, z=2: y / z)</span>
<span class="sd">        DAG(func_nodes=[FuncNode(a,b -&gt; f -&gt; _f), FuncNode(z=_f,y -&gt; g -&gt; _g)], name=None)</span>

<span class="sd">        But if you change the signature, even slightly you get an error.</span>

<span class="sd">        Here we didn&#39;t include the defaults:</span>

<span class="sd">        &gt;&gt;&gt; dag.ch_funcs(g=lambda y, z: y / z)  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        ValueError: You can only change the func of a FuncNode with a another func if the signatures match.</span>
<span class="sd">          ...</span>

<span class="sd">        Here we include defaults, but ``z``&#39;s is different:</span>

<span class="sd">        &gt;&gt;&gt; dag.ch_funcs(g=lambda y=1, z=200: y / z)  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        ValueError: You can only change the func of a FuncNode with a another func if the signatures match.</span>
<span class="sd">          ...</span>

<span class="sd">        Here the defaults are exactly the same, but the order of parameters is</span>
<span class="sd">        different:</span>

<span class="sd">        &gt;&gt;&gt; dag.ch_funcs(g=lambda z=2, y=1: y / z)  # doctest: +NORMALIZE_WHITESPACE +ELLIPSIS</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          ...</span>
<span class="sd">        ValueError: You can only change the func of a FuncNode with a another func if the signatures match.</span>
<span class="sd">          ...</span>

<span class="sd">        This validation of the functions controlled by the ``func_comparator``</span>
<span class="sd">        argument. By default this is the ``compare_signatures`` which compares the</span>
<span class="sd">        signatures of the functions in the strictest way possible.</span>
<span class="sd">        The is the right choice for a default since it will get you out of trouble</span>
<span class="sd">        down the line.</span>

<span class="sd">        But it&#39;s also annoying in many situations, and in those cases you should</span>
<span class="sd">        specify the ``func_comparator`` that makes sense for your context.</span>

<span class="sd">        Since most of the time, you&#39;ll want to compare functions solely based on</span>
<span class="sd">        their signature, we provide a ``compare_signatures`` allows you to control the</span>
<span class="sd">        signature comparison through a ``signature_comparator`` argument.</span>

<span class="sd">        &gt;&gt;&gt; from meshed import compare_signatures</span>
<span class="sd">        &gt;&gt;&gt; from functools import partial</span>
<span class="sd">        &gt;&gt;&gt; on_names = lambda sig1, sig2: list(sig1.parameters) == list(sig2.parameters)</span>
<span class="sd">        &gt;&gt;&gt; same_names = partial(compare_signatures, signature_comparator=on_names)</span>
<span class="sd">        &gt;&gt;&gt; ch_fnode = partial(ch_func_node_func, func_comparator=same_names)</span>
<span class="sd">        &gt;&gt;&gt; d = dag.ch_funcs(ch_fnode, g=lambda y, z: y / z);</span>
<span class="sd">        &gt;&gt;&gt; Sig(d)</span>
<span class="sd">        &lt;Sig (a, b, y)&gt;</span>
<span class="sd">        &gt;&gt;&gt; d(2, 3, 4)</span>
<span class="sd">        0.8</span>

<span class="sd">        And this one works too:</span>

<span class="sd">        &gt;&gt;&gt; d = dag.ch_funcs(ch_fnode, g=lambda y=1, z=200: y / z);</span>

<span class="sd">        But our ``same_names`` function compared names including their order.</span>
<span class="sd">        If we want a function with the signature ``(z=2, y=1)`` to be able to be</span>
<span class="sd">        &quot;injected&quot; we&#39;ll need a different comparator:</span>

<span class="sd">        &gt;&gt;&gt; _names = lambda sig1, sig2: set(sig1.parameters) == set(sig2.parameters)</span>
<span class="sd">        &gt;&gt;&gt; same_set_of_names = partial(</span>
<span class="sd">        ...     compare_signatures,</span>
<span class="sd">        ...     signature_comparator=(</span>
<span class="sd">        ...         lambda sig1, sig2: set(sig1.parameters) == set(sig2.parameters)</span>
<span class="sd">        ...     )</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; ch_fnode2 = partial(ch_func_node_func, func_comparator=same_set_of_names)</span>
<span class="sd">        &gt;&gt;&gt; d = dag.ch_funcs(ch_fnode2, g=lambda z=2, y=1: y / z);</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ch_funcs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">func_mapping</span><span class="o">=</span><span class="n">func_mapping</span><span class="p">,</span> <span class="n">ch_func_node_func</span><span class="o">=</span><span class="n">ch_func_node_func</span>
        <span class="p">)</span></div>

        <span class="c1"># _validate_func_mapping(func_mapping, self)</span>
        <span class="c1">#</span>
        <span class="c1"># # def validate(func_mapping, func_nodes):</span>
        <span class="c1">#</span>
        <span class="c1"># # def ch_func(dag, key, func):</span>
        <span class="c1"># #     return DAG(</span>
        <span class="c1"># #         replace_item_in_iterable(</span>
        <span class="c1"># #             dag.func_nodes,</span>
        <span class="c1"># #             condition=lambda fn: dag._func_node_for.get(key, None) is not None,</span>
        <span class="c1"># #             replacement=lambda fn: ch_func_node_func(fn, func=func),</span>
        <span class="c1"># #         )</span>
        <span class="c1"># #     )</span>
        <span class="c1">#</span>
        <span class="c1"># # TODO: Change to use self._func_node_for</span>
        <span class="c1"># def ch_func(dag, key, func):</span>
        <span class="c1">#     return DAG(</span>
        <span class="c1">#         replace_item_in_iterable(</span>
        <span class="c1">#             dag.func_nodes,</span>
        <span class="c1">#             condition=lambda fn: fn.name == key or fn.out == key,</span>
        <span class="c1">#             replacement=lambda fn: _ch_func_node_func(fn, func=func),</span>
        <span class="c1">#         )</span>
        <span class="c1">#     )</span>
        <span class="c1">#</span>
        <span class="c1"># new_dag = self</span>
        <span class="c1"># for key, func in func_mapping.items():</span>
        <span class="c1">#     new_dag = ch_func(new_dag, key, func)</span>
        <span class="c1"># return new_dag</span>

    <span class="c1"># ------------ utils --------------------------------------------------------------</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">params_for_src</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The ``{src_name: list_of_params_using_that_src,...}`` dictionary.</span>
<span class="sd">        That is, a ``dict`` having lists of all ``Parameter`` objs that are used by a</span>
<span class="sd">        ``node.bind`` source (value of ``node.bind``) for each such source in the graph</span>

<span class="sd">        For each ``func_node``, ``func_node.bind`` gives us the</span>
<span class="sd">        ``{param: varnode_src_name}`` specification that tells us where (key of scope)</span>
<span class="sd">        to source the arguments of the ``func_node.func`` for each ``param`` of that</span>
<span class="sd">        function.</span>

<span class="sd">        What ``params_for_src`` is, is the corresponding inverse map.</span>
<span class="sd">        The ``{varnode_src_name: list_of_params}`` gathered by scanning each</span>
<span class="sd">        ``func_node`` of the DAG.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">src_name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">bind</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">d</span><span class="p">[</span><span class="n">src_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">arg_name</span><span class="p">])</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<div class="viewcode-block" id="DAG.src_name_params"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.src_name_params">[docs]</a>    <span class="k">def</span> <span class="nf">src_name_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate Parameter instances that are needed to compute ``src_names``&quot;&quot;&quot;</span>
        <span class="c1"># see params_for_src property to see what d is</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params_for_src</span>
        <span class="k">if</span> <span class="n">src_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># if no src_names given, use the names of all var_nodes</span>
            <span class="n">src_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># For every src_name of the DAG that is in ``src_names``...</span>
        <span class="k">for</span> <span class="n">src_name</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">src_names</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">src_name</span><span class="p">]</span>  <span class="c1"># consider all the params that use it</span>
            <span class="c1"># make version of these params that have the same name (namely src_name)</span>
            <span class="n">params_with_name_changed_to_src_name</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">p</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">src_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">params</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params_with_name_changed_to_src_name</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if there&#39;s only one param, yield it (there can be no conflict)</span>
                <span class="k">yield</span> <span class="n">params_with_name_changed_to_src_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># if there&#39;s more than one param, merge them</span>
                <span class="c1"># How to resolve conflicts (different defaults, annotations or kinds)</span>
                <span class="c1"># is determined by what ``parameter_merge`` specified, which is,</span>
                <span class="c1"># by default, strict (everything needs to be the same, or</span>
                <span class="c1"># ``parameter_merge`` with raise an error.)</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameter_merge</span><span class="p">(</span><span class="o">*</span><span class="n">params_with_name_changed_to_src_name</span><span class="p">)</span></div>

    <span class="c1"># TODO: Find more representative (and possibly shorter) doctest:</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">graph_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The dict representing the ``{from_node: to_nodes}`` graph.</span>
<span class="sd">        Like ``.graph``, but with node ids (names).</span>

<span class="sd">        &gt;&gt;&gt; from meshed.dag import DAG</span>
<span class="sd">        &gt;&gt;&gt; def add(a, b=1): return a + b</span>
<span class="sd">        &gt;&gt;&gt; def mult(x, y=3): return x * y</span>
<span class="sd">        &gt;&gt;&gt; def exp(mult, a): return mult ** a</span>
<span class="sd">        &gt;&gt;&gt; assert DAG([add, mult, exp]).graph_ids == {</span>
<span class="sd">        ...     &#39;a&#39;: [&#39;add_&#39;, &#39;exp_&#39;],</span>
<span class="sd">        ...     &#39;b&#39;: [&#39;add_&#39;],</span>
<span class="sd">        ...     &#39;add_&#39;: [&#39;add&#39;],</span>
<span class="sd">        ...     &#39;x&#39;: [&#39;mult_&#39;],</span>
<span class="sd">        ...     &#39;y&#39;: [&#39;mult_&#39;],</span>
<span class="sd">        ...     &#39;mult_&#39;: [&#39;mult&#39;],</span>
<span class="sd">        ...     &#39;mult&#39;: [&#39;exp_&#39;],</span>
<span class="sd">        ...     &#39;exp_&#39;: [&#39;exp&#39;]</span>
<span class="sd">        ... }</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">_name_attr_or_x</span><span class="p">(</span><span class="n">k</span><span class="p">):</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_name_attr_or_x</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_prepare_other_for_addition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DAG</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Note: This is so that we can use sum(dags) to get a union of dags without</span>
            <span class="c1"># having to specify the initial DAG() value of sum (which is 0 by default).</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">DAG</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">other</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A union of DAGs. See ``__add__`` for more details.</span>

<span class="sd">        &gt;&gt;&gt; dag = sum([DAG(list), DAG(tuple)])</span>
<span class="sd">        &gt;&gt;&gt; print(dag.synopsis_string(bind_info=&#39;hybrid&#39;))</span>
<span class="sd">        iterable -&gt; list_ -&gt; list</span>
<span class="sd">        iterable -&gt; tuple_ -&gt; tuple</span>
<span class="sd">        &gt;&gt;&gt; dag([1,2,3])</span>
<span class="sd">        ([1, 2, 3], (1, 2, 3))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We could have just returned self + other to be commutative, but perhaps</span>
        <span class="c1"># we would like to control some orders of things via the order of addition</span>
        <span class="c1"># (thinkg list addition versus set addition for example), so instead we write</span>
        <span class="c1"># the explicit code:</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_prepare_other_for_addition</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A union of DAGs.</span>

<span class="sd">        :param other: Another DAG or a valid object to make one with ``DAG(other)``.</span>

<span class="sd">        &gt;&gt;&gt; dag = DAG(list) + DAG(tuple)</span>
<span class="sd">        &gt;&gt;&gt; print(dag.synopsis_string(bind_info=&#39;hybrid&#39;))</span>
<span class="sd">        iterable -&gt; list_ -&gt; list</span>
<span class="sd">        iterable -&gt; tuple_ -&gt; tuple</span>
<span class="sd">        &gt;&gt;&gt; dag([1,2,3])</span>
<span class="sd">        ([1, 2, 3], (1, 2, 3))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_other_for_addition</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">renamer</span><span class="o">=</span><span class="n">numbered_suffix_renamer</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span><span class="n">ch_names</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="n">renamer</span><span class="o">=</span><span class="n">renamer</span><span class="p">))</span>

<div class="viewcode-block" id="DAG.add_edge"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.add_edge">[docs]</a>    <span class="k">def</span> <span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">,</span> <span class="n">to_param</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an e</span>

<span class="sd">        :param from_node:</span>
<span class="sd">        :param to_node:</span>
<span class="sd">        :param to_param:</span>
<span class="sd">        :return: A new DAG with the edge added</span>

<span class="sd">        &gt;&gt;&gt; def f(a, b): return a + b</span>
<span class="sd">        &gt;&gt;&gt; def g(c, d=1): return c * d</span>
<span class="sd">        &gt;&gt;&gt; def h(x, y=1): return x ** y</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; three_funcs = DAG([f, g, h])</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     three_funcs(x=1, c=2, a=3, b=4)</span>
<span class="sd">        ...     == (7, 2, 1)</span>
<span class="sd">        ...     == (f(a=3, b=4), g(c=2), h(x=1))</span>
<span class="sd">        ...     == (3 + 4, 2*1, 1** 1)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; print(three_funcs.synopsis_string())</span>
<span class="sd">        a,b -&gt; f_ -&gt; f</span>
<span class="sd">        c,d -&gt; g_ -&gt; g</span>
<span class="sd">        x,y -&gt; h_ -&gt; h</span>
<span class="sd">        &gt;&gt;&gt; hg = three_funcs.add_edge(&#39;h&#39;, &#39;g&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     hg(a=3, b=4, x=1)</span>
<span class="sd">        ...     == (7, 1)</span>
<span class="sd">        ...     == (f(a=3, b=4), g(c=h(x=1)))</span>
<span class="sd">        ...     == (3 + 4, 1 * (1 ** 1))</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; print(hg.synopsis_string())</span>
<span class="sd">        a,b -&gt; f_ -&gt; f</span>
<span class="sd">        x,y -&gt; h_ -&gt; h</span>
<span class="sd">        h,d -&gt; g_ -&gt; g</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; fhg = three_funcs.add_edge(&#39;h&#39;, &#39;g&#39;).add_edge(&#39;f&#39;, &#39;h&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     fhg(a=3, b=4)</span>
<span class="sd">        ...     == 7</span>
<span class="sd">        ...     == g(h(f(3, 4)))</span>
<span class="sd">        ...     == ((3 + 4) * 1) ** 1</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; print(fhg.synopsis_string())</span>
<span class="sd">        a,b -&gt; f_ -&gt; f</span>
<span class="sd">        f,y -&gt; h_ -&gt; h</span>
<span class="sd">        h,d -&gt; g_ -&gt; g</span>

<span class="sd">        The from and to nodes can be expressed by the ``FuncNode`` ``name`` (identifier)</span>
<span class="sd">        or ``out``, or even the function itself if it&#39;s used only once in the ``DAG``.</span>

<span class="sd">        &gt;&gt;&gt; fhg = three_funcs.add_edge(h, &#39;g&#39;).add_edge(&#39;f_&#39;, &#39;h&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert fhg(a=3, b=4) == 7</span>

<span class="sd">        By default, the edge will be added from ``from_node.out`` to the first</span>
<span class="sd">        parameter of the function of ``to_node``.</span>
<span class="sd">        But if you want otherwise, you can specify the parameter the edge should be</span>
<span class="sd">        connected to.</span>
<span class="sd">        For example, see below how we connect the outputs of ``g`` and ``h`` to the</span>
<span class="sd">        parameters ``a`` and ``b`` of ``f`` respectively:</span>

<span class="sd">        &gt;&gt;&gt; f_of_g_and_h = (</span>
<span class="sd">        ...     DAG([f, g, h])</span>
<span class="sd">        ...     .add_edge(g, f, to_param=&#39;a&#39;)</span>
<span class="sd">        ...     .add_edge(h, f, &#39;b&#39;)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; assert (</span>
<span class="sd">        ...     f_of_g_and_h(x=2, c=3, y=2, d=2)</span>
<span class="sd">        ...     == 10</span>
<span class="sd">        ...     == f(g(c=3, d=2), h(x=2, y=2))</span>
<span class="sd">        ...     == 3 * 2 + 2 ** 2</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(f_of_g_and_h.synopsis_string())</span>
<span class="sd">        c,d -&gt; g_ -&gt; g</span>
<span class="sd">        x,y -&gt; h_ -&gt; h</span>
<span class="sd">        g,h -&gt; f_ -&gt; f</span>

<span class="sd">        See Also ``DAG.add_edges`` to add multiple edges at once</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># resolve from_node and to_node into FuncNodes</span>
        <span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_func_node</span><span class="p">,</span> <span class="p">(</span><span class="n">from_node</span><span class="p">,</span> <span class="n">to_node</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">to_node</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">to_node</span><span class="p">):</span>
            <span class="n">to_node</span> <span class="o">=</span> <span class="n">FuncNode</span><span class="p">(</span>
                <span class="n">to_node</span>
            <span class="p">)</span>  <span class="c1"># TODO: Automatically avoid clashing with dag identifiers (?)</span>

        <span class="c1"># if to_param is None, take the first parameter of to_node as the one</span>
        <span class="k">if</span> <span class="n">to_param</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">to_node</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidFunctionParameters</span><span class="p">(</span>
                    <span class="s2">&quot;You can&#39;t add an edge TO a FuncNode whose function has no &quot;</span>
                    <span class="s1">&#39;parameters. &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;You attempted to add an edge between </span><span class="si">{</span><span class="n">from_node</span><span class="si">=}</span><span class="s1"> and </span><span class="si">{</span><span class="n">to_node</span><span class="si">=}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># first param of .func (i.e. first key of .bind)</span>
                <span class="n">to_param</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">to_node</span><span class="o">.</span><span class="n">bind</span><span class="p">))</span>

        <span class="n">existing_bind</span> <span class="o">=</span> <span class="n">to_node</span><span class="o">.</span><span class="n">bind</span><span class="p">[</span><span class="n">to_param</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">existing_bind</span> <span class="o">==</span> <span class="n">fn</span><span class="o">.</span><span class="n">out</span> <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">to_node</span><span class="si">}</span><span class="s2"> node is already sourcing &#39;</span><span class="si">{</span><span class="n">to_param</span><span class="si">}</span><span class="s2">&#39; from &#39;&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">existing_bind</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
                <span class="s1">&#39;Delete that edge to be able before you add a new one&#39;</span>
            <span class="p">)</span>

        <span class="n">new_to_node_dict</span> <span class="o">=</span> <span class="n">to_node</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="n">new_bind</span> <span class="o">=</span> <span class="n">new_to_node_dict</span><span class="p">[</span><span class="s1">&#39;bind&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_bind</span><span class="p">[</span><span class="n">to_param</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_node</span><span class="o">.</span><span class="n">out</span>  <span class="c1"># this is the actual edge creation</span>
        <span class="n">new_to_node</span> <span class="o">=</span> <span class="n">FuncNode</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">new_to_node_dict</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="n">new_bind</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span>
            <span class="n">replace_item_in_iterable</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span>
                <span class="n">condition</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">to_node</span><span class="p">,</span>
                <span class="n">replacement</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">new_to_node</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>

    <span class="c1"># TODO: There are optimization and pre-validation opportunities here!</span>
<div class="viewcode-block" id="DAG.add_edges"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.add_edges">[docs]</a>    <span class="k">def</span> <span class="nf">add_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds multiple edges by applying ``DAG.add_edge`` multiple times.</span>

<span class="sd">        :param edges: An iterable of ``(from_node, to_node)`` pairs or</span>
<span class="sd">            ``(from_node, to_node, param)`` triples.</span>
<span class="sd">        :return: A new dag with the said edges added.</span>

<span class="sd">        &gt;&gt;&gt; def f(a, b): return a + b</span>
<span class="sd">        &gt;&gt;&gt; def g(c, d=1): return c * d</span>
<span class="sd">        &gt;&gt;&gt; def h(x, y=1): return x ** y</span>
<span class="sd">        &gt;&gt;&gt; fhg = DAG([f, g, h]).add_edges([(h, &#39;g&#39;), (&#39;f_&#39;, &#39;h&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; assert fhg(a=3, b=4) == 7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">dag</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dag</span></div>

<div class="viewcode-block" id="DAG.debugger"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.debugger">[docs]</a>    <span class="k">def</span> <span class="nf">debugger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feedback</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="n">dflt_debugger_feedback</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility to debug DAGs by computing each step sequentially, with feedback.</span>

<span class="sd">        :param feedback: A callable that defines what feedback is given, usually used to</span>
<span class="sd">            print/log some information and output some information for every step.</span>
<span class="sd">            Must be a function with signature ``(func_node, scope, output, step)`` or</span>
<span class="sd">            a subset thereof.</span>
<span class="sd">        :return:</span>

<span class="sd">        &gt;&gt;&gt; from inspect import signature</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def f(a, b):</span>
<span class="sd">        ...     return a + b</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; def g(c, d=4):</span>
<span class="sd">        ...     return c * d</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; def h(f, g):</span>
<span class="sd">        ...     return g - f</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; dag2 = DAG([f, g, h], name=&#39;arithmetic&#39;)</span>
<span class="sd">        &gt;&gt;&gt; dag2</span>
<span class="sd">        DAG(func_nodes=[FuncNode(a,b -&gt; f_ -&gt; f), FuncNode(c,d -&gt; g_ -&gt; g), FuncNode(f,g -&gt; h_ -&gt; h)], name=&#39;arithmetic&#39;)</span>
<span class="sd">        &gt;&gt;&gt; str(signature(dag2))</span>
<span class="sd">        &#39;(a, b, c, d=4)&#39;</span>
<span class="sd">        &gt;&gt;&gt; dag2(1,2,3)</span>
<span class="sd">        9</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; debugger = dag2.debugger()</span>
<span class="sd">        &gt;&gt;&gt; str(signature(debugger))</span>
<span class="sd">        &#39;(a, b, c, d=4)&#39;</span>
<span class="sd">        &gt;&gt;&gt; d = debugger(1,2,3)</span>
<span class="sd">        &gt;&gt;&gt; next(d)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        0 --------------------------------------------------------------</span>
<span class="sd">            func_node=FuncNode(a,b -&gt; f_ -&gt; f)</span>
<span class="sd">            scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3}</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; next(d)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        1 --------------------------------------------------------------</span>
<span class="sd">            func_node=FuncNode(c,d -&gt; g_ -&gt; g)</span>
<span class="sd">            scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3, &#39;g&#39;: 12}</span>
<span class="sd">        12</span>

<span class="sd">        ... and so on. You can also choose to run every step all at once, collecting</span>
<span class="sd">        the ``feedback`` outputs of each step in a list, like this:</span>

<span class="sd">        &gt;&gt;&gt; feedback_outputs = list(debugger(1,2,3))  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        0 --------------------------------------------------------------</span>
<span class="sd">            func_node=FuncNode(a,b -&gt; f_ -&gt; f)</span>
<span class="sd">            scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3}</span>
<span class="sd">        1 --------------------------------------------------------------</span>
<span class="sd">            func_node=FuncNode(c,d -&gt; g_ -&gt; g)</span>
<span class="sd">            scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3, &#39;g&#39;: 12}</span>
<span class="sd">        2 --------------------------------------------------------------</span>
<span class="sd">            func_node=FuncNode(f,g -&gt; h_ -&gt; h)</span>
<span class="sd">            scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3, &#39;g&#39;: 12, &#39;h&#39;: 9}</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Add feedback callable validation</span>
        <span class="nd">@Sig</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">launch_debugger</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_kwargs</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">step</span><span class="p">,</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">):</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">func_node</span><span class="o">.</span><span class="n">call_on_scope</span><span class="p">(</span><span class="n">scope</span><span class="p">)</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">func_node</span><span class="o">=</span><span class="n">func_node</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="n">scope</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span>
                <span class="p">)</span>
                <span class="k">yield</span> <span class="n">call_forgivingly</span><span class="p">(</span><span class="n">feedback</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">launch_debugger</span></div>

    <span class="c1"># ------------ display --------------------------------------------------------------</span>

    <span class="k">def</span> <span class="nf">synopsis_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind_info</span><span class="p">:</span> <span class="n">BindInfo</span> <span class="o">=</span> <span class="s1">&#39;var_nodes&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="n">func_node</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">(</span><span class="n">bind_info</span><span class="p">)</span> <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span>
        <span class="p">)</span>

    <span class="c1"># TODO: Give more control (merge with lined)</span>
<div class="viewcode-block" id="DAG.dot_digraph_body"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.dot_digraph_body">[docs]</a>    <span class="k">def</span> <span class="nf">dot_digraph_body</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start_lines</span><span class="o">=</span><span class="p">(),</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">end_lines</span><span class="o">=</span><span class="p">(),</span>
        <span class="n">vnode_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">dflt_configs</span><span class="p">[</span><span class="s1">&#39;vnode_shape&#39;</span><span class="p">],</span>
        <span class="n">fnode_shape</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">dflt_configs</span><span class="p">[</span><span class="s1">&#39;fnode_shape&#39;</span><span class="p">],</span>
        <span class="n">func_display</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">dflt_configs</span><span class="p">[</span><span class="s1">&#39;func_display&#39;</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make lines for dot (graphviz) specification of DAG</span>

<span class="sd">        &gt;&gt;&gt; def add(a, b=1): return a + b</span>
<span class="sd">        &gt;&gt;&gt; def mult(x, y=3): return x * y</span>
<span class="sd">        &gt;&gt;&gt; def exp(mult, a): return mult ** a</span>
<span class="sd">        &gt;&gt;&gt; func_nodes = [</span>
<span class="sd">        ...     FuncNode(add, out=&#39;x&#39;), FuncNode(mult, name=&#39;the_product&#39;), FuncNode(exp)</span>
<span class="sd">        ... ]</span>

<span class="sd">        #</span>
<span class="sd">        # &gt;&gt;&gt; assert list(DAG(func_nodes).dot_digraph_body()) == [</span>
<span class="sd">        # ]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_lines</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">start_lines</span> <span class="o">=</span> <span class="n">start_lines</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>  <span class="c1"># TODO: really? split on space?</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">end_lines</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">end_lines</span> <span class="o">=</span> <span class="n">end_lines</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">vnode_shape</span><span class="o">=</span><span class="n">vnode_shape</span><span class="p">,</span> <span class="n">fnode_shape</span><span class="o">=</span><span class="n">fnode_shape</span><span class="p">,</span> <span class="n">func_display</span><span class="o">=</span><span class="n">func_display</span>
        <span class="p">)</span>
        <span class="k">yield from</span> <span class="n">dot_lines_of_objs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="n">start_lines</span><span class="o">=</span><span class="n">start_lines</span><span class="p">,</span> <span class="n">end_lines</span><span class="o">=</span><span class="n">end_lines</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="DAG.dot_digraph_ascii"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.dot_digraph_ascii">[docs]</a>    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph_ascii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get an ascii art string that represents the pipeline&quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">meshed.util</span> <span class="kn">import</span> <span class="n">dot_to_ascii</span>

        <span class="k">return</span> <span class="n">dot_to_ascii</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot_digraph_body</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span></div>

<div class="viewcode-block" id="DAG.dot_digraph"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.DAG.dot_digraph">[docs]</a>    <span class="nd">@wraps</span><span class="p">(</span><span class="n">dot_digraph_body</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dot_digraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">graphviz</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ModuleNotFoundError</span><span class="p">,</span> <span class="ne">ImportError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="se">\n</span><span class="s1">You may not have graphviz installed. &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;See https://pypi.org/project/graphviz/.&#39;</span>
            <span class="p">)</span>
        <span class="c1"># Note: Since graphviz 0.18, need to have a newline in body lines!</span>
        <span class="n">body</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">add_new_line_if_none</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot_digraph_body</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">graphviz</span><span class="o">.</span><span class="n">Digraph</span><span class="p">(</span><span class="n">body</span><span class="o">=</span><span class="n">body</span><span class="p">)</span></div>

    <span class="c1"># NOTE: &quot;sig = property(__signature__)&quot; is not working. So, doing the following instead.</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span>

    <span class="nd">@sig</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">find_funcs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filt</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">FuncNode</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Callable</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">func_node</span><span class="o">.</span><span class="n">func</span> <span class="k">for</span> <span class="n">func_node</span> <span class="ow">in</span> <span class="nb">filter</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">call_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="n">Sig</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">source_kwargs</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">print_dag_string</span><span class="p">(</span><span class="n">dag</span><span class="p">:</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">bind_info</span><span class="p">:</span> <span class="n">BindInfo</span> <span class="o">=</span> <span class="s1">&#39;hybrid&#39;</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">(</span><span class="n">bind_info</span><span class="o">=</span><span class="n">bind_info</span><span class="p">))</span>


<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># dag tools</span>

<span class="c1"># from typing import Iterable, Union</span>
<span class="c1"># from i2 import Sig</span>
<span class="kn">from</span> <span class="nn">meshed.util</span> <span class="kn">import</span> <span class="n">extract_dict</span>


<div class="viewcode-block" id="parametrized_dag_factory"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.parametrized_dag_factory">[docs]</a><span class="k">def</span> <span class="nf">parametrized_dag_factory</span><span class="p">(</span><span class="n">dag</span><span class="p">:</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">param_var_nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a factory for sub-DAGs derived from the input DAG, with values of</span>
<span class="sd">    specific &#39;parameter&#39; variable nodes precomputed and fixed. These precomputed nodes,</span>
<span class="sd">    and their ancestor nodes (unless required elsewhere), are omitted from the sub-DAG.</span>

<span class="sd">    The factory function produced by this operation requires arguments corresponding to</span>
<span class="sd">    the ancestor nodes of the parameter variable nodes. These arguments are used to</span>
<span class="sd">    compute the values of the parameter nodes.</span>

<span class="sd">    This function reflects the typical structure of a class in object-oriented</span>
<span class="sd">    programming, where initialization arguments are used to set certain fixed values</span>
<span class="sd">    (attributes), which are then leveraged in subsequent methods.</span>

<span class="sd">    &gt;&gt;&gt; import i2</span>
<span class="sd">    &gt;&gt;&gt; from meshed import code_to_dag</span>
<span class="sd">    &gt;&gt;&gt; @code_to_dag</span>
<span class="sd">    ... def testdag():</span>
<span class="sd">    ...     a = criss(aa, aaa)</span>
<span class="sd">    ...     b = cross(aa, bb)</span>
<span class="sd">    ...     c = apple(a, b)</span>
<span class="sd">    ...     d = sauce(a, b)</span>
<span class="sd">    ...     e = applesauce(c, d)</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; dag_factory = parametrized_dag_factory(testdag, &#39;a&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(f&quot;{i2.Sig(dag_factory)}&quot;)</span>
<span class="sd">    (aa, aaa)</span>
<span class="sd">    &gt;&gt;&gt; d = dag_factory(aa=1, aaa=2)</span>
<span class="sd">    &gt;&gt;&gt; print(f&quot;{i2.Sig(d)}&quot;)</span>
<span class="sd">    (b)</span>
<span class="sd">    &gt;&gt;&gt; d(b=&#39;bananna&#39;)</span>
<span class="sd">    &#39;applesauce(c=apple(a=criss(aa=1, aaa=2), b=bananna), d=sauce(a=criss(aa=1, aaa=2), b=bananna))&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param_var_nodes</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">param_var_nodes</span> <span class="o">=</span> <span class="n">param_var_nodes</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="c1"># The dag is split into two parts:</span>
    <span class="c1">#   Part whose role it is to compute the param_var_nodes from root nodes</span>
    <span class="n">param_dag</span> <span class="o">=</span> <span class="n">dag</span><span class="p">[:</span><span class="n">param_var_nodes</span><span class="p">]</span>
    <span class="c1">#   Part that computes the rest based on these (and remaining root nodes)</span>
    <span class="n">computation_dag</span> <span class="o">=</span> <span class="n">dag</span><span class="p">[</span><span class="n">param_var_nodes</span><span class="p">:]</span>
    <span class="c1"># Get the intersection of the two parts on the var nodes</span>
    <span class="n">common_var_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">param_dag</span><span class="o">.</span><span class="n">var_nodes</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">computation_dag</span><span class="o">.</span><span class="n">var_nodes</span><span class="p">)</span>

    <span class="nd">@Sig</span><span class="p">(</span><span class="n">param_dag</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">dag_factory</span><span class="p">(</span><span class="o">*</span><span class="n">parametrization_args</span><span class="p">,</span> <span class="o">**</span><span class="n">parametrization_kwargs</span><span class="p">):</span>
        <span class="c1"># use the param_dag to compute the values of the parameter var nodes</span>
        <span class="c1"># (and what ever else happens to be in the leaves, but we&#39;ll remove that later)</span>
        <span class="n">_</span> <span class="o">=</span> <span class="n">param_dag</span><span class="p">(</span><span class="o">*</span><span class="n">parametrization_args</span><span class="p">,</span> <span class="o">**</span><span class="n">parametrization_kwargs</span><span class="p">)</span>
        <span class="c1"># Get the values for all nodes that are common to param_dag and computation_dag</span>
        <span class="c1"># (There may be more than just param_var_nodes!)</span>
        <span class="n">common_var_node_values</span> <span class="o">=</span> <span class="n">extract_dict</span><span class="p">(</span><span class="n">param_dag</span><span class="o">.</span><span class="n">last_scope</span><span class="p">,</span> <span class="n">common_var_nodes</span><span class="p">)</span>
        <span class="c1"># By fixing those values, you now have a the computation_dag you want</span>
        <span class="c1"># Note: Also, remove the bound arguments</span>
        <span class="c1"># (i.e. the arguments that were used to compute the values)</span>
        <span class="c1"># so that the user doesn&#39;t change those and get inconsistencies!</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">computation_dag</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="o">**</span><span class="n">common_var_node_values</span><span class="p">,</span> <span class="n">_remove_bound_arguments</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="c1"># Remember the var nodes that parametrized the dag</span>
        <span class="c1"># TODO: Is this a good idea? Meant for debugging really.</span>
        <span class="n">d</span><span class="o">.</span><span class="n">_common_var_node_values</span> <span class="o">=</span> <span class="n">common_var_node_values</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">return</span> <span class="n">dag_factory</span></div>


<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="c1"># reordering funcnodes</span>

<span class="kn">from</span> <span class="nn">meshed.util</span> <span class="kn">import</span> <span class="n">uncurry</span><span class="p">,</span> <span class="n">pairs</span>

<span class="n">mk_mock_funcnode_from_tuple</span> <span class="o">=</span> <span class="n">uncurry</span><span class="p">(</span><span class="n">mk_mock_funcnode</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">funcnodes_from_pairs</span><span class="p">(</span><span class="n">pairs</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">mk_mock_funcnode_from_tuple</span><span class="p">,</span> <span class="n">pairs</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">reorder_on_constraints</span><span class="p">(</span><span class="n">funcnodes</span><span class="p">,</span> <span class="n">outs</span><span class="p">):</span>
    <span class="n">extra_nodes</span> <span class="o">=</span> <span class="n">funcnodes_from_pairs</span><span class="p">(</span><span class="n">pairs</span><span class="p">(</span><span class="n">outs</span><span class="p">))</span>
    <span class="n">funcnodes</span> <span class="o">+=</span> <span class="n">extra_nodes</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">_func_nodes_to_graph_dict</span><span class="p">(</span><span class="n">funcnodes</span><span class="p">)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">topological_sort</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;after ordering:&#39;</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="n">ordered_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">extra_nodes</span><span class="p">]</span>
    <span class="n">func_nodes</span><span class="p">,</span> <span class="n">var_nodes</span> <span class="o">=</span> <span class="n">_separate_func_nodes_and_var_nodes</span><span class="p">(</span><span class="n">ordered_nodes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">func_nodes</span><span class="p">,</span> <span class="n">var_nodes</span>


<div class="viewcode-block" id="attribute_vals"><a class="viewcode-back" href="../../module_docs/meshed/dag.html#meshed.dag.attribute_vals">[docs]</a><span class="k">def</span> <span class="nf">attribute_vals</span><span class="p">(</span><span class="n">objs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">attrs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">egress</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract attributes from an iterable of objects</span>
<span class="sd">    &gt;&gt;&gt; list(attribute_vals([print, map], attrs=[&#39;__name__&#39;, &#39;__module__&#39;]))</span>
<span class="sd">    [(&#39;print&#39;, &#39;builtins&#39;), (&#39;map&#39;, &#39;builtins&#39;)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">attrs</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">val_tuples</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="o">*</span><span class="n">attrs</span><span class="p">),</span> <span class="n">objs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">egress</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">egress</span><span class="p">(</span><span class="n">val_tuples</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">val_tuples</span></div>


<span class="n">names_and_outs</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">attribute_vals</span><span class="p">,</span> <span class="n">attrs</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;out&#39;</span><span class="p">),</span> <span class="n">egress</span><span class="o">=</span><span class="n">chain</span><span class="p">)</span>

<span class="n">DagAble</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">DAG</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FuncNodeAble</span><span class="p">]]</span>


<span class="c1"># TODO: Extract hardcoded &quot;.name or .out&quot; condition so indexing/condition can be</span>
<span class="c1">#  controlled by user.</span>
<span class="k">def</span> <span class="nf">_validate_func_mapping</span><span class="p">(</span><span class="n">func_mapping</span><span class="p">:</span> <span class="n">FuncMapping</span><span class="p">,</span> <span class="n">func_nodes</span><span class="p">:</span> <span class="n">DagAble</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates a ``FuncMapping`` against an iterable of ``FuncNodes``.</span>

<span class="sd">    That is, it assures that:</span>

<span class="sd">    - The keys of ``func_mapping`` are all ``FuncNode`` identifiers (i.e. appear as a</span>
<span class="sd">    ``.name`` or ``.out`` of one of the ``func_nodes``.</span>

<span class="sd">    - The values of ``func_mapping`` are all callable.</span>

<span class="sd">    &gt;&gt;&gt; def f(a, b):</span>
<span class="sd">    ...     return a + b</span>
<span class="sd">    &gt;&gt;&gt; def g(a_plus_b, x):</span>
<span class="sd">    ...     return a_plus_b * x</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; func_nodes = [</span>
<span class="sd">    ...     FuncNode(func=f, out=&#39;a_plus_b&#39;), FuncNode(func=g, bind={&#39;x&#39;: &#39;b&#39;})</span>
<span class="sd">    ... ]</span>
<span class="sd">    &gt;&gt;&gt; _validate_func_mapping(</span>
<span class="sd">    ...     dict(f=lambda a, b: a - b, g=lambda a_plus_b, x: x), func_nodes</span>
<span class="sd">    ... )</span>

<span class="sd">    You can use the ``.name`` or ``.out`` to index the func_node:</span>

<span class="sd">    &gt;&gt;&gt; _validate_func_mapping(dict(f=lambda a, b: a - b), func_nodes)</span>
<span class="sd">    &gt;&gt;&gt; _validate_func_mapping(dict(a_plus_b=lambda a, b: a - b), func_nodes)</span>

<span class="sd">    If you mention a key that doesn&#39;t correspond to one of the elements of</span>
<span class="sd">    ``func_nodes``, you&#39;ll be told off.</span>

<span class="sd">    &gt;&gt;&gt; _validate_func_mapping(dict(not_a_key=lambda a, b: a - b), func_nodes)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    KeyError: &quot;These identifiers weren&#39;t found in func_nodes: not_a_key&quot;</span>

<span class="sd">    If you mention a value that is not callable, you&#39;ll also be told off:</span>

<span class="sd">    &gt;&gt;&gt; _validate_func_mapping(dict(f=&#39;hello world&#39;), func_nodes)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    TypeError: These values of func_src weren&#39;t callable: hello world</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">allowed_identifiers</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
        <span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">names_and_outs</span><span class="p">(</span><span class="n">DAG</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">not_allowed</span> <span class="o">:=</span> <span class="p">(</span><span class="n">func_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">allowed_identifiers</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;These identifiers weren&#39;t found in func_nodes: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">not_allowed</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">not_callable</span> <span class="o">:=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">func_mapping</span><span class="o">.</span><span class="n">values</span><span class="p">())):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;These values of func_src weren&#39;t callable: </span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">not_callable</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>


<span class="n">FuncMappingValidator</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">FuncMapping</span><span class="p">,</span> <span class="n">DagAble</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>


<span class="c1"># TODO: Redesign. Is terrible both in interface and code.</span>
<span class="c1"># TODO: Merge with DAG, or with Mesh (when it exists)</span>
<span class="c1"># TODO: Make it work with any FuncNode Iterable</span>
<span class="c1"># TODO: extract egress functionality to decorator?</span>
<span class="nd">@double_up_as_factory</span>
<span class="k">def</span> <span class="nf">ch_funcs</span><span class="p">(</span>
    <span class="n">func_nodes</span><span class="p">:</span> <span class="n">DagAble</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">func_mapping</span><span class="p">:</span> <span class="n">FuncMapping</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">validate_func_mapping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FuncMappingValidator</span><span class="p">]</span> <span class="o">=</span> <span class="n">_validate_func_mapping</span><span class="p">,</span>
    <span class="c1"># TODO: Design. Don&#39;t like the fact that ch_func_node_func needs a slot for</span>
    <span class="c1">#  func_comparator, which is then given later. Perhaps only ch_func_node_func should</span>
    <span class="c1">#  should be given (and it contains the func_comparator)</span>
    <span class="n">ch_func_node_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
        <span class="p">[</span><span class="n">FuncNode</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">CallableComparator</span><span class="p">],</span> <span class="n">FuncNode</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">ch_func_node_func</span><span class="p">,</span>
    <span class="c1"># func_comparator: CallableComparator = compare_signatures,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function (and decorator) to change the functions of func_nodes according to</span>
<span class="sd">    the specification of a func_mapping whose keys are ``.name`` or ``.out`` values</span>
<span class="sd">    of the nodes of ``func_nodes`` and the values are the callable we want to replace</span>
<span class="sd">    them by.</span>

<span class="sd">    A constrained version of ``ch_funcs`` is used as a method of ``DAG``.</span>
<span class="sd">    The present function is given to provide more control.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">func_mapping</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">func_mapping</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">validate_func_mapping</span><span class="p">:</span>
        <span class="n">validate_func_mapping</span><span class="p">(</span><span class="n">func_mapping</span><span class="p">,</span> <span class="n">func_nodes</span><span class="p">)</span>

    <span class="c1"># def validate(func_mapping, func_nodes):</span>

    <span class="c1"># def ch_func(dag, key, func):</span>
    <span class="c1">#     return DAG(</span>
    <span class="c1">#         replace_item_in_iterable(</span>
    <span class="c1">#             dag.func_nodes,</span>
    <span class="c1">#             condition=lambda fn: dag._func_node_for.get(key, None) is not None,</span>
    <span class="c1">#             replacement=lambda fn: ch_func_node_func(fn, func=func),</span>
    <span class="c1">#         )</span>
    <span class="c1">#     )</span>

    <span class="c1"># TODO: Optimize (for example, use self._func_node_for)</span>
    <span class="k">def</span> <span class="nf">ch_func</span><span class="p">(</span><span class="n">dag</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">fn</span><span class="p">:</span> <span class="n">fn</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">key</span> <span class="ow">or</span> <span class="n">fn</span><span class="o">.</span><span class="n">out</span> <span class="o">==</span> <span class="n">key</span>  <span class="c1"># TODO: interface ctrl?</span>
        <span class="n">replacement</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">fn</span><span class="p">:</span> <span class="n">ch_func_node_func</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">func</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span>
            <span class="n">replace_item_in_iterable</span><span class="p">(</span>
                <span class="n">dag</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="n">condition</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="n">replacement</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="n">new_dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">func_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">new_dag</span> <span class="o">=</span> <span class="n">ch_func</span><span class="p">(</span><span class="n">new_dag</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_dag</span>

    <span class="c1"># def transformed_func_nodes():</span>
    <span class="c1">#     for fn in func_nodes:</span>
    <span class="c1">#         if (</span>
    <span class="c1">#             new_func := func_mapping.get(fn.out, func_mapping.get(fn.name, None))</span>
    <span class="c1">#         ) is not None:</span>
    <span class="c1">#             new_fn_kwargs = dict(fn.to_dict(), func=new_func)</span>
    <span class="c1">#             yield FuncNode.from_dict(new_fn_kwargs)</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             yield fn</span>

    <span class="c1"># # If func_nodes are input as a DAG (which is an iterable of FuncNodes!),</span>
    <span class="c1"># # make sure to return a DAG as well -- if not, return a list of FuncNodes</span>
    <span class="c1"># if isinstance(func_nodes, DAG):</span>
    <span class="c1">#     return DAG(transformed_func_nodes())</span>
    <span class="c1"># else:</span>
    <span class="c1">#     return list(transformed_func_nodes())</span>


<span class="n">change_funcs</span> <span class="o">=</span> <span class="n">ch_funcs</span>  <span class="c1"># back-compatibility</span>


<span class="c1"># TODO: Include as method of DAG?</span>
<span class="c1"># TODO: extract egress functionality to decorator</span>
<span class="nd">@double_up_as_factory</span>
<span class="k">def</span> <span class="nf">ch_names</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">:</span> <span class="n">DagAble</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">renamer</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">=</span> <span class="n">numbered_suffix_renamer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Renames variables and functions of a ``DAG`` or iterable of ``FuncNodes``.</span>

<span class="sd">    :param func_nodes: A ``DAG`` of iterable of ``FuncNodes``</span>
<span class="sd">    :param renamer: A function taking an old name and returning the new one, or:</span>
<span class="sd">        - A dictionary ``{old_name: new_name, ...}`` mapping old names to new ones</span>
<span class="sd">        - A string, which will be appended to all identifiers of the ``func_nodes``</span>
<span class="sd">    :return: func_nodes with some or all identifiers changed. If the input ``func_nodes``</span>
<span class="sd">    is an iterable of ``FuncNodes``, a list of func_nodes will be returned, and if the</span>
<span class="sd">    input ``func_nodes`` is a ``DAG`` instance, a ``DAG`` will be returned.</span>

<span class="sd">    &gt;&gt;&gt; from meshed.makers import code_to_dag</span>
<span class="sd">    &gt;&gt;&gt; from meshed.dag import print_dag_string</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; @code_to_dag</span>
<span class="sd">    ... def dag():</span>
<span class="sd">    ...     b = f(a)</span>
<span class="sd">    ...     c = g(x=a)</span>
<span class="sd">    ...     d = h(b, y=c)</span>


<span class="sd">    This is what the dag looks like:</span>

<span class="sd">    &gt;&gt;&gt; print_dag_string(dag)</span>
<span class="sd">    a -&gt; f -&gt; b</span>
<span class="sd">    x=a -&gt; g -&gt; c</span>
<span class="sd">    b,y=c -&gt; h -&gt; d</span>

<span class="sd">    Now, if rename the vars of the ``dag`` without further specifying how, all of our</span>
<span class="sd">    nodes (names) will be suffixed with a ``_1``</span>

<span class="sd">    &gt;&gt;&gt; new_dag = ch_names(dag)</span>
<span class="sd">    &gt;&gt;&gt; print_dag_string(new_dag)</span>
<span class="sd">    a=a_1 -&gt; f_1 -&gt; b_1</span>
<span class="sd">    x=a_1 -&gt; g_1 -&gt; c_1</span>
<span class="sd">    b=b_1,y=c_1 -&gt; h_1 -&gt; d_1</span>

<span class="sd">    If any nodes are already suffixed by ``_`` followed by a number, the default</span>
<span class="sd">    renamer (``numbered_suffix_renamer``) will increment that number:</span>

<span class="sd">    &gt;&gt;&gt; another_new_data = ch_names(new_dag)</span>
<span class="sd">    &gt;&gt;&gt; print_dag_string(another_new_data)</span>
<span class="sd">    a=a_2 -&gt; f_2 -&gt; b_2</span>
<span class="sd">    x=a_2 -&gt; g_2 -&gt; c_2</span>
<span class="sd">    b=b_2,y=c_2 -&gt; h_2 -&gt; d_2</span>

<span class="sd">    If we specify a string for the ``renamer`` argument, it will be used to suffix all</span>
<span class="sd">    the nodes.</span>

<span class="sd">    &gt;&gt;&gt; print_dag_string(ch_names(dag, renamer=&#39;_copy&#39;))</span>
<span class="sd">    a=a_copy -&gt; f_copy -&gt; b_copy</span>
<span class="sd">    x=a_copy -&gt; g_copy -&gt; c_copy</span>
<span class="sd">    b=b_copy,y=c_copy -&gt; h_copy -&gt; d_copy</span>

<span class="sd">    Finally, for full functionality on renaming, you can use a function</span>

<span class="sd">    &gt;&gt;&gt; print_dag_string(ch_names(dag, renamer=lambda x: f&quot;{x.upper()}&quot;))</span>
<span class="sd">    a=A -&gt; F -&gt; B</span>
<span class="sd">    x=A -&gt; G -&gt; C</span>
<span class="sd">    b=B,y=C -&gt; H -&gt; D</span>

<span class="sd">    In all the above our input was a ``DAG`` so we got a ``DAG`` back, but if we enter</span>
<span class="sd">    an iterable of ``FuncNode`` instances, we&#39;ll get a list of the same back.</span>
<span class="sd">    Also, know that if your function returns ``None`` for a given identifier, it will</span>
<span class="sd">    have the effect of not changing that identifier.</span>

<span class="sd">    &gt;&gt;&gt; ch_names(dag.func_nodes, renamer=lambda x: x.upper() if x in &#39;abc&#39; else None)</span>
<span class="sd">    [FuncNode(a=A -&gt; f -&gt; B), FuncNode(x=A -&gt; g -&gt; C), FuncNode(b=B,y=C -&gt; h -&gt; d)]</span>

<span class="sd">    If you want to rename the nodes with an explicit mapping, you can do so by</span>
<span class="sd">    specifying this mapping as your renamer</span>

<span class="sd">    &gt;&gt;&gt; substitutions = {&#39;a&#39;: &#39;alpha&#39;, &#39;b&#39;: &#39;bravo&#39;}</span>
<span class="sd">    &gt;&gt;&gt; print_dag_string(ch_names(dag, renamer=substitutions))</span>
<span class="sd">    a=alpha -&gt; f -&gt; bravo</span>
<span class="sd">    x=alpha -&gt; g -&gt; c</span>
<span class="sd">    b=bravo,y=c -&gt; h -&gt; d</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">,</span> <span class="n">DAG</span><span class="p">):</span>
        <span class="n">egress</span> <span class="o">=</span> <span class="n">DAG</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">egress</span> <span class="o">=</span> <span class="nb">list</span>
    <span class="n">renamer</span> <span class="o">=</span> <span class="n">renamer</span> <span class="ow">or</span> <span class="n">numbered_suffix_renamer</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">renamer</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">renamer</span>
        <span class="n">renamer</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">name</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">renamer</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">old_to_new_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">renamer</span><span class="p">)</span>
        <span class="n">renamer</span> <span class="o">=</span> <span class="n">old_to_new_map</span><span class="o">.</span><span class="n">get</span>
    <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">renamer</span><span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;Could not be resolved into a callable: </span><span class="si">{</span><span class="n">renamer</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">ktrans</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">_rename_node</span><span class="p">,</span> <span class="n">renamer</span><span class="o">=</span><span class="n">renamer</span><span class="p">)</span>
    <span class="n">func_node_trans</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">func_node_transformer</span><span class="p">,</span> <span class="n">kwargs_transformers</span><span class="o">=</span><span class="n">ktrans</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">egress</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">func_node_trans</span><span class="p">,</span> <span class="n">func_nodes</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_rename_node</span><span class="p">(</span><span class="n">fn_kwargs</span><span class="p">,</span> <span class="n">renamer</span><span class="p">:</span> <span class="n">Renamer</span> <span class="o">=</span> <span class="n">numbered_suffix_renamer</span><span class="p">):</span>
    <span class="n">fn_kwargs</span> <span class="o">=</span> <span class="n">fn_kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="c1"># decorate renamer so if the original returns None the decorated will return input</span>
    <span class="n">renamer</span> <span class="o">=</span> <span class="n">_if_none_return_input</span><span class="p">(</span><span class="n">renamer</span><span class="p">)</span>
    <span class="n">fn_kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">renamer</span><span class="p">(</span><span class="n">fn_kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
    <span class="n">fn_kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">renamer</span><span class="p">(</span><span class="n">fn_kwargs</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
    <span class="n">fn_kwargs</span><span class="p">[</span><span class="s1">&#39;bind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">param</span><span class="p">:</span> <span class="n">renamer</span><span class="p">(</span><span class="n">var_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">var_id</span> <span class="ow">in</span> <span class="n">fn_kwargs</span><span class="p">[</span><span class="s1">&#39;bind&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">fn_kwargs</span>


<span class="n">rename_nodes</span> <span class="o">=</span> <span class="n">ch_names</span>  <span class="c1"># back-compatibility</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>