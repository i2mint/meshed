

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>meshed.makers &mdash; meshed 0.1.161 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=78f4e1ef"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/toggleprompt.js?v=d7ede5d2"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            meshed
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed.html">meshed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/base.html">meshed.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/caching.html">meshed.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/components.html">meshed.components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/composition.html">meshed.composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/dag.html">meshed.dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples.html">meshed.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/online_marketing.html">meshed.examples.online_marketing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/price_elasticity.html">meshed.examples.price_elasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/examples/vaccine_vs_no_vaccine.html">meshed.examples.vaccine_vs_no_vaccine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext.html">meshed.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk.html">meshed.ext.gk</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/ext/gk_tests.html">meshed.ext.gk_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/itools.html">meshed.itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/makers.html">meshed.makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap.html">meshed.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/annotations_to_meshes.html">meshed.scrap.annotations_to_meshes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/cached_dag.html">meshed.scrap.cached_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/collapse_and_expand.html">meshed.scrap.collapse_and_expand</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/conversion.html">meshed.scrap.conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/dask_graph_language.html">meshed.scrap.dask_graph_language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/flow_control_script.html">meshed.scrap.flow_control_script</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/gk_with_networkx.html">meshed.scrap.gk_with_networkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/gui_interaction.html">meshed.scrap.gui_interaction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/misc_utils.html">meshed.scrap.misc_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/reactive_scope.html">meshed.scrap.reactive_scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/scrap/wrapping_dags.html">meshed.scrap.wrapping_dags</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/slabs.html">meshed.slabs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests.html">meshed.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/objects_for_testing.html">meshed.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_base.html">meshed.tests.test_base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_caching.html">meshed.tests.test_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_ch_funcs.html">meshed.tests.test_ch_funcs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_components.html">meshed.tests.test_components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_composition.html">meshed.tests.test_composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag.html">meshed.tests.test_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_2.html">meshed.tests.test_dag_2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_defaults.html">meshed.tests.test_dag_defaults</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_dag_variadics.html">meshed.tests.test_dag_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_getitem.html">meshed.tests.test_getitem</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_itools.html">meshed.tests.test_itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_makers.html">meshed.tests.test_makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_meshed_tools.html">meshed.tests.test_meshed_tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/test_util.html">meshed.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tests/utils_for_testing.html">meshed.tests.utils_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/tools.html">meshed.tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/util.html">meshed.util</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../module_docs/meshed/viz.html">meshed.viz</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">meshed</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">meshed.makers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for meshed.makers</h1><div class="highlight"><pre>
<span></span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Makers</span>

<span class="sd">This module contains tools to make meshed objects in different ways.</span>

<span class="sd">Let&#39;s start with an example where we have some code representing a user story:</span>

<span class="sd">&gt;&gt;&gt; def user_story():</span>
<span class="sd">...     wfs = call(src_to_wf, data_src)</span>
<span class="sd">...     chks_iter = map(chunker, wfs)</span>
<span class="sd">...     chks = chain(chks_iter)</span>
<span class="sd">...     fvs = map(featurizer, chks)</span>
<span class="sd">...     model_outputs = map(model, fvs)</span>

<span class="sd">If the code is compliant (has only function calls and assignments of their result),</span>
<span class="sd">we can extract ``FuncNode`` factories from these lines (uses AST behind the scenes).</span>

<span class="sd">&gt;&gt;&gt; from meshed.makers import src_to_func_node_factory</span>
<span class="sd">&gt;&gt;&gt; fnodes_factories = list(src_to_func_node_factory(user_story))</span>

<span class="sd">Each factory is a curried version of ``FuncNode``, set up to be able to make a ``DAG``</span>
<span class="sd">equivalent to the user story, once we provide the necessary functions (``call``,</span>
<span class="sd">``map``, and ``chain``).</span>

<span class="sd">&gt;&gt;&gt; from functools import partial</span>
<span class="sd">&gt;&gt;&gt; assert all(</span>
<span class="sd">... isinstance(x, partial) and issubclass(x.func, FuncNode) for x in fnodes_factories</span>
<span class="sd">... )</span>

<span class="sd">See that the ``FuncNode`` factories are all set up with</span>
<span class="sd">``name`` (id),</span>
<span class="sd">``out`` (output variable name),</span>
<span class="sd">``bind`` (names of the variables where the function will source it&#39;s arguments), and</span>
<span class="sd">``func_label`` (which can be used when displaying the DAG, or as a key to the function</span>
<span class="sd">to use).</span>

<span class="sd">&gt;&gt;&gt; assert [x.keywords for x in fnodes_factories] == [</span>
<span class="sd">...  {&#39;name&#39;: &#39;call&#39;,</span>
<span class="sd">...   &#39;out&#39;: &#39;wfs&#39;,</span>
<span class="sd">...   &#39;bind&#39;: {0: &#39;src_to_wf&#39;, 1: &#39;data_src&#39;},</span>
<span class="sd">...   &#39;func_label&#39;: &#39;call&#39;},</span>
<span class="sd">...  {&#39;name&#39;: &#39;map&#39;,</span>
<span class="sd">...   &#39;out&#39;: &#39;chks_iter&#39;,</span>
<span class="sd">...   &#39;bind&#39;: {0: &#39;chunker&#39;, 1: &#39;wfs&#39;},</span>
<span class="sd">...   &#39;func_label&#39;: &#39;map&#39;},</span>
<span class="sd">...  {&#39;name&#39;: &#39;chain&#39;,</span>
<span class="sd">...   &#39;out&#39;: &#39;chks&#39;,</span>
<span class="sd">...   &#39;bind&#39;: {0: &#39;chks_iter&#39;},</span>
<span class="sd">...   &#39;func_label&#39;: &#39;chain&#39;},</span>
<span class="sd">...  {&#39;name&#39;: &#39;map_04&#39;,</span>
<span class="sd">...   &#39;out&#39;: &#39;fvs&#39;,</span>
<span class="sd">...   &#39;bind&#39;: {0: &#39;featurizer&#39;, 1: &#39;chks&#39;},</span>
<span class="sd">...   &#39;func_label&#39;: &#39;map&#39;},</span>
<span class="sd">...  {&#39;name&#39;: &#39;map_05&#39;,</span>
<span class="sd">...   &#39;out&#39;: &#39;model_outputs&#39;,</span>
<span class="sd">...   &#39;bind&#39;: {0: &#39;model&#39;, 1: &#39;fvs&#39;},</span>
<span class="sd">...   &#39;func_label&#39;: &#39;map&#39;}</span>
<span class="sd">... ]</span>

<span class="sd">What can we do with that?</span>

<span class="sd">Well, provide the functions, so the DAG can actually compute.</span>

<span class="sd">You can do it yourself, or get a little help with ``mk_fnodes_from_fn_factories``.</span>

<span class="sd">&gt;&gt;&gt; from meshed.dag import DAG</span>
<span class="sd">&gt;&gt;&gt; from meshed.makers import mk_fnodes_from_fn_factories</span>
<span class="sd">&gt;&gt;&gt; fnodes = list(mk_fnodes_from_fn_factories(fnodes_factories))</span>
<span class="sd">&gt;&gt;&gt; dag = DAG(fnodes)</span>
<span class="sd">&gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">src_to_wf,data_src -&gt; call -&gt; wfs</span>
<span class="sd">chunker,wfs -&gt; map -&gt; chks_iter</span>
<span class="sd">chks_iter -&gt; chain -&gt; chks</span>
<span class="sd">featurizer,chks -&gt; map_04 -&gt; fvs</span>
<span class="sd">model,fvs -&gt; map_05 -&gt; model_outputs</span>

<span class="sd">Wait! But we didn&#39;t actually provide the functions we wanted to use!</span>
<span class="sd">What happened?!?</span>
<span class="sd">What happened is that ``mk_fnodes_from_fn_factories`` just made some for us.</span>
<span class="sd">It used the convenient ``meshed.util.mk_place_holder_func`` which makes a function</span>
<span class="sd">(that happens to actually compute something and be picklable).</span>

<span class="sd">&gt;&gt;&gt; from inspect import signature</span>
<span class="sd">&gt;&gt;&gt; str(signature(dag))</span>
<span class="sd">&#39;(src_to_wf, data_src, chunker, featurizer, model)&#39;</span>

<span class="sd">We can actually call the ``dag`` and get something meaningful:</span>

<span class="sd">&gt;&gt;&gt; dag(1, 2, 3, 4, 5)</span>
<span class="sd">&#39;map(model=5, fvs=map(featurizer=4, chks=chain(chks_iter=map(chunker=3, wfs=call(src_to_wf=1, data_src=2)))))&#39;</span>

<span class="sd">If you don&#39;t want ``mk_fnodes_from_fn_factories`` to do that (because you are in</span>
<span class="sd">prod and need to make sure as much as possible is explicitly as expected, you can</span>
<span class="sd">simply use a different ``factory_to_func`` argument. The default one is:</span>

<span class="sd">&gt;&gt;&gt; from meshed.makers import dlft_factory_to_func</span>

<span class="sd">which you can also reuse to make your own.</span>
<span class="sd">See below how we provide a ``name_to_func_map`` to specify how ``func_label``s should</span>
<span class="sd">map to actual functions, and set ``use_place_holder_fallback=False`` to make</span>
<span class="sd">sure that we don&#39;t ever fallback on a placeholder function as we did above.</span>

<span class="sd">&gt;&gt;&gt; def _call(x, y):</span>
<span class="sd">...     # would use operator.methodcaller(&#39;__call__&#39;) but doesn&#39;t have a __name__</span>
<span class="sd">...     return x + y</span>
<span class="sd">&gt;&gt;&gt; def _map(x, y):</span>
<span class="sd">...     return [x, y]</span>
<span class="sd">&gt;&gt;&gt; def _chain(iterable):</span>
<span class="sd">...     return sum(iterable)</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; factory_to_func = partial(</span>
<span class="sd">...     dlft_factory_to_func,</span>
<span class="sd">...     name_to_func_map={&#39;map&#39;: _map, &#39;chain&#39;: _chain, &#39;call&#39;: _call},</span>
<span class="sd">...     use_place_holder_fallback=False</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; fnodes = list(mk_fnodes_from_fn_factories(fnodes_factories, factory_to_func))</span>
<span class="sd">&gt;&gt;&gt; dag = DAG(fnodes)</span>

<span class="sd">On the surface, we get the same dag as we had before -- at least from the point of view</span>
<span class="sd">of the dag signature, names, and relationships between these names:</span>

<span class="sd">&gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">src_to_wf,data_src -&gt; call -&gt; wfs</span>
<span class="sd">chunker,wfs -&gt; map -&gt; chks_iter</span>
<span class="sd">chks_iter -&gt; chain -&gt; chks</span>
<span class="sd">featurizer,chks -&gt; map_04 -&gt; fvs</span>
<span class="sd">model,fvs -&gt; map_05 -&gt; model_outputs</span>
<span class="sd">&gt;&gt;&gt; str(signature(dag))</span>
<span class="sd">&#39;(src_to_wf, data_src, chunker, featurizer, model)&#39;</span>

<span class="sd">But see below that the dag is now using the functions we specified:</span>

<span class="sd">&gt;&gt;&gt; # dag(src_to_wf=1, data_src=2, chunker=3, featurizer=4, model=5)</span>
<span class="sd">&gt;&gt;&gt; # will trigger this:</span>
<span class="sd">&gt;&gt;&gt; # src_to_wf=1, data_src=2 -&gt; call -&gt; wfs == 1 + 2 == 3</span>
<span class="sd">&gt;&gt;&gt; # chunker=3 , wfs=3 -&gt; map -&gt; chks_iter == [3, 3]</span>
<span class="sd">&gt;&gt;&gt; # chks_iter=6 -&gt; chain -&gt; chks == 3 + 3 == 6</span>
<span class="sd">&gt;&gt;&gt; # featurizer=4, chks=6 -&gt; map_04 -&gt; fvs == [4, 6]</span>
<span class="sd">&gt;&gt;&gt; # model=5, fvs=[4, 6] -&gt; map_05 -&gt; model_outputs == [5, [4, 6]]</span>
<span class="sd">&gt;&gt;&gt; dag(1, 2, 3, 4, 5)</span>
<span class="sd">[5, [4, 6]]</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ast</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">itemgetter</span><span class="p">,</span> <span class="n">attrgetter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Iterator</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">i2</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sig</span><span class="p">,</span> <span class="n">name_of_obj</span><span class="p">,</span> <span class="n">partialx</span><span class="p">,</span> <span class="n">double_up_as_factory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">i2.signatures</span><span class="w"> </span><span class="kn">import</span> <span class="n">name_of_obj</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">meshed.dag</span><span class="w"> </span><span class="kn">import</span> <span class="n">DAG</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">meshed.base</span><span class="w"> </span><span class="kn">import</span> <span class="n">FuncNode</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">meshed.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">mk_place_holder_func</span><span class="p">,</span> <span class="n">ordered_set_operations</span>


<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>

<span class="c1"># Some restrictions exist and need to be clarified or removed (i.e. more cases handled)</span>
<span class="c1"># For example,</span>
<span class="c1"># * can&#39;t reuse a variable (would lead to same node)</span>
<span class="c1"># * x = y (or x, y = tup) not handled (but could easily by binding)</span>
<span class="c1"># We don&#39;t need these cases to be handled, only x = func(...) forms lead to Turing (I</span>
<span class="c1"># think...):</span>
<span class="c1"># Further other cases are not handled, but we don&#39;t want to handle ALL of python</span>
<span class="c1"># -- just a sufficiently expressive subset.</span>


<span class="k">def</span><span class="w"> </span><span class="nf">attr_dict</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">dir</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_from_ast_module</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="s2">&quot;__module__&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_ast&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ast_info_str</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;lineno&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;lineno=</span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;lineno=unknown&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_itemgetter</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">()):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sequence</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sequence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)</span>


<div class="viewcode-block" id="signed_itemgetter">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.signed_itemgetter">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">signed_itemgetter</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Like ``operator.itemgetter``, except has a signature, which we needed&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">partialx</span><span class="p">(</span><span class="n">_itemgetter</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">_rm_partialize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_ast_unparse</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">astunparse</span>

        <span class="k">return</span> <span class="n">astunparse</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">ModuleNotFoundError</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;to see the code, pip install astunparse&gt;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_error_handler</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">_ast_info_str</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">If</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;At </span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2">: You cannot have if statements. &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;Replace them with functional equivalents. (</span><span class="si">{</span><span class="n">body</span><span class="si">=}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_ast_unparse</span><span class="p">(</span><span class="n">body</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Couldn&#39;t find a handler for parsing body with </span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">body</span><span class="si">=}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_ast_unparse</span><span class="p">(</span><span class="n">body</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">parse_body</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">body_index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">_ast_info_str</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Assign</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AnnAssign</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">parse_assignment</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">):</span>
        <span class="n">dummy_var</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">body_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">ast</span><span class="o">.</span><span class="n">Store</span><span class="p">())</span>
        <span class="n">new_assign</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">Assign</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="p">[</span><span class="n">dummy_var</span><span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="n">body</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">parse_assignment</span><span class="p">(</span><span class="n">new_assign</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Return</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># ignore  # TODO: Would like to actually use this</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Expr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Str</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Constant</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># ignore  # TODO: Would like to actually use this</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_error_handler</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>


<span class="c1"># Note: generalize? glom?</span>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_assignment</span><span class="p">(</span><span class="n">body</span><span class="p">:</span> <span class="n">ast</span><span class="o">.</span><span class="n">Assign</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">:</span>
    <span class="c1"># TODO: Make this validation better (at least more help in raised error)</span>
    <span class="c1"># TODO: extract validating code out as validation functions?</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">_ast_info_str</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Assign</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AnnAssign</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All commands should be assignments, this one wasn&#39;t: </span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Assign</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">targets</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">AnnAssign</span><span class="p">):</span>
        <span class="n">target</span> <span class="o">=</span> <span class="p">[</span><span class="n">body</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>  <span class="c1"># ast.AnnAssign has a single target, not a list</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Only one target allowed: </span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
        <span class="n">target</span><span class="p">,</span> <span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Tuple</span><span class="p">)</span>
    <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;Should be a ast.Name or ast.Tuple: </span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">value</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">value</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Call</span><span class="p">),</span> <span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Only assigned function calls are allowed:&quot;</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">info</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">target</span><span class="p">,</span> <span class="n">value</span>


<span class="c1"># TODO: Evolve this: Perhaps it can be used to centralize this concern:</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_extract_value_from_ast_element</span><span class="p">(</span><span class="n">ast_element</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ast_element</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ast_element</span><span class="o">.</span><span class="n">id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ast_element</span><span class="o">.</span><span class="n">value</span>


<div class="viewcode-block" id="parsed_to_node_kwargs">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.parsed_to_node_kwargs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parsed_to_node_kwargs</span><span class="p">(</span><span class="n">target_value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract FuncNode kwargs (name, out, and bind) from ast (target,value) pairs</span>

<span class="sd">    :param target_value: A (target, value) pair</span>
<span class="sd">    :return: A ``{name:..., out:..., bind:...}`` dict (meant to be used to curry FuncNode</span>

<span class="sd">    Where can you make make target_values? With the ``parse_assignment_steps`` function.</span>

<span class="sd">    &gt;&gt;&gt; from meshed.makers import parse_assignment_steps</span>
<span class="sd">    &gt;&gt;&gt; def foo():</span>
<span class="sd">    ...     x = func1(a, b=2)</span>
<span class="sd">    ...     y = func2(x, func1, c=3, d=x)</span>
<span class="sd">    &gt;&gt;&gt; for target_value in parse_assignment_steps(foo):</span>
<span class="sd">    ...     for d in parsed_to_node_kwargs(target_value):</span>
<span class="sd">    ...         print(d)</span>
<span class="sd">    {&#39;name&#39;: &#39;func1&#39;, &#39;out&#39;: &#39;x&#39;, &#39;bind&#39;: {0: &#39;a&#39;, &#39;b&#39;: 2}}</span>
<span class="sd">    {&#39;name&#39;: &#39;func2&#39;, &#39;out&#39;: &#39;y&#39;, &#39;bind&#39;: {0: &#39;x&#39;, 1: &#39;func1&#39;, &#39;c&#39;: 3, &#39;d&#39;: &#39;x&#39;}}</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Note: ast.Tuple has names in &#39;elts&#39; attribute,</span>
    <span class="c1"># and could be handled, but would need to lead to multiple nodes</span>
    <span class="n">target</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">target_value</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">args</span>
    <span class="n">bind_from_args</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">k</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)}</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">arg</span><span class="p">:</span> <span class="n">_extract_value_from_ast_element</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">keywords</span><span class="p">}</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Name</span><span class="p">):</span>
        <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">target</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">bind_from_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Tuple</span><span class="p">):</span>
        <span class="n">assign_to_names</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">),</span> <span class="n">target</span><span class="o">.</span><span class="n">elts</span><span class="p">))</span>
        <span class="c1"># yield the function call information, assigning to a single variable</span>
        <span class="c1"># TODO: Long. Better way? (careful: need global uniqueness!)</span>
        <span class="n">func_output_name</span> <span class="o">=</span> <span class="s2">&quot;__&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">assign_to_names</span><span class="p">)</span>
        <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">value</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">func_output_name</span><span class="p">,</span>
            <span class="n">bind</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">bind_from_args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="c1"># then, yield instructions to extract variable into several</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">assign_to_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">assign_to_names</span><span class="p">):</span>
            <span class="k">yield</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">func</span><span class="o">=</span><span class="n">signed_itemgetter</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
                <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">assign_to_name</span><span class="si">}</span><span class="s2">__</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="n">out</span><span class="o">=</span><span class="n">assign_to_name</span><span class="p">,</span>
                <span class="n">bind</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">func_output_name</span><span class="p">},</span>
                <span class="n">func_label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># raise ValueError(f&quot;You&#39;re here: {target=}&quot;)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Should be a ast.Name or ast.Tuple. Was: </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<span class="n">FuncNodeFactory</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">FuncNode</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">node_kwargs_to_func_node_factory</span><span class="p">(</span><span class="n">node_kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FuncNodeFactory</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">FuncNode</span><span class="p">,</span> <span class="o">**</span><span class="n">node_kwargs</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_src_string</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">src</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_remove_indentation</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\s+&quot;</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">indent_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indent</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">gen</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">src</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">indent</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">line</span><span class="p">[</span><span class="n">indent_length</span><span class="p">:]</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">gen</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;I found no indent!&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">robust_ast_parse</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">IndentationError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">robust_ast_parse</span><span class="p">(</span><span class="n">_remove_indentation</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>


<div class="viewcode-block" id="parse_steps">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.parse_steps">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_steps</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse source code and generate tuples of information about it.</span>

<span class="sd">    :param src: The source string or a python object whose code string can be extracted.</span>
<span class="sd">    :return: And generator of &quot;target_values&quot;</span>

<span class="sd">    &gt;&gt;&gt; from meshed.makers import parse_steps</span>
<span class="sd">    &gt;&gt;&gt; def foo():</span>
<span class="sd">    ...     x = func1(a, b=2)</span>
<span class="sd">    ...     y = func2(x, c=3)</span>
<span class="sd">    &gt;&gt;&gt; target_values = list(parse_steps(foo))</span>

<span class="sd">    Let&#39;s look at the first target_value to see what it contains:</span>

<span class="sd">    &gt;&gt;&gt; name, call = target_values[0]  # a 2-tuple</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(name, ast.Name)  # the first element is a ast Name object</span>
<span class="sd">    &gt;&gt;&gt; sorted(vars(name))</span>
<span class="sd">    [&#39;col_offset&#39;, &#39;ctx&#39;, &#39;end_col_offset&#39;, &#39;end_lineno&#39;, &#39;id&#39;, &#39;lineno&#39;]</span>
<span class="sd">    &gt;&gt;&gt; name.id</span>
<span class="sd">    &#39;x&#39;</span>
<span class="sd">    &gt;&gt;&gt; assert isinstance(call, ast.Call)  # the first element is a ast Call object</span>
<span class="sd">    &gt;&gt;&gt; sorted(vars(call))</span>
<span class="sd">    [&#39;args&#39;, &#39;col_offset&#39;, &#39;end_col_offset&#39;, &#39;end_lineno&#39;, &#39;func&#39;, &#39;keywords&#39;, &#39;lineno&#39;]</span>
<span class="sd">    &gt;&gt;&gt; call.args[0].id</span>
<span class="sd">    &#39;a&#39;</span>
<span class="sd">    &gt;&gt;&gt; call.keywords[0].arg</span>
<span class="sd">    &#39;b&#39;</span>
<span class="sd">    &gt;&gt;&gt; call.keywords[0].value.value</span>
<span class="sd">    2</span>

<span class="sd">    Basically, these ast objects contain all we need to know about the (parsed) source.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">src</span> <span class="o">=</span> <span class="n">_ensure_src_string</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">robust_ast_parse</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">func_body</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># TODO: work with func_body.args to get info on interface (name, args, kwargs,</span>
    <span class="c1">#  return etc.)</span>
    <span class="c1">#     return func_body</span>
    <span class="k">for</span> <span class="n">body_index</span><span class="p">,</span> <span class="n">body</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">func_body</span><span class="o">.</span><span class="n">body</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parsed_body</span> <span class="o">:=</span> <span class="n">parse_body</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">body_index</span><span class="o">=</span><span class="n">body_index</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">parsed_body</span></div>



<span class="n">parse_assignment_steps</span> <span class="o">=</span> <span class="n">parse_steps</span>  <span class="c1"># backcompatible</span>

<span class="n">iterize</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">func</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="nb">map</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>


<span class="n">FuncNodeFactory</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">FuncNode</span><span class="p">]</span>
<span class="n">FactoryToFunc</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">FuncNodeFactory</span><span class="p">],</span> <span class="n">Callable</span><span class="p">]</span>


<div class="viewcode-block" id="src_to_func_node_factory">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.src_to_func_node_factory">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">src_to_func_node_factory</span><span class="p">(</span>
    <span class="n">src</span><span class="p">,</span> <span class="n">exclude_names</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">,</span> <span class="n">FuncNodeFactory</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :param src: Callable or string of callable.</span>
<span class="sd">    :param exclude_names: Names to exclude when making func_nodes</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">exclude_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">exclude_names</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">target_value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parse_assignment_steps</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node_kwargs</span> <span class="ow">in</span> <span class="n">parsed_to_node_kwargs</span><span class="p">(</span><span class="n">target_value</span><span class="p">):</span>
            <span class="n">node_kwargs</span><span class="p">[</span><span class="s2">&quot;func_label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">node_kwargs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">node_kwargs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">exclude_names</span><span class="p">:</span>
                <span class="c1"># need to keep names uniques, so add a prefix to (hope) to get uniqueness</span>
                <span class="n">node_kwargs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">02.0f</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">exclude_names</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node_kwargs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>
            <span class="k">yield</span> <span class="n">node_kwargs_to_func_node_factory</span><span class="p">(</span><span class="n">node_kwargs</span><span class="p">)</span></div>



<span class="n">dlft_factory_to_func</span><span class="p">:</span> <span class="n">FactoryToFunc</span>


<span class="c1"># TODO: A bit strange to ask a factory for information to get a func that it needs</span>
<span class="c1">#  to make itself. Do we gain much over simply saying &quot;factory, make yourself&quot;?</span>
<div class="viewcode-block" id="dlft_factory_to_func">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.dlft_factory_to_func">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dlft_factory_to_func</span><span class="p">(</span>
    <span class="n">factory</span><span class="p">:</span> <span class="n">partial</span><span class="p">,</span>
    <span class="n">name_to_func_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_place_holder_fallback</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a function for the given factory, using&quot;&quot;&quot;</span>
    <span class="c1"># TODO: Add extra validation (like n_args of return func against bind)</span>
    <span class="n">name_to_func_map</span> <span class="o">=</span> <span class="n">name_to_func_map</span> <span class="ow">or</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">factory_kwargs</span> <span class="o">=</span> <span class="n">factory</span><span class="o">.</span><span class="n">keywords</span>
    <span class="n">name</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">factory_kwargs</span><span class="p">[</span><span class="s2">&quot;func_label&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">factory_kwargs</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">factory_kwargs</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">name_to_func_map</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">name_to_func_map</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">use_place_holder_fallback</span><span class="p">:</span>
        <span class="n">arg_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">factory_kwargs</span><span class="p">[</span><span class="s2">&quot;bind&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="n">mk_place_holder_func</span><span class="p">(</span><span class="n">arg_names</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;name not found in name_to_func_map: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="mk_fnodes_from_fn_factories">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.mk_fnodes_from_fn_factories">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mk_fnodes_from_fn_factories</span><span class="p">(</span>
    <span class="n">fnodes_factories</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FuncNodeFactory</span><span class="p">],</span>
    <span class="n">factory_to_func</span><span class="p">:</span> <span class="n">FactoryToFunc</span> <span class="o">=</span> <span class="n">dlft_factory_to_func</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make func nodes from func node factories and a specification of how to make the</span>
<span class="sd">    nodes from these.</span>

<span class="sd">    :param fnodes_factories: An iterable of FuncNodeFactory</span>
<span class="sd">    :param factory_to_func: A function that will give you a function given a</span>
<span class="sd">        FuncNodeFactory input (where it will draw the information it needs to know</span>
<span class="sd">        what kind of function to make).</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: Might be a cleaner design for this...</span>
    <span class="k">for</span> <span class="n">fnode_factory</span> <span class="ow">in</span> <span class="n">fnodes_factories</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">fnode_factory</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sig</span><span class="o">.</span><span class="n">n_required</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sig</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;func&quot;</span><span class="p">:</span>
            <span class="c1"># first making sure the fnode_factory is exactly as expected for this case,</span>
            <span class="c1"># get a function for this fnode_factory, then use it to make the fnode</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">factory_to_func</span><span class="p">(</span><span class="n">fnode_factory</span><span class="p">)</span>
            <span class="k">yield</span> <span class="n">fnode_factory</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">sig</span><span class="o">.</span><span class="n">n_required</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if fnode_factory has no (required) arguments, just call the factory:</span>
            <span class="k">yield</span> <span class="n">fnode_factory</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if couldn&#39;t figure it out from the last two cases, freak out!</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The fnode_factory didn&#39;t have the expected format, so I&#39;m freaking &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;out. It&#39;s supposed to be a no-arguments-required-callable or a &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;functools.partial that needs only a func to make the func node. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;This is the offending fnode_factory: </span><span class="si">{</span><span class="n">fnode_factory</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>



<div class="viewcode-block" id="dlft_factory_to_func_mapping">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.dlft_factory_to_func_mapping">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">dlft_factory_to_func_mapping</span><span class="p">(</span><span class="n">Mapping</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">dlft_factory_to_func</span><span class="p">(</span><span class="n">item</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_code_to_fnodes</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">func_src</span><span class="o">=</span><span class="n">dlft_factory_to_func</span><span class="p">):</span>
    <span class="c1"># Make all the funodes, but partial ones that don&#39;t have the func defined yet</span>
    <span class="n">fnodes_factories</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">src_to_func_node_factory</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
    <span class="c1"># &quot;Inject&quot; the actual functions</span>
    <span class="k">return</span> <span class="n">mk_fnodes_from_fn_factories</span><span class="p">(</span><span class="n">fnodes_factories</span><span class="p">,</span> <span class="n">func_src</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_extract_name_from_single_func_def</span><span class="p">(</span><span class="n">src</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">robust_ast_parse</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">body</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;body&quot;</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">first_element</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">body</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">first_element</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">FunctionDef</span><span class="p">)</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">name</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">first_element</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">name</span>
    <span class="k">return</span> <span class="n">default</span>


<span class="n">FuncSource</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Callable</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span>


<span class="c1"># TODO: Make code_to_fnodes more flexible (not need to be enclosed in a function</span>
<span class="c1">#  definition)</span>
<span class="nd">@double_up_as_factory</span>
<span class="k">def</span><span class="w"> </span><span class="nf">code_to_fnodes</span><span class="p">(</span>
    <span class="n">src</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">func_src</span><span class="p">:</span> <span class="n">FuncSource</span> <span class="o">=</span> <span class="n">dlft_factory_to_func</span><span class="p">,</span>
    <span class="n">use_place_holder_fallback</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get func_nodes from src code&quot;&quot;&quot;</span>
    <span class="n">func_src</span> <span class="o">=</span> <span class="n">_ensure_func_src</span><span class="p">(</span><span class="n">func_src</span><span class="p">,</span> <span class="n">use_place_holder_fallback</span><span class="p">)</span>
    <span class="c1"># Pass on to _code_to_fnodes to get func nodes iterable needed to make DAG</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_code_to_fnodes</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">func_src</span><span class="p">))</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_reconfigure_signature_according_to_src</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dag</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
        <span class="n">new_dag_sig</span> <span class="o">=</span> <span class="n">Sig</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span><span class="o">.</span><span class="n">modified</span><span class="p">(</span><span class="n">_allow_reordering</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">Sig</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_dag_sig</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dag</span>


<span class="nd">@double_up_as_factory</span>
<span class="k">def</span><span class="w"> </span><span class="nf">code_to_dag</span><span class="p">(</span>
    <span class="n">src</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">func_src</span><span class="p">:</span> <span class="n">FuncSource</span> <span class="o">=</span> <span class="n">dlft_factory_to_func</span><span class="p">,</span>
    <span class="n">use_place_holder_fallback</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DAG</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a ``meshed.DAG`` from src code</span>

<span class="sd">    This function parses Python code and creates a DAG that represents the</span>
<span class="sd">    computational flow. The inverse operation is available through ``dag_to_code``</span>
<span class="sd">    which can convert a DAG back to executable Python code.</span>

<span class="sd">    See also: ``dag_to_code`` for the inverse operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fnodes</span> <span class="o">=</span> <span class="n">code_to_fnodes</span><span class="p">(</span>
        <span class="n">src</span><span class="p">,</span> <span class="n">func_src</span><span class="o">=</span><span class="n">func_src</span><span class="p">,</span> <span class="n">use_place_holder_fallback</span><span class="o">=</span><span class="n">use_place_holder_fallback</span>
    <span class="p">)</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">fnodes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">_ensure_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">src</span><span class="p">))</span>
    <span class="n">dag</span><span class="o">.</span><span class="n">_code_to_dag_src</span> <span class="o">=</span> <span class="n">src</span>
    <span class="k">return</span> <span class="n">_reconfigure_signature_according_to_src</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dag</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">code_to_digraph</span><span class="p">(</span><span class="n">src</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">code_to_dag</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">.</span><span class="n">dot_digraph</span><span class="p">()</span>


<span class="n">simple_code_to_digraph</span> <span class="o">=</span> <span class="n">code_to_digraph</span>  <span class="c1"># back-compatability alias</span>

<span class="c1"># import re</span>
<span class="c1"># from typing import Tuple, Iterable, Iterator</span>
<span class="c1"># from meshed import FuncNode, code_to_dag, code_to_fnodes, DAG</span>

<span class="n">extract_tokens</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;\w+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">findall</span>


<div class="viewcode-block" id="triples_to_fnodes">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.triples_to_fnodes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">triples_to_fnodes</span><span class="p">(</span><span class="n">triples</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts an iterable of func call triples to an iterable of ``FuncNode``s.</span>
<span class="sd">    (Which in turn can be converted to a ``DAG``.)</span>

<span class="sd">    Note how the python identifiers are extracted (on the basis of &quot;an unbroken</span>
<span class="sd">    sequence of alphanumerical (and underscore) characters&quot;, ignoring all other</span>
<span class="sd">    characters).</span>

<span class="sd">    &gt;&gt;&gt; from meshed import DAG</span>
<span class="sd">    &gt;&gt;&gt; dag = DAG(</span>
<span class="sd">    ...     triples_to_fnodes(</span>
<span class="sd">    ...     [</span>
<span class="sd">    ...         (&#39;alpha bravo&#39;, &#39;charlie&#39;, &#39;delta echo&#39;),</span>
<span class="sd">    ...         (&#39; foxtrot  &amp;^$#&#39;, &#39;golf&#39;, &#39;  alpha,  echo&#39;),</span>
<span class="sd">    ...     ])</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; print(dag.synopsis_string())</span>
<span class="sd">    delta,echo -&gt; charlie -&gt; alpha__bravo</span>
<span class="sd">    alpha__bravo -&gt; alpha__0 -&gt; alpha</span>
<span class="sd">    alpha__bravo -&gt; bravo__1 -&gt; bravo</span>
<span class="sd">    alpha,echo -&gt; golf -&gt; foxtrot</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">code</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_triple_to_func_call_str</span><span class="p">(</span><span class="o">*</span><span class="n">triple</span><span class="p">)</span> <span class="k">for</span> <span class="n">triple</span> <span class="ow">in</span> <span class="n">triples</span><span class="p">)</span>
    <span class="n">code</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;def main():</span><span class="se">\n\t</span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">return</span> <span class="n">code_to_fnodes</span><span class="p">(</span><span class="n">code</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_triple_to_func_call_str</span><span class="p">(</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts a `(outputs, func_name, inputs)` triple to a function call string.</span>

<span class="sd">    &gt;&gt;&gt; _triple_to_func_call_str((&#39;a&#39;, &#39;b&#39;), &#39;func&#39;, (&#39;c&#39;, &#39;d&#39;))</span>
<span class="sd">    &#39;a, b = func(c, d)&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">_ensure_tokens_iterable</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">_ensure_tokens_iterable</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_tokens_iterable</span><span class="p">(</span><span class="n">tokens</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">extract_tokens</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tokens</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_func_src</span><span class="p">(</span>
    <span class="n">func_src</span><span class="p">:</span> <span class="n">FuncSource</span><span class="p">,</span> <span class="n">use_place_holder_fallback</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Callable</span><span class="p">]:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_src</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">):</span>
        <span class="n">name_to_func_map</span> <span class="o">=</span> <span class="n">func_src</span>
        <span class="n">func_src</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="n">dlft_factory_to_func</span><span class="p">,</span>
            <span class="n">name_to_func_map</span><span class="o">=</span><span class="n">name_to_func_map</span><span class="p">,</span>
            <span class="n">use_place_holder_fallback</span><span class="o">=</span><span class="n">use_place_holder_fallback</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_src</span><span class="p">,</span> <span class="n">Callable</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;func_src should be callable, or a mapping&quot;</span>
    <span class="k">return</span> <span class="n">func_src</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_name</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">_extract_name_from_single_func_def</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="s2">&quot;dag_made_from_code_parsing&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name_of_obj</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">name</span>


<span class="c1"># SB stuff, not used, so comment-out deprecating</span>
<span class="c1"># class AssignNodeVisitor(ast.NodeVisitor):</span>
<span class="c1">#     def __init__(self):</span>
<span class="c1">#         self.store = []</span>
<span class="c1">#</span>
<span class="c1">#     def visit_Assign(self, node):</span>
<span class="c1">#         self.store.append(parse_assignment(node))</span>
<span class="c1">#         return node</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># def retrieve_assignments(src):</span>
<span class="c1">#     if callable(src):</span>
<span class="c1">#         src = inspect.getsource(src)</span>
<span class="c1">#     nodes = ast.parse(src)</span>
<span class="c1">#     visitor = AssignNodeVisitor()</span>
<span class="c1">#     visitor.visit(nodes)</span>
<span class="c1">#</span>
<span class="c1">#     return visitor.store</span>


<span class="k">def</span><span class="w"> </span><span class="nf">lined_dag</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">funcs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dag</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name_of_obj</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">]</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">names</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dag</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="n">NamedFuncs</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span>


<div class="viewcode-block" id="named_funcs_to_func_nodes">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.named_funcs_to_func_nodes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">named_funcs_to_func_nodes</span><span class="p">(</span><span class="n">named_funcs</span><span class="p">:</span> <span class="n">NamedFuncs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make ``FuncNode``s from keyword arguments, using the key as the ``.out`` of the</span>
<span class="sd">    ``FuncNode`` and the value as the ``.func`` of the ``FuncNode``.</span>

<span class="sd">    Example use: To get from ``Slabs`` to ``DAG``.</span>

<span class="sd">    &gt;&gt;&gt; from meshed import DAG</span>
<span class="sd">    &gt;&gt;&gt; func_nodes = list(named_funcs_to_func_nodes(dict(</span>
<span class="sd">    ...     a=lambda x: x + 1,</span>
<span class="sd">    ...     b=lambda a: a + 2,</span>
<span class="sd">    ...     c=lambda a, b: a * b)</span>
<span class="sd">    ... ))</span>
<span class="sd">    &gt;&gt;&gt; dag = DAG(func_nodes)</span>
<span class="sd">    &gt;&gt;&gt; dag(x=3)</span>
<span class="sd">    24</span>

<span class="sd">    The inverse of this function is ``func_nodes_to_named_funcs``.</span>

<span class="sd">    &gt;&gt;&gt; named_funcs = func_nodes_to_named_funcs(dag.func_nodes)</span>
<span class="sd">    &gt;&gt;&gt; dag2 = DAG(named_funcs_to_func_nodes(named_funcs))</span>
<span class="sd">    &gt;&gt;&gt; assert dag2(x=3) == dag(x=3) == 24</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">FuncNode</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s2">_&quot;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span> <span class="k">for</span> <span class="n">out</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">named_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">)</span></div>



<div class="viewcode-block" id="func_nodes_to_named_funcs">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.func_nodes_to_named_funcs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">func_nodes_to_named_funcs</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FuncNode</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">NamedFuncs</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make some components (kwargs) based on the ``.out`` and ``.func`` of the</span>
<span class="sd">    ``FuncNode``s.</span>

<span class="sd">    Example use: To get from ``DAG`` to ``Slabs``.</span>

<span class="sd">    &gt;&gt;&gt; from meshed import DAG, FuncNode</span>
<span class="sd">    &gt;&gt;&gt; dag = DAG([</span>
<span class="sd">    ...     FuncNode(lambda x: x + 1, out=&#39;a&#39;),</span>
<span class="sd">    ...     FuncNode(lambda a: a + 2, out=&#39;b&#39;,),</span>
<span class="sd">    ...     FuncNode(lambda a, b: a * b, out=&#39;c&#39;),</span>
<span class="sd">    ... ])</span>
<span class="sd">    &gt;&gt;&gt; dag(x=10)</span>
<span class="sd">    143</span>
<span class="sd">    &gt;&gt;&gt; named_funcs = func_nodes_to_named_funcs(dag.func_nodes)</span>
<span class="sd">    &gt;&gt;&gt; isinstance(named_funcs, dict)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; list(named_funcs)</span>
<span class="sd">    [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">    &gt;&gt;&gt; callable(named_funcs[&#39;a&#39;])</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; assert dag.find_func_node(&#39;a&#39;).func(3) == named_funcs[&#39;a&#39;](3) ==4</span>

<span class="sd">    The inverse of this function is ``named_funcs_to_func_nodes``.</span>

<span class="sd">    &gt;&gt;&gt; func_nodes = list(named_funcs_to_func_nodes(named_funcs))</span>
<span class="sd">    &gt;&gt;&gt; dag2 = DAG(func_nodes)</span>
<span class="sd">    &gt;&gt;&gt; assert dag2(x=3) == dag(x=3) == 24</span>


<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">out</span><span class="p">:</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">func_nodes</span><span class="p">}</span></div>



<span class="c1"># --------------------------------------------------------------------------------------</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This section contains some ideas around making a two-way interaction between meshed </span>
<span class="sd">and a GUI that will enable the construction of meshes as well as rendering them, </span>
<span class="sd">and possibly running them.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># from typing import Callable</span>
<span class="c1"># from meshed.dag import DAG, FuncNode</span>
<span class="c1"># from meshed.util import mk_place_holder_func</span>
<span class="c1"># from functools import partial</span>

<span class="c1"># TODO: Add default func_to_jdict and dict_to_func that uses mk_place_holder_func to</span>
<span class="c1">#  jdict will be only signature (jdict) and deserializing it will be just placeholder</span>
<span class="n">Jdict</span> <span class="o">=</span> <span class="nb">dict</span>  <span class="c1"># json-serializable dictionary</span>


<span class="k">def</span><span class="w"> </span><span class="nf">fnode_to_jdict</span><span class="p">(</span>
    <span class="n">fnode</span><span class="p">:</span> <span class="n">FuncNode</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">func_to_jdict</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Callable</span><span class="p">],</span> <span class="n">Jdict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">):</span>
    <span class="n">jdict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">fnode</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="s2">&quot;func_label&quot;</span><span class="p">:</span> <span class="n">fnode</span><span class="o">.</span><span class="n">func_label</span><span class="p">,</span>
        <span class="s2">&quot;bind&quot;</span><span class="p">:</span> <span class="n">fnode</span><span class="o">.</span><span class="n">bind</span><span class="p">,</span>
        <span class="s2">&quot;out&quot;</span><span class="p">:</span> <span class="n">fnode</span><span class="o">.</span><span class="n">out</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">func_to_jdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">jdict</span><span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">func_to_jdict</span><span class="p">(</span><span class="n">fnode</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">jdict</span>


<span class="k">def</span><span class="w"> </span><span class="nf">jdict_to_fnode</span><span class="p">(</span><span class="n">jdict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jdict_to_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Jdict</span><span class="p">],</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">jdict_to_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">FuncNode</span><span class="p">(</span>
            <span class="n">func</span><span class="o">=</span><span class="n">jdict_to_func</span><span class="p">(</span><span class="n">jdict</span><span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">]),</span>
            <span class="n">name</span><span class="o">=</span><span class="n">jdict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
            <span class="n">func_label</span><span class="o">=</span><span class="n">jdict</span><span class="p">[</span><span class="s2">&quot;func_label&quot;</span><span class="p">],</span>
            <span class="n">bind</span><span class="o">=</span><span class="n">jdict</span><span class="p">[</span><span class="s2">&quot;bind&quot;</span><span class="p">],</span>
            <span class="n">out</span><span class="o">=</span><span class="n">jdict</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Need a function&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="dag_to_jdict">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.dag_to_jdict">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dag_to_jdict</span><span class="p">(</span><span class="n">dag</span><span class="p">:</span> <span class="n">DAG</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">func_to_jdict</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will produce a json-serializable dictionary from a dag.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fnode_to_jdict_</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">fnode_to_jdict</span><span class="p">,</span> <span class="n">func_to_jdict</span><span class="o">=</span><span class="n">func_to_jdict</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">dag</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
        <span class="s2">&quot;func_nodes&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">fnode_to_jdict_</span><span class="p">,</span> <span class="n">dag</span><span class="o">.</span><span class="n">func_nodes</span><span class="p">)),</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="jdict_to_dag">
<a class="viewcode-back" href="../../module_docs/meshed/makers.html#meshed.makers.jdict_to_dag">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">jdict_to_dag</span><span class="p">(</span><span class="n">jdict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">jdict_to_func</span><span class="p">:</span> <span class="n">Callable</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Will produce a dag from a json-serializable dictionary.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">jdict_to_fnode_</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">jdict_to_fnode</span><span class="p">,</span> <span class="n">jdict_to_func</span><span class="o">=</span><span class="n">jdict_to_func</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="n">jdict</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span>
        <span class="n">func_nodes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">jdict_to_fnode_</span><span class="p">,</span> <span class="n">jdict</span><span class="p">[</span><span class="s2">&quot;func_nodes&quot;</span><span class="p">])),</span>
    <span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>