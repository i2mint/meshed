<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>meshed.dag &mdash; meshed 0.1.109 documentation</title><link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="../../_static/toggleprompt.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="meshed.examples.online_marketing" href="examples/online_marketing.html" />
    <link rel="prev" title="meshed.composition" href="composition.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            meshed
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../meshed.html">meshed</a></li>
<li class="toctree-l1"><a class="reference internal" href="base.html">meshed.base</a></li>
<li class="toctree-l1"><a class="reference internal" href="caching.html">meshed.caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="composition.html">meshed.composition</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">meshed.dag</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#faq-and-troubleshooting">FAQ and Troubleshooting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dags-and-pipelines">DAGs and Pipelines</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples/online_marketing.html">meshed.examples.online_marketing</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/price_elasticity.html">meshed.examples.price_elasticity</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples/vaccine_vs_no_vaccine.html">meshed.examples.vaccine_vs_no_vaccine</a></li>
<li class="toctree-l1"><a class="reference internal" href="ext.html">meshed.ext</a></li>
<li class="toctree-l1"><a class="reference internal" href="ext/gk.html">meshed.ext.gk</a></li>
<li class="toctree-l1"><a class="reference internal" href="ext/gk_tests.html">meshed.ext.gk_tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="itools.html">meshed.itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="makers.html">meshed.makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap.html">meshed.scrap</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/annotations_to_meshes.html">meshed.scrap.annotations_to_meshes</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/cached_dag.html">meshed.scrap.cached_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/conversion.html">meshed.scrap.conversion</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/dask_graph_language.html">meshed.scrap.dask_graph_language</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/gk_with_networkx.html">meshed.scrap.gk_with_networkx</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/misc_utils.html">meshed.scrap.misc_utils</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/reactive_scope.html">meshed.scrap.reactive_scope</a></li>
<li class="toctree-l1"><a class="reference internal" href="scrap/wrapping_dags.html">meshed.scrap.wrapping_dags</a></li>
<li class="toctree-l1"><a class="reference internal" href="slabs.html">meshed.slabs</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests.html">meshed.tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/objects_for_testing.html">meshed.tests.objects_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_base.html">meshed.tests.test_base</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_caching.html">meshed.tests.test_caching</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_ch_funcs.html">meshed.tests.test_ch_funcs</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_composition.html">meshed.tests.test_composition</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_dag.html">meshed.tests.test_dag</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_dag_2.html">meshed.tests.test_dag_2</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_dag_defaults.html">meshed.tests.test_dag_defaults</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_dag_variadics.html">meshed.tests.test_dag_variadics</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_getitem.html">meshed.tests.test_getitem</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_itools.html">meshed.tests.test_itools</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_makers.html">meshed.tests.test_makers</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/test_util.html">meshed.tests.test_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests/utils_for_testing.html">meshed.tests.utils_for_testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="util.html">meshed.util</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">meshed</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">meshed.dag</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/module_docs/meshed/dag.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-meshed.dag">
<span id="meshed-dag"></span><h1>meshed.dag<a class="headerlink" href="#module-meshed.dag" title="Permalink to this headline">¶</a></h1>
<p>Making DAGs</p>
<p>In it’s simplest form, consider this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">meshed</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">this</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">that</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">((</span><span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">,</span> <span class="n">combine</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">())</span>
<span class="go">a,b -&gt; this_ -&gt; this</span>
<span class="go">x,b -&gt; that_ -&gt; that</span>
<span class="go">this,that -&gt; combine_ -&gt; combine</span>
</pre></div>
</div>
<p>But don’t be fooled: There’s much more to it!</p>
<section id="faq-and-troubleshooting">
<h2>FAQ and Troubleshooting<a class="headerlink" href="#faq-and-troubleshooting" title="Permalink to this headline">¶</a></h2>
<section id="dags-and-pipelines">
<h3>DAGs and Pipelines<a class="headerlink" href="#dags-and-pipelines" title="Permalink to this headline">¶</a></h3>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">meshed</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">chunker</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">chk_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">sequence</span><span class="p">)]</span> <span class="o">*</span> <span class="n">chk_size</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_chunker</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">chunker</span><span class="p">,</span> <span class="n">chk_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vec</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>  <span class="c1"># when appropriate, use easier to read sequences</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">my_chunker</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span>
<span class="go">[(0, 1, 2), (3, 4, 5)]</span>
</pre></div>
</div>
<p>Oh, that’s just a <code class="docutils literal notranslate"><span class="pre">my_chunker</span> <span class="pre">-&gt;</span> <span class="pre">list</span></code> pipeline!
A pipeline is a subset of DAG, so let me do this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([</span><span class="n">my_chunker</span><span class="p">,</span> <span class="nb">list</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">TypeError</span>: <span class="n">missing a required argument: &#39;sequence&#39;</span>
</pre></div>
</div>
<p>What happened here?
You’re assuming that saying <code class="docutils literal notranslate"><span class="pre">[my_chunker,</span> <span class="pre">list]</span></code> is enough for DAG to know that
what you meant is for <code class="docutils literal notranslate"><span class="pre">my_chunker</span></code> to feed it’s input to <code class="docutils literal notranslate"><span class="pre">list</span></code>.
Sure, DAG has enough information to do so, but the default connection policy doesn’t
assume that it’s a pipeline you want to make.
In fact, the order you specify the functions doesn’t have an affect on the connections
with the default connection policy.</p>
<p>See what the signature of <code class="docutils literal notranslate"><span class="pre">dag</span></code> is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">dag</span><span class="p">))</span>
<span class="go">&#39;(iterable=(), /, sequence, *, chk_size: int = 3)&#39;</span>
</pre></div>
</div>
<p>So dag actually works just fine. Here’s the proof:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">vec</span><span class="p">)</span>  
<span class="go">([1, 2, 3], &lt;zip object at 0x104d7f080&gt;)</span>
</pre></div>
</div>
<p>It’s just not what you might have intended.</p>
<p>Your best bet to get what you intended is to be explicit.</p>
<p>The way to be explicit is to not specify functions alone, but <code class="docutils literal notranslate"><span class="pre">FuncNodes</span></code> that
wrap them, along with the specification
the <code class="docutils literal notranslate"><span class="pre">name</span></code> the function will be referred to by,
the names that it’s parameters should <code class="docutils literal notranslate"><span class="pre">bind</span></code> to (that is, where the function
will get it’s import arguments from), and
the <code class="docutils literal notranslate"><span class="pre">out</span></code> name of where it should be it’s output.</p>
<p>In the current case a fully specified DAG would look something like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">meshed</span> <span class="kn">import</span> <span class="n">FuncNode</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span>
<span class="gp">... </span>        <span class="n">FuncNode</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">func</span><span class="o">=</span><span class="n">my_chunker</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;chunker&#39;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">bind</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">sequence</span><span class="o">=</span><span class="s1">&#39;sequence&#39;</span><span class="p">,</span> <span class="n">chk_size</span><span class="o">=</span><span class="s1">&#39;chk_size&#39;</span><span class="p">),</span>
<span class="gp">... </span>            <span class="n">out</span><span class="o">=</span><span class="s1">&#39;chks&#39;</span>
<span class="gp">... </span>        <span class="p">),</span>
<span class="gp">... </span>        <span class="n">FuncNode</span><span class="p">(</span>
<span class="gp">... </span>            <span class="n">func</span><span class="o">=</span><span class="nb">list</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">name</span><span class="o">=</span><span class="s1">&#39;gather_chks_into_list&#39;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="n">bind</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="s1">&#39;chks&#39;</span><span class="p">),</span>
<span class="gp">... </span>            <span class="n">out</span><span class="o">=</span><span class="s1">&#39;list_of_chks&#39;</span>
<span class="gp">... </span>        <span class="p">),</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">dag</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span>
<span class="go">[(0, 1, 2), (3, 4, 5)]</span>
</pre></div>
</div>
<p>But really, if you didn’t care about the names of things,
all you need in this case was to make sure that the output of <code class="docutils literal notranslate"><span class="pre">my_chunker</span></code> was
fed to <code class="docutils literal notranslate"><span class="pre">list</span></code>, and therefore the following was sufficient:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="n">my_chunker</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;chks&#39;</span><span class="p">),</span>  <span class="c1"># call the output of chunker &quot;chks&quot;</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">iterable</span><span class="o">=</span><span class="s1">&#39;chks&#39;</span><span class="p">))</span>  <span class="c1"># source list input from &quot;chks&quot;</span>
<span class="gp">... </span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">dag</span><span class="p">(</span><span class="n">vec</span><span class="p">))</span>
<span class="go">[(0, 1, 2), (3, 4, 5)]</span>
</pre></div>
</div>
<p>Connection policies are very useful when you want to define ways for DAG to
“just figure it out” for you.
That is, you want to tell the machine to adapt to your thoughts, not vice versa.
We support such technological expectations!
The default connection policy is there to provide one such ways, but
by all means, use another!</p>
<p>Does this mean that connection policies are not for production code?
Well, it depends. The Zen of Python (<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">this</span></code>)
states “explicit is better than implicit”, and indeed it’s often
a good fallback rule.
But defining components and the way they should be assembled can go a long way
in achieving consistency, separation of concerns, adaptability, and flexibility.
All quite useful things. Also in production. Especially in production.
That said it is your responsiblity to use the right policy for your particular context.</p>
<dl class="py class">
<dt id="meshed.dag.DAG">
<em class="property">class </em><code class="sig-prename descclassname">meshed.dag.</code><code class="sig-name descname">DAG</code><span class="sig-paren">(</span><em class="sig-param">func_nodes: Iterable[Union[meshed.base.FuncNode, Callable]] = (), cache_last_scope: bool = True, parameter_merge: Callable[[Iterable[inspect.Parameter]], inspect.Parameter] = functools.partial(&lt;function parameter_merger&gt;, same_kind=True, same_default=True, same_annotation=True), new_scope: Callable = &lt;class 'dict'&gt;, name: str = None, extract_output_from_scope: Callable[[dict, Iterable[str]], Any] = &lt;function extract_values&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG" title="Permalink to this definition">¶</a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">meshed.dag</span> <span class="kn">import</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Sig</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">this</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">that</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">((</span><span class="n">this</span><span class="p">,</span> <span class="n">that</span><span class="p">,</span> <span class="n">combine</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">())</span>
<span class="go">a,b -&gt; this_ -&gt; this</span>
<span class="go">x,b -&gt; that_ -&gt; that</span>
<span class="go">this,that -&gt; combine_ -&gt; combine</span>
</pre></div>
</div>
<p>But what does it do?</p>
<p>It’s a callable, with a signature:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>  
<span class="go">&lt;Sig (a, x, b=1)&gt;</span>
</pre></div>
</div>
<p>And when you call it, it executes the dag from the root values you give it and
returns the leaf output values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># (a+b,x*b) == (1+3,2*3) == (4, 6)</span>
<span class="go">(4, 6)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># (a+b,x*b) == (1+1,2*1) == (2, 2)</span>
<span class="go">(2, 2)</span>
</pre></div>
</div>
<p>The above DAG was created straight from the functions, using only the names of the
functions and their arguments to define how to hook the network up.</p>
<p>But if you didn’t write those functions specifically for that purpose, or you want
to use someone else’s functions, we got you covered.</p>
<p>You can define the name of the node (the <cite>name</cite> argument), the name of the output
(the <cite>out</cite> argument) and a mapping from the function’s arguments names to
“network names” (through the <cite>bind</cite> argument).
The edges of the DAG are defined by matching <cite>out</cite> TO <cite>bind</cite>.</p>
<dl class="py method">
<dt id="meshed.dag.DAG.add_edge">
<code class="sig-name descname">add_edge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">from_node</span></em>, <em class="sig-param"><span class="n">to_node</span></em>, <em class="sig-param"><span class="n">to_param</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.add_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an e</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_node</strong> – </p></li>
<li><p><strong>to_node</strong> – </p></li>
<li><p><strong>to_param</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new DAG with the edge added</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="n">y</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">three_funcs</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">three_funcs</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="o">**</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">three_funcs</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">())</span>
<span class="go">a,b -&gt; f_ -&gt; f</span>
<span class="go">c,d -&gt; g_ -&gt; g</span>
<span class="go">x,y -&gt; h_ -&gt; h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hg</span> <span class="o">=</span> <span class="n">three_funcs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">hg</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span> <span class="n">g</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">**</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">hg</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">())</span>
<span class="go">a,b -&gt; f_ -&gt; f</span>
<span class="go">x,y -&gt; h_ -&gt; h</span>
<span class="go">h,d -&gt; g_ -&gt; g</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fhg</span> <span class="o">=</span> <span class="n">three_funcs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">fhg</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="mi">7</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="n">g</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)))</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="p">((</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">1</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fhg</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">())</span>
<span class="go">a,b -&gt; f_ -&gt; f</span>
<span class="go">f,y -&gt; h_ -&gt; h</span>
<span class="go">h,d -&gt; g_ -&gt; g</span>
</pre></div>
</div>
<p>The from and to nodes can be expressed by the <code class="docutils literal notranslate"><span class="pre">FuncNode</span></code> <code class="docutils literal notranslate"><span class="pre">name</span></code> (identifier)
or <code class="docutils literal notranslate"><span class="pre">out</span></code>, or even the function itself if it’s used only once in the <code class="docutils literal notranslate"><span class="pre">DAG</span></code>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fhg</span> <span class="o">=</span> <span class="n">three_funcs</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s1">&#39;f_&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">fhg</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span>
</pre></div>
</div>
<p>By default, the edge will be added from <code class="docutils literal notranslate"><span class="pre">from_node.out</span></code> to the first
parameter of the function of <code class="docutils literal notranslate"><span class="pre">to_node</span></code>.
But if you want otherwise, you can specify the parameter the edge should be
connected to.
For example, see below how we connect the outputs of <code class="docutils literal notranslate"><span class="pre">g</span></code> and <code class="docutils literal notranslate"><span class="pre">h</span></code> to the
parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> of <code class="docutils literal notranslate"><span class="pre">f</span></code> respectively:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f_of_g_and_h</span> <span class="o">=</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">DAG</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">to_param</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="p">(</span>
<span class="gp">... </span>    <span class="n">f_of_g_and_h</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">... </span>    <span class="o">==</span> <span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">2</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f_of_g_and_h</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">())</span>
<span class="go">c,d -&gt; g_ -&gt; g</span>
<span class="go">x,y -&gt; h_ -&gt; h</span>
<span class="go">g,h -&gt; f_ -&gt; f</span>
</pre></div>
</div>
<p>See Also <code class="docutils literal notranslate"><span class="pre">DAG.add_edges</span></code> to add multiple edges at once</p>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.add_edges">
<code class="sig-name descname">add_edges</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">edges</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.add_edges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.add_edges" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds multiple edges by applying <code class="docutils literal notranslate"><span class="pre">DAG.add_edge</span></code> multiple times.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>edges</strong> – An iterable of <code class="docutils literal notranslate"><span class="pre">(from_node,</span> <span class="pre">to_node)</span></code> pairs or
<code class="docutils literal notranslate"><span class="pre">(from_node,</span> <span class="pre">to_node,</span> <span class="pre">param)</span></code> triples.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new dag with the said edges added.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">**</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fhg</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span><span class="o">.</span><span class="n">add_edges</span><span class="p">([(</span><span class="n">h</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;f_&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">fhg</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.call_on_scope">
<code class="sig-name descname">call_on_scope</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">scope</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.call_on_scope"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.call_on_scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the func_nodes using scope (a dict or MutableMapping) both to
source it’s arguments and write it’s results.</p>
<p>Note: This method is only meant to be used as a backend to __call__, not as
an actual interface method. Additional control/constraints on read and writes
can be implemented by providing a custom scope for that. For example, one could
log read and/or writes to specific keys, or disallow overwriting to an existing
key (useful for pipeline sanity), etc.</p>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.ch_funcs">
<code class="sig-name descname">ch_funcs</code><span class="sig-paren">(</span><em class="sig-param">func_comparator: Callable[[Callable, Callable], Comparison] = &lt;function compare_signatures&gt;, /, **func_mapping: Callable</em><span class="sig-paren">)</span> &#x2192; <a class="reference internal" href="#meshed.dag.DAG" title="meshed.dag.DAG">meshed.dag.DAG</a><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.ch_funcs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.ch_funcs" title="Permalink to this definition">¶</a></dt>
<dd><p>Change some of the functions in the DAG.
More preciseluy get a copy of the DAG where in some of the functions have
changed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name_and_func</strong> – <code class="docutils literal notranslate"><span class="pre">name=func</span></code> pairs where <code class="docutils literal notranslate"><span class="pre">name</span></code> is the
<code class="docutils literal notranslate"><span class="pre">FuncNode.name</span></code> of the func nodes you want to change and func is the
function you want to change it by.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A new DAG with the different functions.</p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">meshed</span> <span class="kn">import</span> <span class="n">FuncNode</span><span class="p">,</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">Sig</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">a_plus_b</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a_plus_b</span> <span class="o">*</span> <span class="n">x</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f_node</span> <span class="o">=</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;a_plus_b&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g_node</span> <span class="o">=</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;b&#39;</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">((</span><span class="n">f_node</span><span class="p">,</span> <span class="n">g_node</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">())</span>
<span class="go">a,b -&gt; f -&gt; a_plus_b</span>
<span class="go">b,a_plus_b -&gt; g_ -&gt; g</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># (2 + 3) * 3 == 5 * 3</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">ch_funcs</span><span class="p">(</span><span class="n">f</span><span class="o">=</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dd</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># (2 - 3) * 3 == -1 * 3</span>
<span class="go">-3</span>
</pre></div>
</div>
<p>You can reference the <code class="docutils literal notranslate"><span class="pre">FuncNode</span></code> you want to change through its <code class="docutils literal notranslate"><span class="pre">.name</span></code> or
<code class="docutils literal notranslate"><span class="pre">.out</span></code> attribute (both are unique to this <code class="docutils literal notranslate"><span class="pre">FuncNode</span></code> in a <code class="docutils literal notranslate"><span class="pre">DAG</span></code>).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">i2</span> <span class="kn">import</span> <span class="n">Sig</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span> <span class="s1">&#39;f&#39;</span><span class="p">})</span>
<span class="gp">... </span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
<span class="go">&lt;Sig (a, b, f=2, y=1)&gt;</span>
<span class="go">&gt;&gt;&gt;</span>
</pre></div>
</div>
<p>If you replace by a different function with exactly the same signature,
all goes well:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">ch_funcs</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="k">lambda</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">2</span><span class="p">:</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span>
<span class="go">DAG(func_nodes=[FuncNode(a,b -&gt; f -&gt; _f), FuncNode(z=_f,y -&gt; g -&gt; _g)], name=None)</span>
</pre></div>
</div>
<p>But if you change the signature, even slightly you get an error.</p>
<p>Here we didn’t include the defaults:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">ch_funcs</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">You can only change the func of a FuncNode with a another func if the signatures match.</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>Here we include defaults, but <code class="docutils literal notranslate"><span class="pre">z</span></code>’s is different:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">ch_funcs</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="k">lambda</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">200</span><span class="p">:</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">You can only change the func of a FuncNode with a another func if the signatures match.</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>Here the defaults are exactly the same, but the order of parameters is
different:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="o">.</span><span class="n">ch_funcs</span><span class="p">(</span><span class="n">g</span><span class="o">=</span><span class="k">lambda</span> <span class="n">z</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span>  
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">ValueError</span>: <span class="n">You can only change the func of a FuncNode with a another func if the signatures match.</span>
<span class="go">  ...</span>
</pre></div>
</div>
<p>This validation of the functions controlled by the <code class="docutils literal notranslate"><span class="pre">func_comparator</span></code>
argument. By default this is the <code class="docutils literal notranslate"><span class="pre">compare_signatures</span></code> which compares the
signatures of the functions in the strictest way possible.
The is the right choice for a default since it will get you out of trouble
down the line.</p>
<p>But it’s also annoying in many situations, and in those cases you should
specify the <code class="docutils literal notranslate"><span class="pre">func_comparator</span></code> that makes sense for your context.</p>
<p>Since most of the time, you’ll want to compare functions solely based on
their signature, we provide a <code class="docutils literal notranslate"><span class="pre">compare_signatures</span></code> allows you to control the
signature comparison through a <code class="docutils literal notranslate"><span class="pre">signature_comparator</span></code> argument.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">meshed</span> <span class="kn">import</span> <span class="n">compare_signatures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_names</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">sig1</span><span class="p">,</span> <span class="n">sig2</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig1</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig2</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">same_names</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">compare_signatures</span><span class="p">,</span> <span class="n">signature_comparator</span><span class="o">=</span><span class="n">on_names</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">ch_funcs</span><span class="p">(</span><span class="n">same_names</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="k">lambda</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">);</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sig</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
<span class="go">&lt;Sig (a, b, y)&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="go">0.8</span>
</pre></div>
</div>
<p>And this one works too:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">ch_funcs</span><span class="p">(</span><span class="n">same_names</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="k">lambda</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">200</span><span class="p">:</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
<p>But our <code class="docutils literal notranslate"><span class="pre">same_names</span></code> function compared names including their order.
If we want a function with the signature <code class="docutils literal notranslate"><span class="pre">(z=2,</span> <span class="pre">y=1)</span></code> to be able to be
“injected” we’ll need a different comparator:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">_names</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">sig1</span><span class="p">,</span> <span class="n">sig2</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">sig1</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">sig2</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">same_set_of_names</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">compare_signatures</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">signature_comparator</span><span class="o">=</span><span class="p">(</span>
<span class="gp">... </span>        <span class="k">lambda</span> <span class="n">sig1</span><span class="p">,</span> <span class="n">sig2</span><span class="p">:</span> <span class="nb">set</span><span class="p">(</span><span class="n">sig1</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">sig2</span><span class="o">.</span><span class="n">parameters</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">ch_funcs</span><span class="p">(</span><span class="n">same_set_of_names</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="k">lambda</span> <span class="n">z</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.debugger">
<code class="sig-name descname">debugger</code><span class="sig-paren">(</span><em class="sig-param">feedback: Callable = &lt;function dflt_debugger_feedback&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.debugger"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.debugger" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility to debug DAGs by computing each step sequentially, with feedback.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>feedback</strong> – A callable that defines what feedback is given, usually used to
print/log some information and output some information for every step.
Must be a function with signature <code class="docutils literal notranslate"><span class="pre">(func_node,</span> <span class="pre">scope,</span> <span class="pre">output,</span> <span class="pre">step)</span></code> or
a subset thereof.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">g</span> <span class="o">-</span> <span class="n">f</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag2</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;arithmetic&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag2</span>
<span class="go">DAG(func_nodes=[FuncNode(a,b -&gt; f_ -&gt; f), FuncNode(c,d -&gt; g_ -&gt; g), FuncNode(f,g -&gt; h_ -&gt; h)], name=&#39;arithmetic&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">dag2</span><span class="p">))</span>
<span class="go">&#39;(a, b, c, d=4)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag2</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">9</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">debugger</span> <span class="o">=</span> <span class="n">dag2</span><span class="o">.</span><span class="n">debugger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">debugger</span><span class="p">))</span>
<span class="go">&#39;(a, b, c, d=4)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">debugger</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  
<span class="go">0 --------------------------------------------------------------</span>
<span class="go">    func_node=FuncNode(a,b -&gt; f_ -&gt; f)</span>
<span class="go">    scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3}</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">next</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>  
<span class="go">1 --------------------------------------------------------------</span>
<span class="go">    func_node=FuncNode(c,d -&gt; g_ -&gt; g)</span>
<span class="go">    scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3, &#39;g&#39;: 12}</span>
<span class="go">12</span>
</pre></div>
</div>
<p>… and so on. You can also choose to run every step all at once, collecting
the <code class="docutils literal notranslate"><span class="pre">feedback</span></code> outputs of each step in a list, like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">feedback_outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">debugger</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>  
<span class="go">0 --------------------------------------------------------------</span>
<span class="go">    func_node=FuncNode(a,b -&gt; f_ -&gt; f)</span>
<span class="go">    scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3}</span>
<span class="go">1 --------------------------------------------------------------</span>
<span class="go">    func_node=FuncNode(c,d -&gt; g_ -&gt; g)</span>
<span class="go">    scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3, &#39;g&#39;: 12}</span>
<span class="go">2 --------------------------------------------------------------</span>
<span class="go">    func_node=FuncNode(f,g -&gt; h_ -&gt; h)</span>
<span class="go">    scope={&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;f&#39;: 3, &#39;g&#39;: 12, &#39;h&#39;: 9}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.dot_digraph">
<code class="sig-name descname">dot_digraph</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start_lines</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">end_lines</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">vnode_shape</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'none'</span></em>, <em class="sig-param"><span class="n">fnode_shape</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'box'</span></em>, <em class="sig-param"><span class="n">func_display</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.dot_digraph"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.dot_digraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Make lines for dot (graphviz) specification of DAG</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">mult</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span> <span class="k">return</span> <span class="n">mult</span> <span class="o">**</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func_nodes</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">mult</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;the_product&#39;</span><span class="p">),</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="gp">... </span><span class="p">]</span>
</pre></div>
</div>
<p>#
# &gt;&gt;&gt; assert list(DAG(func_nodes).dot_digraph_body()) == [
# ]</p>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.dot_digraph_ascii">
<code class="sig-name descname">dot_digraph_ascii</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start_lines</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">end_lines</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">vnode_shape</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'none'</span></em>, <em class="sig-param"><span class="n">fnode_shape</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'box'</span></em>, <em class="sig-param"><span class="n">func_display</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.dot_digraph_ascii"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.dot_digraph_ascii" title="Permalink to this definition">¶</a></dt>
<dd><p>Make lines for dot (graphviz) specification of DAG</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">mult</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span> <span class="k">return</span> <span class="n">mult</span> <span class="o">**</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func_nodes</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">mult</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;the_product&#39;</span><span class="p">),</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="gp">... </span><span class="p">]</span>
</pre></div>
</div>
<p>#
# &gt;&gt;&gt; assert list(DAG(func_nodes).dot_digraph_body()) == [
# ]</p>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.dot_digraph_body">
<code class="sig-name descname">dot_digraph_body</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start_lines</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">end_lines</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">vnode_shape</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'none'</span></em>, <em class="sig-param"><span class="n">fnode_shape</span><span class="p">:</span> <span class="n">str</span> <span class="o">=</span> <span class="default_value">'box'</span></em>, <em class="sig-param"><span class="n">func_display</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">True</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.dot_digraph_body"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.dot_digraph_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Make lines for dot (graphviz) specification of DAG</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">mult</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span> <span class="k">return</span> <span class="n">mult</span> <span class="o">**</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func_nodes</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">mult</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;the_product&#39;</span><span class="p">),</span> <span class="n">FuncNode</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="gp">... </span><span class="p">]</span>
</pre></div>
</div>
<p>#
# &gt;&gt;&gt; assert list(DAG(func_nodes).dot_digraph_body()) == [
# ]</p>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.extract_output_from_scope">
<code class="sig-name descname">extract_output_from_scope</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">keys</span><span class="p">:</span> <span class="n">Iterable</span></em><span class="sig-paren">)</span><a class="headerlink" href="#meshed.dag.DAG.extract_output_from_scope" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract values from dict <code class="docutils literal notranslate"><span class="pre">d</span></code>, returning them:</p>
<ul class="simple">
<li><p>as a tuple if len(keys) &gt; 1</p></li>
<li><p>a single value if len(keys) == 1</p></li>
<li><p>None if not</p></li>
</ul>
<p>This is used as the default extractor in DAG</p>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.from_funcs">
<em class="property">classmethod </em><code class="sig-name descname">from_funcs</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">funcs</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">named_funcs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.from_funcs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.from_funcs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>funcs</strong> – </p></li>
<li><p><strong>named_funcs</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="o">.</span><span class="n">from_funcs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">x</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">y</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_0</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">_0</span>  <span class="c1"># _0 refers to first arg (lambda a: a * 2)</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dag</span><span class="o">.</span><span class="n">synopsis_string</span><span class="p">())</span>
<span class="go">a -&gt; _0_ -&gt; _0</span>
<span class="go"> -&gt; x_ -&gt; x</span>
<span class="go">x,_0 -&gt; y_ -&gt; y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">16</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.graph_ids">
<em class="property">property </em><code class="sig-name descname">graph_ids</code><a class="headerlink" href="#meshed.dag.DAG.graph_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>The dict representing the <code class="docutils literal notranslate"><span class="pre">{from_node:</span> <span class="pre">to_nodes}</span></code> graph.
Like <code class="docutils literal notranslate"><span class="pre">.graph</span></code>, but with node ids (names).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">meshed.dag</span> <span class="kn">import</span> <span class="n">DAG</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">mult</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span> <span class="k">return</span> <span class="n">mult</span> <span class="o">**</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">DAG</span><span class="p">([</span><span class="n">add</span><span class="p">,</span> <span class="n">mult</span><span class="p">,</span> <span class="n">exp</span><span class="p">])</span><span class="o">.</span><span class="n">graph_ids</span> <span class="o">==</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;add_&#39;</span><span class="p">,</span> <span class="s1">&#39;exp_&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;add_&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;add_&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;add&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;mult_&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;mult_&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;mult_&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;mult&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;mult&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;exp_&#39;</span><span class="p">],</span>
<span class="gp">... </span>    <span class="s1">&#39;exp_&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;exp&#39;</span><span class="p">]</span>
<span class="gp">... </span><span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py attribute">
<dt id="meshed.dag.DAG.new_scope">
<code class="sig-name descname">new_scope</code><a class="headerlink" href="#meshed.dag.DAG.new_scope" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">builtins.dict</span></code></p>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.parameter_merge">
<code class="sig-name descname">parameter_merge</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">same_name</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">same_kind</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">same_default</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">same_annotation</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#meshed.dag.DAG.parameter_merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Validates that all the params are exactly the same, returning the first if so.</p>
<p>This is used when hooking up functions that use the same parameters (i.e. arg
names). When the name of an argument is used more than once, which kind, default,
and annotation should be used in the interface of the DAG?</p>
<p>If they’re all the same, there’s no problem.</p>
<p>But if they’re not the same, we need to provide control on which to ignore.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">Parameter</span> <span class="k">as</span> <span class="n">P</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">PK</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">KO</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameter_merger</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">))</span>
<span class="go">&lt;Parameter &quot;a&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameter_merger</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;different_name&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">),</span> <span class="n">same_name</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;Parameter &quot;a&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameter_merger</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">KO</span><span class="p">),</span> <span class="n">same_kind</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;Parameter &quot;a&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameter_merger</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">,</span>  <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">),</span> <span class="n">same_default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;Parameter &quot;a&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameter_merger</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">42</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">),</span> <span class="n">same_default</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;Parameter &quot;a=42&quot;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameter_merger</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="nb">int</span><span class="p">),</span> <span class="n">P</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">PK</span><span class="p">),</span> <span class="n">same_annotation</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;Parameter &quot;a: int&quot;&gt;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.params_for_src">
<em class="property">property </em><code class="sig-name descname">params_for_src</code><a class="headerlink" href="#meshed.dag.DAG.params_for_src" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="pre">{src_name:</span> <span class="pre">list_of_params_using_that_src,...}</span></code> dictionary.
That is, a <code class="docutils literal notranslate"><span class="pre">dict</span></code> having lists of all <code class="docutils literal notranslate"><span class="pre">Parameter</span></code> objs that are used by a
<code class="docutils literal notranslate"><span class="pre">node.bind</span></code> source (value of <code class="docutils literal notranslate"><span class="pre">node.bind</span></code>) for each such source in the graph</p>
<p>For each <code class="docutils literal notranslate"><span class="pre">func_node</span></code>, <code class="docutils literal notranslate"><span class="pre">func_node.bind</span></code> gives us the
<code class="docutils literal notranslate"><span class="pre">{param:</span> <span class="pre">varnode_src_name}</span></code> specification that tells us where (key of scope)
to source the arguments of the <code class="docutils literal notranslate"><span class="pre">func_node.func</span></code> for each <code class="docutils literal notranslate"><span class="pre">param</span></code> of that
function.</p>
<p>What <code class="docutils literal notranslate"><span class="pre">params_for_src</span></code> is, is the corresponding inverse map.
The <code class="docutils literal notranslate"><span class="pre">{varnode_src_name:</span> <span class="pre">list_of_params}</span></code> gathered by scanning each
<code class="docutils literal notranslate"><span class="pre">func_node</span></code> of the DAG.</p>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.partial">
<code class="sig-name descname">partial</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">positional_dflts</span></em>, <em class="sig-param"><span class="n">_remove_bound_arguments</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">_consider_defaulted_arguments_as_bound</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">keyword_dflts</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.partial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.partial" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a curried version of the DAG.</p>
<p>Like <code class="docutils literal notranslate"><span class="pre">functools.partial</span></code>, but returns a DAG (not just a callable) and allows
you to remove bound arguments as well as roll in orphaned_nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>positional_dflts</strong> – Bind arguments positionally</p></li>
<li><p><strong>keyword_dflts</strong> – Bind arguments through their names</p></li>
<li><p><strong>_remove_bound_arguments</strong> – False – set to True if you don’t want bound
arguments to show up in the signature.</p></li>
<li><p><strong>_consider_defaulted_arguments_as_bound</strong> – False – set to True if
you want to also consider arguments that already had defaults as bound
(and be removed).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">c</span> <span class="o">*</span> <span class="n">d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">g</span> <span class="o">-</span> <span class="n">f</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">dag</span><span class="p">))</span>
<span class="go">&#39;(a, b, c, d=4)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># == (3 * 4) - (1 + 2) == 12 - 3 == 9</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dag</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># same as above</span>
<span class="go">9</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_dag</span> <span class="o">=</span> <span class="n">dag</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">new_dag</span><span class="p">,</span> <span class="n">DAG</span><span class="p">)</span>  <span class="c1"># it&#39;s a dag (not just a partialized callable!)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">str</span><span class="p">(</span><span class="n">signature</span><span class="p">(</span><span class="n">new_dag</span><span class="p">))</span>
<span class="go">&#39;(a, b, c=3, d=4)&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_dag</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># same as dag(c=3, a=1, b=2, d=4), so:</span>
<span class="go">9</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt id="meshed.dag.DAG.src_name_params">
<code class="sig-name descname">src_name_params</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">src_names</span><span class="p">:</span> <span class="n">Optional<span class="p">[</span>Iterable<span class="p">[</span>str<span class="p">]</span><span class="p">, </span>None<span class="p">]</span></span> <span class="o">=</span> <span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#DAG.src_name_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.DAG.src_name_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate Parameter instances that are needed to compute <code class="docutils literal notranslate"><span class="pre">src_names</span></code></p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt id="meshed.dag.attribute_vals">
<code class="sig-prename descclassname">meshed.dag.</code><code class="sig-name descname">attribute_vals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">objs</span><span class="p">:</span> <span class="n">Iterable</span></em>, <em class="sig-param"><span class="n">attrs</span><span class="p">:</span> <span class="n">Iterable<span class="p">[</span>str<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">egress</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#attribute_vals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.attribute_vals" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract attributes from an iterable of objects
&gt;&gt;&gt; list(attribute_vals([print, map], attrs=[‘__name__’, ‘__module__’]))
[(‘print’, ‘builtins’), (‘map’, ‘builtins’)]</p>
</dd></dl>

<dl class="py function">
<dt id="meshed.dag.dot_lines_of_func_nodes">
<code class="sig-prename descclassname">meshed.dag.</code><code class="sig-name descname">dot_lines_of_func_nodes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func_nodes</span><span class="p">:</span> <span class="n">Iterable<span class="p">[</span><a class="reference internal" href="base.html#meshed.base.FuncNode" title="meshed.base.FuncNode">meshed.base.FuncNode</a><span class="p">]</span></span></em>, <em class="sig-param"><span class="n">start_lines</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="n">end_lines</span><span class="o">=</span><span class="default_value">()</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#dot_lines_of_func_nodes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.dot_lines_of_func_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Got lines generator for the graphviz.DiGraph(body=list(…))</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="n">mult</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">mult</span> <span class="o">**</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func_nodes</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="n">mult</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;the_product&#39;</span><span class="p">),</span>
<span class="gp">... </span>    <span class="n">FuncNode</span><span class="p">(</span><span class="n">exp</span><span class="p">)</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dot_lines_of_func_nodes</span><span class="p">(</span><span class="n">func_nodes</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">lines</span> <span class="o">==</span> <span class="p">[</span>
<span class="gp">... </span><span class="s1">&#39;x [label=&quot;x&quot; shape=&quot;none&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;_add [label=&quot;_add&quot; shape=&quot;box&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;_add -&gt; x&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;a [label=&quot;a&quot; shape=&quot;none&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;b [label=&quot;b=&quot; shape=&quot;none&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;a -&gt; _add&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;b -&gt; _add&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;mult [label=&quot;mult&quot; shape=&quot;none&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;the_product [label=&quot;the_product&quot; shape=&quot;box&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;the_product -&gt; mult&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;x [label=&quot;x&quot; shape=&quot;none&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;y [label=&quot;y=&quot; shape=&quot;none&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;x -&gt; the_product&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;y -&gt; the_product&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;exp [label=&quot;exp&quot; shape=&quot;none&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;_exp [label=&quot;_exp&quot; shape=&quot;box&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;_exp -&gt; exp&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;mult [label=&quot;mult&quot; shape=&quot;none&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;a [label=&quot;a&quot; shape=&quot;none&quot;]&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;mult -&gt; _exp&#39;</span><span class="p">,</span>
<span class="gp">... </span><span class="s1">&#39;a -&gt; _exp&#39;</span>
<span class="gp">... </span><span class="p">]</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">meshed.util</span> <span class="kn">import</span> <span class="n">dot_to_ascii</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dot_to_ascii</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)))</span>  

<span class="go">                a        ─┐</span>
<span class="go">                          │</span>
<span class="go">           │              │</span>
<span class="go">           │              │</span>
<span class="go">           ▼              │</span>
<span class="go">         ┌─────────────┐  │</span>
<span class="go"> b=  ──▶ │    _add     │  │</span>
<span class="go">         └─────────────┘  │</span>
<span class="go">           │              │</span>
<span class="go">           │              │</span>
<span class="go">           ▼              │</span>
<span class="go">                          │</span>
<span class="go">                x         │</span>
<span class="go">                          │</span>
<span class="go">           │              │</span>
<span class="go">           │              │</span>
<span class="go">           ▼              │</span>
<span class="go">         ┌─────────────┐  │</span>
<span class="go"> y=  ──▶ │ the_product │  │</span>
<span class="go">         └─────────────┘  │</span>
<span class="go">           │              │</span>
<span class="go">           │              │</span>
<span class="go">           ▼              │</span>
<span class="go">                          │</span>
<span class="go">              mult        │</span>
<span class="go">                          │</span>
<span class="go">           │              │</span>
<span class="go">           │              │</span>
<span class="go">           ▼              │</span>
<span class="go">         ┌─────────────┐  │</span>
<span class="go">         │    _exp     │ ◀┘</span>
<span class="go">         └─────────────┘</span>
<span class="go">           │</span>
<span class="go">           │</span>
<span class="go">           ▼</span>

<span class="go">               exp</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="meshed.dag.hook_up">
<code class="sig-prename descclassname">meshed.dag.</code><code class="sig-name descname">hook_up</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">variables</span><span class="p">:</span> <span class="n">MutableMapping</span></em>, <em class="sig-param"><span class="n">output_name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#hook_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.hook_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Source inputs and write outputs to given variables mapping.</p>
<p>Returns inputless and outputless function that will, when called,
get relevant inputs from the provided variables mapping and write it’s
output there as well.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>variables</strong> – The MutableMapping (like… a dict) where the function</p>
</dd>
</dl>
<p>should both read it’s input and write it’s output.
:param output_name: The key of the variables mapping that should be used
to write the output of the function
:return: A function</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">formula1</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="p">((</span><span class="n">w</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">**</span> <span class="n">z</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">hook_up</span><span class="p">(</span><span class="n">formula1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># NOTE: update d, not d = dict(...), which would make a DIFFERENT d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># not d = dict(w=2, x=3, y=4), which would</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
</pre></div>
</div>
<p>Note that there’s no output. The output is in d
&gt;&gt;&gt; d
{‘w’: 2, ‘x’: 3, ‘y’: 4, ‘formula1’: 20}</p>
<p>Again…</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;formula1&#39;</span><span class="p">]</span>
<span class="go">9</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="meshed.dag.named_partial">
<code class="sig-prename descclassname">meshed.dag.</code><code class="sig-name descname">named_partial</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="n">__name__</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">keywords</span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/meshed/dag.html#named_partial"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#meshed.dag.named_partial" title="Permalink to this definition">¶</a></dt>
<dd><p>functools.partial, but with a __name__</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">named_partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;print&#39;</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">named_partial</span><span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="vm">__name__</span><span class="o">=</span><span class="s1">&#39;now_partial_has_a_name&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span>
<span class="go">&#39;now_partial_has_a_name&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt id="meshed.dag.names_and_outs">
<code class="sig-prename descclassname">meshed.dag.</code><code class="sig-name descname">names_and_outs</code><span class="sig-paren">(</span><em class="sig-param">objs: Iterable</em>, <em class="sig-param">*</em>, <em class="sig-param">attrs: Iterable[str] = ('name'</em>, <em class="sig-param">'out')</em>, <em class="sig-param">egress=&lt;class 'itertools.chain'&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#meshed.dag.names_and_outs" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract attributes from an iterable of objects
&gt;&gt;&gt; list(attribute_vals([print, map], attrs=[‘__name__’, ‘__module__’]))
[(‘print’, ‘builtins’), (‘map’, ‘builtins’)]</p>
</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="composition.html" class="btn btn-neutral float-left" title="meshed.composition" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="examples/online_marketing.html" class="btn btn-neutral float-right" title="meshed.examples.online_marketing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright NO COPYRIGHT.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>